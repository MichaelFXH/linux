<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>sudo</title>
      <link href="/2018/09/17/sudo/"/>
      <url>/2018/09/17/sudo/</url>
      
        <content type="html"><![CDATA[<blockquote><p>sudo命令用来以其他身份来执行命令，预设的身份为root。在/etc/sudoers中设置了可执行sudo指令的用户。若其未经授权的用户企图使用sudo，则会发出警告的邮件给管理员。用户使用sudo时，必须先输入密码，之后有5分钟的有效期限，超过期限则必须重新输入密码。</p></blockquote><a id="more"></a><h1 id="sudo使用"><a href="#sudo使用" class="headerlink" title="sudo使用"></a>sudo使用</h1><p>配置文件：/etc/sudoers, /etc/sudoers.d/<br>用户 登入主机=(代表用户) 命令<br>root ALL=(ALL) ALL<br>格式说明：<br>user: 运行命令者的身份<br>host: 通过哪些主机<br>(runas)：以哪个用户的身份<br>command: 运行哪些命令</p><h2 id="sudo别名"><a href="#sudo别名" class="headerlink" title="sudo别名"></a>sudo别名</h2><p>格式说明：<br>user: 运行命令者的身份<br>host: 通过哪些主机<br>(runas)：以哪个用户的身份<br>command: 运行哪些命令<br>别名有四种类型：User_Alias, Runas_Alias, Host_Alias ，Cmnd_Alias<br>别名格式：<a href="[A-Z][0-9]_">A-Z</a><em><br>别名定义：<br>Alias_Type NAME1 = item1, item2, item3 : NAME2 = item4, item5<br>别名定义：<br>Alias_Type NAME1 = item1, item2, item3 : NAME2 = item4, item5<br>示例2：<br>student ALL=(root) /sbin/pidof,/sbin/ifconfig<br>%wheel ALL=(ALL) NOPASSWD: ALL<br>示例3<br>User_Alias NETADMIN= netuser1,netuser2<br>Cmnd_Alias NETCMD = /usr/sbin/ip<br>NETADMIN ALL=（root） NETCMD<br>示例4<br>User_Alias SYSADER=wang,mage,%admins<br>User_Alias DISKADER=tom<br>Host_Alias SERS=<a href="http://www.magedu.com,172.16.0.0/24" target="_blank" rel="noopener">www.magedu.com,172.16.0.0/24</a><br>Runas_Alias OP=root<br>Cmnd_Alias SYDCMD=/bin/chown,/bin/chmod<br>Cmnd_Alias DSKCMD=/sbin/parted,/sbin/fdisk<br>SYSADER SERS= SYDCMD,DSKCMD<br>DISKADER ALL=(OP) DSKCMD<br>示例5<br>User_Alias ADMINUSER = adminuser1,adminuser2<br>Cmnd_Alias ADMINCMD = /usr/sbin/useradd，/usr/sbin/usermod,<br>/usr/bin/passwd [a-zA-Z]</em>, !/usr/bin/passwd root<br>ADMINUSER ALL=(root) NOPASSWD:ADMINCMD，<br>PASSWD:/usr/sbin/userdel<br>示例6<br>Defaults:wang runas_default=tom<br>wang ALL=(tom,jerry) ALL<br>示例7<br>wang 192.168.1.6,192.168.1.8=(root) /usr/sbin/,!/usr/sbin/useradd<br>示例8<br>wang ALL=(ALL) /bin/cat /var/log/messages*</p><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p>-b：在后台执行指令；<br>-h：显示帮助；<br>-H：将HOME环境变量设为新身份的HOME环境变量；<br>-k：结束密码的有效期限，也就是下次再执行sudo时便需要输入密码；。<br>-l：列出目前用户可执行与无法执行的指令；<br>-p：改变询问密码的提示符号；<br>-s<shell>：执行指定的shell；<br>-u&lt;用户&gt;：以指定的用户作为新的身份。若不加上此参数，则预设以root作为新的身份；<br>-v：延长密码有效期限5分钟；<br>-V ：显示版本信息。</shell></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>配置sudo必须通过编辑/etc/sudoers文件，而且只有超级用户才可以修改它，还必须使用visudo编辑。之所以使用visudo有两个原因，一是它能够防止两个用户同时修改它；二是它也能进行有限的语法检查。所以，即使只有你一个超级用户，你也最好用visudo来检查一下语法。</p><p>visudo默认的是在vi里打开配置文件，用vi来修改文件。我们可以在编译时修改这个默认项。visudo不会擅自保存带有语法错误的配置文件，它会提示你出现的问题，并询问该如何处理，就像：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudoers file: syntax error, line 22 &lt;&lt;</span><br></pre></td></tr></table></figure></p><p>此时我们有三种选择：键入“e”是重新编辑，键入“x”是不保存退出，键入“Q”是退出并保存。如果真选择Q，那么sudo将不会再运行，直到错误被纠正。</p><p>现在，我们一起来看一下神秘的配置文件，学一下如何编写它。让我们从一个简单的例子开始：让用户Foobar可以通过sudo执行所有root可执行的命令。以root身份用visudo打开配置文件，可以看到类似下面几行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Runas alias specification</span><br><span class="line"># User privilege specificationroot    ALL=(ALL)ALL</span><br></pre></td></tr></table></figure></p><p>我们一看就明白个差不多了，root有所有权限，只要仿照现有root的例子就行，我们在下面加一行（最好用tab作为空白）<br>foobar ALL=(ALL)    ALL</p><p>保存退出后，切换到foobar用户，我们用它的身份执行命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[foobar@localhost ~]$ ls /root</span><br><span class="line">ls: /root: 权限不够</span><br><span class="line"></span><br><span class="line">[foobar@localhost ~]$ sudo ls /root</span><br><span class="line">PassWord:</span><br><span class="line">anaconda-ks.cfg Desktop install.log install.log.syslog</span><br></pre></td></tr></table></figure></p><p>好了，我们限制一下foobar的权利，不让他为所欲为。比如我们只想让他像root那样使用ls和ifconfig，把那一行改为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foobar localhost=    /sbin/ifconfig,   /bin/ls</span><br></pre></td></tr></table></figure></p><p>再来执行命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[foobar@localhost ~]$ sudo head -5 /etc/shadow</span><br><span class="line">Password:</span><br><span class="line">Sorry, user foobar is not allowed to execute <span class="string">'/usr/bin/head -5 /etc/shadow'</span> as root on localhost.localdomain.</span><br><span class="line"></span><br><span class="line">[foobar@localhost ~]$ sudo /sbin/ifconfigeth0      Linkencap:Ethernet HWaddr 00:14:85:EC:E9:9B...</span><br></pre></td></tr></table></figure></p><p>现在让我们来看一下那三个ALL到底是什么意思。第一个ALL是指网络中的主机，我们后面把它改成了主机名，它指明foobar可以在此主机上执行后面的命令。第二个括号里的ALL是指目标用户，也就是以谁的身份去执行命令。最后一个ALL当然就是指命令名了。例如，我们想让foobar用户在linux主机上以jimmy或rene的身份执行kill命令，这样编写配置文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foobar    linux=(jimmy,rene)    /bin/<span class="built_in">kill</span></span><br></pre></td></tr></table></figure></p><p>但这还有个问题，foobar到底以jimmy还是rene的身份执行？这时我们应该想到了sudo -u了，它正是用在这种时候。 foobar可以使用sudo -u jimmy kill PID或者sudo -u rene kill PID，但这样挺麻烦，其实我们可以不必每次加-u，把rene或jimmy设为默认的目标用户即可。再在上面加一行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Defaults:foobar    runas_default=rene</span><br></pre></td></tr></table></figure></p><p>Defaults后面如果有冒号，是对后面用户的默认，如果没有，则是对所有用户的默认。就像配置文件中自带的一行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Defaults    env_reset</span><br></pre></td></tr></table></figure></p><p>另一个问题是，很多时候，我们本来就登录了，每次使用sudo还要输入密码就显得烦琐了。我们可不可以不再输入密码呢？当然可以，我们这样修改配置文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foobar localhost=NOPASSWD:     /bin/cat, /bin/ls</span><br></pre></td></tr></table></figure></p><h1 id="日志与安全"><a href="#日志与安全" class="headerlink" title="日志与安全"></a>日志与安全</h1><p>sudo为安全考虑得很周到，不仅可以记录日志，还能在有必要时向系统管理员报告。但是，sudo的日志功能不是自动的，必须由管理员开启。这样来做：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch /var/<span class="built_in">log</span>/sudo</span><br><span class="line">vi /etc/syslog.conf</span><br></pre></td></tr></table></figure></p><p>在syslog.conf最后面加一行（必须用tab分割开）并保存：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local2.debug    /var/<span class="built_in">log</span>/sudo</span><br></pre></td></tr></table></figure></p><p>重启日志守候进程，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux grep syslogd</span><br></pre></td></tr></table></figure></p><p>把得到的syslogd进程的PID（输出的第二列是PID）填入下面：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> –HUP PID</span><br></pre></td></tr></table></figure></p><p>这样，sudo就可以写日志了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[foobar@localhost ~]$ sudo ls /rootanaconda-ks.cfg</span><br><span class="line">Desktop install.log</span><br><span class="line">install.log.syslog</span><br><span class="line"><span class="variable">$cat</span> /var/<span class="built_in">log</span>/sudoJul 28 22:52:54 localhost sudo:   foobar :</span><br><span class="line">TTY=pts/1 ; <span class="built_in">pwd</span>=/home/foobar ; USER=root ; <span class="built_in">command</span>=/bin/ls /root</span><br></pre></td></tr></table></figure></p><p>不过，有一个小小的“缺陷”，sudo记录日志并不是很忠实：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[foobar@localhost ~]$ sudo cat /etc/shadow &gt; /dev/null</span><br><span class="line">cat /var/<span class="built_in">log</span>/sudo...Jul 28 23:10:24 localhost sudo:   foobar : TTY=pts/1 ;</span><br><span class="line">PWD=/home/foobar ; USER=root ; COMMAND=/bin/cat /etc/shadow</span><br></pre></td></tr></table></figure></p><p>重定向没有被记录在案！为什么？因为在命令运行之前，shell把重定向的工作做完了，sudo根本就没看到重定向。这也有个好处，下面的手段不会得逞：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[foobar@localhost ~]$ sudo ls /root &gt; /etc/shadowbash: /etc/shadow: 权限不够</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sudo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>自动化运维工具</title>
      <link href="/2018/09/12/scp/"/>
      <url>/2018/09/12/scp/</url>
      
        <content type="html"><![CDATA[<blockquote><p>自动化运维工具 scp,rsync,sftp</p></blockquote><a id="more"></a><h1 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h1><p>scp命令用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读read only system时，用scp可以帮你把文件移出来。另外，scp还非常不占资源，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。虽然 rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>scp命令：<br>scp [options] SRC… DEST/<br>两种方式：<br>从远程主机拷贝文件<br>scp [options] [user@]host:/sourcefile /destpath<br>把文件拷贝到远程主机<br>scp [options] /sourcefile [user@]host:/destpath<br>常用选项：<br>-C 压缩数据流<br>-r 递归复制<br>-p 保持原文件的属性信息<br>-q 静默模式<br>-P PORT 指明remote host的监听的端口</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ol><li>从远程复制文件到本地<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp root@10.10.10.10:/opt/soft/nginx-0.5.38.tar.gz /opt/soft/</span><br></pre></td></tr></table></figure></li></ol><p>如果复制目录的时候要加-r</p><ol start="2"><li>从本地上传文件到远程<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp  /opt/soft/nginx-0.5.38.tar.gz root@10.10.10.10:/opt/soft/</span><br></pre></td></tr></table></figure></li></ol><p>同样如果复制目录的时候要加-r</p><h1 id="rsync"><a href="#rsync" class="headerlink" title="rsync"></a>rsync</h1><p>rsync命令是一个远程数据同步工具，可通过LAN/WAN快速同步多台主机间的文件。rsync使用所谓的“rsync算法”来使本地和远程两个主机之间的文件达到同步，这个算法只传送两个文件的不同部分，而不是每次都整份传送，因此速度相当快。 rsync是一个功能非常强大的工具，其命令也有很多功能特色选项，我们下面就对它的选项一一进行分析说明。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>rsync [OPTION]… SRC DEST<br>rsync [OPTION]… SRC [USER@]host:DEST<br>rsync [OPTION]… [USER@]HOST:SRC DEST<br>rsync [OPTION]… [USER@]HOST::SRC DEST<br>rsync [OPTION]… SRC [USER@]HOST::DEST<br>rsync [OPTION]… rsync://[USER@]HOST[:PORT]/SRC [DEST]</p><ol><li>拷贝本地文件。当SRC和DES路径信息都不包含有单个冒号”:”分隔符时就启动这种工作模式。如：rsync -a /data /backup</li><li>使用一个远程shell程序(如rsh、ssh)来实现将本地机器的内容拷贝到远程机器。当DST路径地址包含单个冒号”:”分隔符时启动该模式。如：rsync -avz *.c foo:src</li><li>使用一个远程shell程序(如rsh、ssh)来实现将远程机器的内容拷贝到本地机器。当SRC地址路径包含单个冒号”:”分隔符时启动该模式。如：rsync -avz foo:src/bar /data</li><li>从远程rsync服务器中拷贝文件到本地机。当SRC路径信息包含”::”分隔符时启动该模式。如：rsync -av <a href="mailto:root@192.168.78.192" target="_blank" rel="noopener">root@192.168.78.192</a>::www /databack</li><li>从本地机器拷贝文件到远程rsync服务器中。当DST路径信息包含”::”分隔符时启动该模式。如：rsync -av /databack <a href="mailto:root@192.168.78.192" target="_blank" rel="noopener">root@192.168.78.192</a>::www</li><li>列远程机的文件列表。这类似于rsync传输，不过只要在命令中省略掉本地机信息即可。如：rsync -v rsync://192.168.78.192/www</li></ol><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p>-n 模拟复制过程<br>-v 显示详细过程<br>-r 递归复制目录树<br>-p 保留权限<br>-t 保留时间戳<br>-g 保留组信息<br>-o 保留所有者信息<br>-l 将软链接文件本身进行复制（默认）<br>-L 将软链接文件指向的文件复制<br>-a 存档，相当于–rlptgoD，但不保留ACL（-A）和SELinux属性（-X）<br>–delete 删除那些DST中SRC没有的文件。<br>–progress 在传输时现实传输过程。<br>-z, –compress 对备份的文件在传输时进行压缩处理。</p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p><strong>SSH方式</strong></p><p>首先在服务端启动ssh服务：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service sshd start</span><br></pre></td></tr></table></figure></p><p>使用rsync进行同步<br>接下来就可以在客户端使用rsync命令来备份服务端上的数据了，SSH方式是通过系统用户来进行备份的，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -vzrtopg --progress -e ssh --delete root@172.20.58.21:/www/* /databack/experiment/rsync</span><br></pre></td></tr></table></figure></p><p>上面的信息描述了整个的备份过程，以及总共备份数据的大小。</p><p><strong>后台服务方式</strong><br>启动rsync服务，编辑/etc/xinetd.d/rsync文件，将其中的disable=yes改为disable=no，并重启xinetd服务，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># cat /etc/xinetd.d/rsync</span></span><br><span class="line"><span class="comment"># default: off</span></span><br><span class="line"><span class="comment"># description: The rsync server is a good addition to an ftp server, as it \</span></span><br><span class="line"><span class="comment">#       allows crc checksumming etc.</span></span><br><span class="line">service rsync</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">disable</span> = yes</span><br><span class="line">        flags           = IPv6</span><br><span class="line">        socket_type     = stream</span><br><span class="line">        <span class="built_in">wait</span>            = no</span><br><span class="line">        user            = root</span><br><span class="line">        server          = /usr/bin/rsync</span><br><span class="line">        server_args     = --daemon</span><br><span class="line">        log_on_failure  += USERID</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建配置文件，默认安装好rsync程序后，并不会自动创建rsync的主配置文件，需要手工来创建，其主配置文件为“/etc/rsyncd.conf”，创建该文件并插入如下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/rsyncd.conf</span><br><span class="line"></span><br><span class="line">uid=root</span><br><span class="line">gid=root</span><br><span class="line">max connections=4</span><br><span class="line"><span class="built_in">log</span> file=/var/<span class="built_in">log</span>/rsyncd.log</span><br><span class="line">pid file=/var/run/rsyncd.pid</span><br><span class="line">lock file=/var/run/rsyncd.lock</span><br><span class="line">secrets file=/etc/rsyncd.passwd</span><br><span class="line">hosts deny=172.20.58.0/16</span><br><span class="line"></span><br><span class="line">[www]</span><br><span class="line">comment= backup web</span><br><span class="line">path=/www</span><br><span class="line"><span class="built_in">read</span> only = no</span><br><span class="line">exclude=<span class="built_in">test</span></span><br><span class="line">auth users=work</span><br></pre></td></tr></table></figure></p><p>创建密码文件，采用这种方式不能使用系统用户对客户端进行认证，所以需要创建一个密码文件，其格式为“username:password”，用户名可以和密码可以随便定义，最好不要和系统帐户一致，同时要把创建的密码文件权限设置为600，这在前面的模块参数做了详细介绍。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"work:abc123"</span> &gt; /etc/rsyncd.passwd</span><br><span class="line">chmod 600 /etc/rsyncd.passwd</span><br></pre></td></tr></table></figure></p><p>备份，完成以上工作，现在就可以对数据进行备份了，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --progress --delete work@172.16.78.192::www /databack/experiment/rsync</span><br></pre></td></tr></table></figure></p><p>恢复，当服务器的数据出现问题时，那么这时就需要通过客户端的数据对服务端进行恢复，但前提是服务端允许客户端有写入权限，否则也不能在客户端直接对服务端进行恢复，使用rsync对数据进行恢复的方法如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --progress /databack/experiment/rsync/ work@172.16.78.192::www</span><br></pre></td></tr></table></figure></p><h1 id="sftp"><a href="#sftp" class="headerlink" title="sftp"></a>sftp</h1><p>sftp命令是一款交互式的文件传输程序，命令的运行和使用方式与ftp命令相似，但是，sftp命令对传输的所有信息使用ssh加密，它还支持公钥认证和压缩等功能。</p><p>交互式文件传输工具<br>用法和传统的ftp工具相似<br>利用ssh服务实现安全的文件上传和下载<br>使用ls cd mkdir rmdir pwd get put等指令，可用？或help获取帮助信息<br>sftp [user@]host<br>sftp&gt; help</p><h1 id="pssh"><a href="#pssh" class="headerlink" title="pssh"></a>pssh</h1><p>pssh命令是一个python编写可以在多台服务器上执行命令的工具，同时支持拷贝文件，是同类工具中很出色的，类似pdsh，个人认为相对pdsh更为简便，使用必须在各个服务器上配置好密钥认证访问。</p><p><strong>yum方法</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install pssh</span><br></pre></td></tr></table></figure></p><p><strong>编译安装</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget http://parallel-ssh.googlecode.com/files/pssh-2.3.1.tar.gz</span><br><span class="line">tar xf pssh-2.3.1.tar.gz</span><br><span class="line"><span class="built_in">cd</span> pssh-2.3.1/</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure></p><h2 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h2><p>–version：查看版本<br>–help：查看帮助，即此信息<br>-h：主机文件列表，内容格式”[user@]host[:port]”<br>-H：主机字符串，内容格式”[user@]host[:port]”<br>-：登录使用的用户名<br>-p：并发的线程数【可选】<br>-o：输出的文件目录【可选】<br>-e：错误输入文件【可选】<br>-t：TIMEOUT 超时时间设置，0无限制【可选】<br>-O：SSH的选项<br>-v：详细模式<br>-A：手动输入密码模式<br>-x：额外的命令行参数使用空白符号，引号，反斜线处理<br>-X：额外的命令行参数，单个参数模式，同-x<br>-i：每个服务器内部处理信息输出<br>-P：打印出服务器返回信息</p><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><p>获取每台服务器的uptime：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pssh -h ip.txt -i uptime</span><br></pre></td></tr></table></figure></p><p>查看每台服务器上mysql复制IO/SQL线程运行状态信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pssh -h IP.txt -i <span class="string">"/usr/local/mysql/bin/mysql -e 'show slave status \G'"</span>|grep Running:</span><br></pre></td></tr></table></figure></p><p>保存每台服务器运行的结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pssh -h IP.txt -i -o /tmp/pssh/ uptime</span><br></pre></td></tr></table></figure></p><p>通过pssh批量关闭seLinux<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pssh -H root@192.168.1.10 -i <span class="string">"sed -i "</span>s/SELINUX=enforcing/SELINUX=disabled/<span class="string">" /etc/selinux/config"</span></span><br></pre></td></tr></table></figure></p><p>批量发送指令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pssh -H root@192.168.1.10 -i setenforce 0</span><br><span class="line">pssh -H xuewb@192.168.1.10 -i hostname</span><br></pre></td></tr></table></figure></p><p>当不支持ssh的key认证时，通过 -A选项，使用密码认证批量执行指令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pssh -H xuewb@192.168.1.10 -A -i hostname</span><br></pre></td></tr></table></figure></p><p>将标准错误和标准正确重定向都保存至/app目录下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pssh -H 192.168.1.10 -o /app -e /app -i <span class="string">"hostname"</span></span><br></pre></td></tr></table></figure></p><h1 id="PSCP-PSSH"><a href="#PSCP-PSSH" class="headerlink" title="PSCP.PSSH"></a>PSCP.PSSH</h1><p>pscp.pssh功能是将本地文件批量复制到远程主机<br>pscp [-vAr] [-h hosts_file] [-H [user@]host[:port]] [-l user] [-p par] [-o<br>outdir] [-e errdir] [-t timeout] [-O options] [-x args] [-X arg] local remote<br>Pscp-pssh选项<br>-v 显示复制过程<br>-r 递归复制目录<br>将本地curl.sh 复制到/app/目录<br>pscp.pssh -H 192.168.1.10 /root/test/curl.sh /app/<br>pscp.pssh -h host.txt /root/test/curl.sh /app/<br>将本地多个文件批量复制到/app/目录<br>pscp.pssh -H 192.168.1.10 /root/f1.sh /root/f2.sh /app/<br>将本地目录批量复制到/app/目录<br>pscp.pssh -H 192.168.1.10 -r /root/test/ /app/</p><h1 id="PSLURP"><a href="#PSLURP" class="headerlink" title="PSLURP"></a>PSLURP</h1><p>pslurp功能是将远程主机的文件批量复制到本地<br>pslurp [-vAr] [-h hosts_file] [-H [user@]host[:port]] [-l user] [-p par][-o<br>outdir] [-e errdir] [-t timeout] [-O options] [-x args] [-X arg] [-L localdir]<br>remote local（本地名）<br>Pslurp选项<br>-L 指定从远程主机下载到本机的存储的目录，local是下载到本地后的名称<br>-r 递归复制目录<br>批量下载目标服务器的passwd文件至/app下，并更名为user<br>pslurp -H 192.168.1.10 -L /app/ /etc/passwd user</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scp,rsync,sftp,pssh </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SSH</title>
      <link href="/2018/09/12/ssh/"/>
      <url>/2018/09/12/ssh/</url>
      
        <content type="html"><![CDATA[<blockquote><p>SSH 基于密码跟基于Key的验证，SSH端口转发,SSH最佳实践</p></blockquote><a id="more"></a><p>当用户远程连接ssh服务器时，会复制ssh服务器/etc/ssh/ssh_host*key.pub<br>（CentOS7默认是ssh_host_ecdsa_key.pub）文件中的公钥到客户机的<br>~./ssh/know_hosts中。下次连接时，会自动匹配相应私钥，不能匹配，将拒绝连接</p><p>查看ssh相关文件<br>rpm -ql openssh-server</p><p>客户端组件：<br>ssh, 配置文件：/etc/ssh/ssh_config<br>语法<br>ssh [user@]host [COMMAND]<br>ssh [-l user] host [COMMAND]<br>常见选项<br>-p port：远程服务器监听的端口<br>-b:指定连接的源IP<br>-v:调试模式<br>-C：压缩方式<br>-X: 支持x11转发<br>-Y：支持信任x11转发<br>ForwardX11Trusted yes<br>-t: 强制伪tty分配<br>ssh -t remoteserver1 ssh remoteserver2</p><p><strong>执行命令</strong><br>ssh  <a href="mailto:wang@10.1.1.1" target="_blank" rel="noopener">wang@10.1.1.1</a> ‘cat /etc/centos-release’<br><strong>p指定端口</strong><br>服务端<br>vim /etc/ssh/sshd_config 把port 修改<br>systemctl reload sshd 生效<br>客户端<br>ssh  <a href="mailto:wang@10.1.1.1" target="_blank" rel="noopener">wang@10.1.1.1</a> -p 2222</p><p><strong>b 指定ip去连接</strong><br>ssh  -b 192.212.11.11 <a href="mailto:wang@10.1.1.1" target="_blank" rel="noopener">wang@10.1.1.1</a> -p 2222</p><p><strong>X 远程打开服务器端程序</strong><br>ssh -X IP<br>nm-connection-editor<br><strong>t: 强制伪tty分配</strong><br>ssh  -t 192.212.11.11 ssh -t 192.212.11.11</p><h1 id="基于用户名密码的登陆"><a href="#基于用户名密码的登陆" class="headerlink" title="基于用户名密码的登陆"></a>基于用户名密码的登陆</h1><p>基于用户和口令登录验证</p><ol><li>客户端发起ssh请求，服务器会把自己的公钥发送给用户</li><li>用户会根据服务器发来的公钥对密码进行加密</li><li>加密后的信息回传给服务器，服务器用自己的私钥解密，如果密码正确，则用户登录成功</li></ol><h1 id="基于key密钥的登录方式"><a href="#基于key密钥的登录方式" class="headerlink" title="基于key密钥的登录方式"></a>基于key密钥的登录方式</h1><ol><li>首先在客户端生成一对密钥（ssh-keygen）</li><li>并将客户端的公钥ssh-copy-id 拷贝到服务端</li><li>当客户端再次发送一个连接请求，包括ip、用户名</li><li>服务端得到客户端的请求后，会到authorized_keys中查找，如果有响应的IP和用户，就会随机生成一个字符串，例如：acdf</li><li>服务端将使用客户端拷贝过来的公钥进行加密，然后发送给客户端</li><li>得到服务端发来的消息后，客户端会使用私钥进行解密，然后将解密后的字符串发送给服务端</li><li>服务端接受到客户端发来的字符串后，跟之前的字符串进行对比，如果一致，就允许免密码登录</li></ol><h2 id="ssh-keygen实现"><a href="#ssh-keygen实现" class="headerlink" title="ssh-keygen实现"></a>ssh-keygen实现</h2><p>修改/etc/ssh/sshd_config 文件，将RSAAuthentication 和 PubkeyAuthentication 后面的值都改成yes ，保存。</p><ol><li><p>在客户端生成一对公钥私钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure></li><li><p>把公钥发给对方</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i id_rsa root@169.254.59.100</span><br></pre></td></tr></table></figure></li></ol><p>重新设置口令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -p</span><br></pre></td></tr></table></figure></p><p>但是每次连接对方都要设置口令，很麻烦，这时可以使用代理<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-agent bash</span><br><span class="line">ssh-add</span><br></pre></td></tr></table></figure></p><p>再次连接对方则不需要输入口令了。</p><p>实现了不需要用户名密码就可以登陆了，我们可以在远程机器上拷贝文件，执行命令<br>拷贝文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> `cat ip.txt`;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  scp f1.sh <span class="variable">$ip</span>:/data/;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p>执行命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> `cat ip.txt`;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  ssh  <span class="variable">$ip</span>  <span class="string">"/data/f1.sh"</span>;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><h2 id="三台主机实现基于Key验证"><a href="#三台主机实现基于Key验证" class="headerlink" title="三台主机实现基于Key验证"></a>三台主机实现基于Key验证</h2><ol><li><p>在当前的A主机上生成一对密钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen </span><br><span class="line">ssh-copy-id A</span><br></pre></td></tr></table></figure></li><li><p>把/roots/.ssh 目录拷贝到其他主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -rp /root/.ssh B:/root/</span><br><span class="line">scp -rp /root/.ssh C:/root/</span><br></pre></td></tr></table></figure></li></ol><h2 id="secureCRT生成key验证"><a href="#secureCRT生成key验证" class="headerlink" title="secureCRT生成key验证"></a>secureCRT生成key验证</h2><ol><li>secureCRT tools - createpublickey</li><li>传到linux</li><li>重命名为authorized_keys<br>mv Identity.pub authorized_keys</li><li>客户端直接可以连接了</li></ol><h2 id="批量把本机的公钥拷贝到其他服务器-待完善"><a href="#批量把本机的公钥拷贝到其他服务器-待完善" class="headerlink" title="批量把本机的公钥拷贝到其他服务器 待完善"></a>批量把本机的公钥拷贝到其他服务器 待完善</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">rpm -q expect &amp;&gt; /dev/null || yum install expect -y</span><br><span class="line">ssh-keygen  -P <span class="string">""</span> -f <span class="string">"/root/.ssh/id_rsa"</span></span><br><span class="line">password=centos</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> ipaddr;<span class="keyword">do</span></span><br><span class="line">expect &lt;&lt;EOF</span><br><span class="line"><span class="built_in">set</span> timeout 10</span><br><span class="line">spawn ssh-copy-id <span class="variable">$ipaddr</span></span><br><span class="line">expect &#123;</span><br><span class="line"><span class="string">"yes/no"</span> &#123; send <span class="string">"yes\n"</span>;exp_continue &#125;</span><br><span class="line"><span class="string">"password"</span> &#123; send <span class="string">"<span class="variable">$password</span>\n"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">expect eof</span><br><span class="line">EOF</span><br><span class="line"><span class="keyword">done</span> &lt; ip.txt</span><br></pre></td></tr></table></figure><h2 id="重新生成-etc-ssh-目录"><a href="#重新生成-etc-ssh-目录" class="headerlink" title="重新生成/etc/ssh 目录"></a>重新生成/etc/ssh 目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install openssh-server</span><br></pre></td></tr></table></figure><h1 id="SSH端口转发"><a href="#SSH端口转发" class="headerlink" title="SSH端口转发"></a>SSH端口转发</h1><p>当你在咖啡馆享受免费 WiFi 的时候，有没有想到可能有人正在窃取你的密码及隐私信息？当你发现实验室的防火墙阻止了你的网络应用端口，是不是有苦难言？来看看 SSH 的端口转发功能能给我们带来什么好处吧！</p><p>SSH 会自动加密和解密所有 SSH 客户端与服务端之间的网络数据。但是，SSH还能够将其他 TCP 端口的网络数据通过 SSH 链接来转发，并且自动提供了相应的加密及解密服务。这一过程也被叫做“隧道”（tunneling），这是因为 SSH 为其他 TCP 链接提供了一个安全的通道来进行传输而得名。例如，Telnet，SMTP，LDAP 这些 TCP 应用均能够从中得益，避免了用户名，密码以及隐私信息的明文传输。而与此同时，如果工作环境中的防火墙限制了一些网络端口的使用，但是允许 SSH 的连接，也能够通过将 TCP 端口转发来使用 SSH 进行通讯。<br>如果您工作环境中的防火墙限制了一些网络端口的使用，但是允许 SSH 的连接，那么也是能够通过将TCP端口转发来使用SSH进行通讯。<br>SSH 端口转发能够提供两大功能：</p><ol><li>加密 SSH Client 端至 SSH Server 端之间的通讯数据</li><li>突破防火墙的限制完成一些之前无法建立的 TCP 连接</li></ol><p>使用了端口转发之后，TCP 端口 A 与 B 之间现在并不直接通讯，而是转发到了 SSH 客户端及服务端来通讯，从而自动实现了数据加密并同时绕过了防火墙的限制</p><h2 id="本地转发"><a href="#本地转发" class="headerlink" title="本地转发"></a>本地转发</h2><p>语法：<br>ssh -L <local port="">:<remote host="">:<remote port=""> <ssh hostname=""><br>选项：<br>-f 后台启用<br>-N 不打开远程shell，处于等待状态<br>-g 启用网关功能</ssh></remote></remote></local></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><img src="/Linux/端口转发.png" alt="logo"><br>如上图A(是telnet客户端),ip:172.20.59.25，B(是SSH客户端,服务端,ip:172.20.59.26)  C(telnet服务端，ip:172.20.59.27)，<br>现在A要通过SSH 安全协议SSH访问C。假设防火墙可以让A 访问到B的内网。</p><ol><li>首先要在A机器安装telnet客户端，C机器安装telnet服务端（yum install telnet-server -y）</li><li><p>在客户端A机器上执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh –L 9527:172.20.59.27:23 -Nf 172.20.59.26</span><br></pre></td></tr></table></figure></li><li><p>执行ss -ntl </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># ss -ntl</span></span><br><span class="line">State      Recv-Q Send-Q                                          Local Address:Port                                            Peer Address:Port                                                       *:*     </span><br><span class="line">LISTEN     0      128                                                 127.0.0.1:9527</span><br></pre></td></tr></table></figure></li></ol><p>发现A客户机已经打开了9527端口</p><ol start="4"><li>执行命令 telnet 127.0.0.1 9527 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 9527</span><br><span class="line">``` </span><br><span class="line">5. 登陆进去 输入ip a 发现已经连接到了C机器</span><br><span class="line">```bash</span><br><span class="line">ip a</span><br></pre></td></tr></table></figure></li></ol><p>数据先传递到本机的9527端口，然后在本机上开一个随机端口，通过SSH协议把数据报文发送到SSH服务器的22端口，最后在由ssh服务器发送到telnet 服务端。服务端按同样的流程发给客户端。<br>注意：在C机器上启动telnet-server, 并且不能以root身份连接telnet<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chkconfig telnet on       </span><br><span class="line">chkconfig xinetd on    </span><br><span class="line">service xinetd start</span><br><span class="line">chkconfig --list</span><br></pre></td></tr></table></figure></p><h2 id="远程转发"><a href="#远程转发" class="headerlink" title="远程转发"></a>远程转发</h2><p>语法：<br>ssh -R <local port="">:<remote host="">:<remote port=""> <ssh hostname=""><br>示例：<br>ssh –R 9527:telnetsrv:23 –N sshsrv<br><img src="/Linux/端口转发.png" alt="logo"><br>如上图A是telnet客户端，B(是SSH客户端,服务端)  C(telnet服务端)，<br>现在A要通过SSH 安全协议SSH访问C。防火墙让A 访问不到B的内网。所以我们要在B 机器上做一个端口转发。<br>实际中这种方式很实用，比如公司外地出差人员无法访问公司的内外就可以这样操作。</ssh></remote></remote></local></p><ol><li><p>在B机器上执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh –R 9527:172.20.59.27:23 -Nf 172.20.59.25</span><br></pre></td></tr></table></figure></li><li><p>在A机器上不需要做任何配置就可以连接到C</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 9527</span><br></pre></td></tr></table></figure></li></ol><h2 id="怎么实现2个网络之间的连接"><a href="#怎么实现2个网络之间的连接" class="headerlink" title="怎么实现2个网络之间的连接"></a>怎么实现2个网络之间的连接</h2><p>A B –internet— C D(telnet server)<br>现在AB，CD 属于2个网段内的网络，A不能直接访问C，B可以直接访问C。那么现在A要借助B与C的连接，访问到D。<br>注意：前提是网络支持SSH协议。<br>A:172.20.59.25<br>B:172.20.59.26<br>C:172.20.59.27<br>D:172.20.59.28</p><ol><li>本地转发实现<br>A  B(Client) –internet— C(ssh server)  D(telnet server)<br>A 通过B跟C建立的ssh桥梁连接到D。<br>在B机器上执行下面命令，注意要加小j,代表网关功能<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh –L 9527:172.20.59.28:23 -Nfj 172.20.59.27</span><br></pre></td></tr></table></figure></li></ol><p>在A机器上执行命令进行连接<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 172.20.59.26 9527</span><br></pre></td></tr></table></figure></p><ol start="2"><li>远程转发实现<br>A  B(ssh server) –internet— C(Client)  D(telnet server)<br>在C机器上执行下面命令，注意要加小j,代表网关功能<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh –L 9527:172.20.59.28:23 -Nfj 172.20.59.26</span><br></pre></td></tr></table></figure></li></ol><p>在A机器上执行命令进行连接<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 172.20.59.27 9527</span><br></pre></td></tr></table></figure></p><h2 id="动态端口转发"><a href="#动态端口转发" class="headerlink" title="动态端口转发"></a>动态端口转发</h2><p>当用firefox访问internet时，本机的1080端口做为代理服务器，firefox的访问<br>请求被转发到sshserver上，由sshserver替之访问internet<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -D 1080 sshserver</span><br></pre></td></tr></table></figure></p><p>假如有3台电脑A内网， 外网（B，C ），由于防火墙原因 A 访问不了C，A能访问B，B能访问C。<br>那么我们在客户端A上执行命令<br>我们在客户端执行命令，端口自己指定，B服务器充当搬网工<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -D 9527 sshserver（搬网工服务器ip） -fN</span><br></pre></td></tr></table></figure></p><p>然后在客户端A机器配置代理ip 127.0.0.1 端口9527 ，配置好A就可以利用端口转发顺利访问C了。</p><p>但是如果有一台windows机器想访问google怎么办，windows 上不支持ssh命令的。只要在命令中加个小j就可以了。<br>在A机器执行命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -D 9527 sshserver（搬网工服务器ip） -fNg</span><br></pre></td></tr></table></figure></p><p>这样在其他电脑上配置代理ip 跟端口就可以借助这个隧道功能访问到C网站了。<br>比如有个D机器想访问C,通过命令curl 也可以配置代理<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --socks5 A的ip地址:9527 http://C的ip地址</span><br></pre></td></tr></table></figure></p><h1 id="ssh服务的最佳实践"><a href="#ssh服务的最佳实践" class="headerlink" title="ssh服务的最佳实践"></a>ssh服务的最佳实践</h1><p>SSH 服务器端：<br>OpenSSH 软件包包含了以下程序：<br>sshd             – SSH服务端程序<br>sftp-server  – SFTP服务端程序（类似FTP，但提供数据加密的一种协议）<br>scp               – 非交互式sftp-server的客户端，用来向服务器上传/下载文件，安全复制<br>sftp              – 交互式sftp-server客户端，用法和ftp命令一样。<br>slogin          – ssh的别名<br>ssh               – SSH协议的客户端程序，用来登入远程系统或远程执行命令<br>ssh-add       –  SSH代理相关程序，用来向SSH代理添加dsa　key<br>ssh-agent      – ssh代理程序<br>ssh-keygen    – ssh public key 生成器</p><h2 id="etc-ssh-sshd-config文件说明"><a href="#etc-ssh-sshd-config文件说明" class="headerlink" title="/etc/ssh/sshd_config文件说明"></a>/etc/ssh/sshd_config文件说明</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6_1 ~]<span class="comment"># vim /etc/ssh/sshd_config</span></span><br><span class="line"><span class="comment">#       $OpenBSD: sshd_config,v 1.80 2008/07/02 02:24:18 djm Exp $</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This is the sshd server system-wide configuration file.  See</span></span><br><span class="line"><span class="comment"># sshd_config(5) for more information.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This sshd was compiled with PATH=/usr/local/bin:/bin:/usr/bin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The strategy used for options in the default sshd_config shipped with</span></span><br><span class="line"><span class="comment"># OpenSSH is to specify options with their default value where</span></span><br><span class="line"><span class="comment"># possible, but leave them commented.  Uncommented options change a</span></span><br><span class="line"><span class="comment"># default value.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Port 22                  #默认端口是22  生产环境必须修改这个端口</span></span><br><span class="line"><span class="comment">#AddressFamily any</span></span><br><span class="line"><span class="comment">#ListenAddress 0.0.0.0    #监听的地址为所有地址 </span></span><br><span class="line"><span class="comment">#ListenAddress ::</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Disable legacy (protocol version 1) support in the server for new</span></span><br><span class="line"><span class="comment"># installations. In future the default will change to require explicit</span></span><br><span class="line"><span class="comment"># activation of protocol 1</span></span><br><span class="line">Protocol 2                 <span class="comment">#使用SSH V2协议 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># HostKey for protocol version 1</span></span><br><span class="line"><span class="comment">#HostKey /etc/ssh/ssh_host_key</span></span><br><span class="line"><span class="comment"># HostKeys for protocol version 2</span></span><br><span class="line"><span class="comment">#HostKey /etc/ssh/ssh_host_rsa_key</span></span><br><span class="line"><span class="comment">#HostKey /etc/ssh/ssh_host_dsa_key</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Lifetime and size of ephemeral version 1 server key</span></span><br><span class="line"><span class="comment">#KeyRegenerationInterval 1h</span></span><br><span class="line"><span class="comment">#ServerKeyBits 1024  #密钥长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Logging</span></span><br><span class="line"><span class="comment"># obsoletes QuietMode and FascistLogging</span></span><br><span class="line"><span class="comment">#SyslogFacility AUTH</span></span><br><span class="line">SyslogFacility AUTHPRIV</span><br><span class="line"><span class="comment">#LogLevel INFO</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Authentication:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#LoginGraceTime 2m    # 登陆验证时间</span></span><br><span class="line"><span class="comment">#PermitRootLogin yes  #是否允许root用户登陆。</span></span><br><span class="line"><span class="comment">#StrictModes yes</span></span><br><span class="line"><span class="comment">#MaxAuthTries 6</span></span><br><span class="line"><span class="comment">#MaxSessions 10</span></span><br><span class="line"></span><br><span class="line">/X11</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set this to 'yes' to enable PAM authentication, account processing, </span></span><br><span class="line"><span class="comment"># and session processing. If this is enabled, PAM authentication will </span></span><br><span class="line"><span class="comment"># be allowed through the ChallengeResponseAuthentication and</span></span><br><span class="line"><span class="comment"># PasswordAuthentication.  Depending on your PAM configuration,</span></span><br><span class="line"><span class="comment"># PAM authentication via ChallengeResponseAuthentication may bypass</span></span><br><span class="line"><span class="comment"># the setting of "PermitRootLogin without-password".</span></span><br><span class="line"><span class="comment"># If you just want the PAM account and session checks to run without</span></span><br><span class="line"><span class="comment"># PAM authentication, then enable this but set PasswordAuthentication</span></span><br><span class="line"><span class="comment"># and ChallengeResponseAuthentication to 'no'.</span></span><br><span class="line"><span class="comment">#UsePAM no</span></span><br><span class="line">UsePAM yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># Accept locale-related environment variables</span></span><br><span class="line">AcceptEnv LANG LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE LC_MONETARY LC_MESSAGES</span><br><span class="line">AcceptEnv LC_PAPER LC_NAME LC_ADDRESS LC_TELEPHONE LC_MEASUREMENT</span><br><span class="line">AcceptEnv LC_IDENTIFICATION LC_ALL LANGUAGE</span><br><span class="line">AcceptEnv XMODIFIERS</span><br><span class="line"></span><br><span class="line"><span class="comment">#AllowAgentForwarding yes</span></span><br><span class="line"><span class="comment">#AllowTcpForwarding yes</span></span><br><span class="line"><span class="comment">#GatewayPorts no</span></span><br><span class="line"><span class="comment">#X11Forwarding no</span></span><br><span class="line">X11Forwarding yes</span><br><span class="line"><span class="comment">#X11DisplayOffset 10</span></span><br><span class="line"><span class="comment">#X11UseLocalhost yes</span></span><br><span class="line"><span class="comment">#PrintMotd yes</span></span><br><span class="line"><span class="comment">#PrintLastLog yes</span></span><br><span class="line"><span class="comment">#TCPKeepAlive yes</span></span><br><span class="line"><span class="comment">#UseLogin no</span></span><br><span class="line"><span class="comment">#UsePrivilegeSeparation yes</span></span><br><span class="line"><span class="comment">#PermitUserEnvironment no</span></span><br><span class="line"><span class="comment">#Compression delayed</span></span><br><span class="line"><span class="comment">#ClientAliveInterval 0</span></span><br><span class="line"><span class="comment">#ClientAliveCountMax 3</span></span><br><span class="line"><span class="comment">#ShowPatchLevel no</span></span><br><span class="line"><span class="comment">#UseDNS yes       #禁止DNS 反向解析</span></span><br><span class="line"><span class="comment">#PidFile /var/run/sshd.pid</span></span><br><span class="line"><span class="comment">#MaxStartups 10:30:100</span></span><br><span class="line"><span class="comment">#PermitTunnel no</span></span><br><span class="line"><span class="comment">#ChrootDirectory none</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># no default banner path</span></span><br><span class="line"><span class="comment">#Banner none</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># override default of no subsystems</span></span><br><span class="line">Subsystem       sftp    /usr/libexec/openssh/sftp-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example of overriding settings on a per-user basis</span></span><br><span class="line"><span class="comment">#Match User anoncvs</span></span><br><span class="line"><span class="comment">#       X11Forwarding no</span></span><br><span class="line"><span class="comment">#       AllowTcpForwarding no</span></span><br><span class="line"><span class="comment">#       ForceCommand cvs server</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#只允许user用户登录，与DenyUsers选项相反  </span></span><br><span class="line">AllowUsers user1 user2  </span><br><span class="line"><span class="comment"># 禁止指定的 用户或组</span></span><br><span class="line">DenyUsers apache</span><br><span class="line"></span><br><span class="line"><span class="comment">##登录验证方式  </span></span><br><span class="line"><span class="comment">#关闭密码验证  </span></span><br><span class="line">PasswordAuthentication no  </span><br><span class="line"> </span><br><span class="line"><span class="comment">#以下三行没什么要改的，把默认的#注释去掉就行了</span></span><br><span class="line">RSAAuthentication yes</span><br><span class="line"><span class="comment">#启用秘钥验证  </span></span><br><span class="line">PubkeyAuthentication yes  </span><br><span class="line"><span class="comment">#指定公钥数据库文件  </span></span><br><span class="line">AuthorsizedKeysFile .ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>另外，限制登录设置主要是对hosts.allow与hosts.deny就行改动<br>首先限制所有IP都无法连接，我们顺便将FTP的限制也加入其中。注意要想FTP限制起作用，需要修改配置中的tcp_wrappers=YES。<br>　　vi /etc/hosts.deny<br>　　sshd:ALL<br>　　vsftpd:ALL<br>设定允许指定的IP地址连接：<br>　　vi /etc/hosts.allow # xxx.xxx.xxx.表示网段<br>　　sshd:192.168.1.<br>　　vsftpd:192.168.1.</p><h2 id="最佳实践说明"><a href="#最佳实践说明" class="headerlink" title="最佳实践说明"></a>最佳实践说明</h2><p>服务器安全第一条:启用尽可能少的服务.<br>服务器安全第二条:管好你的ssh.<br>1)禁止root用户远程登录<br> root是linux里的最高统帅了,就它官最大,可以在系统里畅通无阻.也就是因为这个原因,它是我们的重点保护对象.对于管理linux系统,一个最基本的建议就是:平时登陆和工作的时候都使用普通用户进行操作.在需要修改系统设置使用特级权限时,再切换到root用户（su  - root）.这样可以最大限度的避免因为误操作造成对linux系统的破坏.另外因为root用户是每个linux系统里都内置的,恶意的黑客可能会拿它做用户名然后尝试用不同的密码登陆密码哟.所以还是自己新建一个帐号,这样用户名被猜中的机率就很低了,再禁止root用户登陆,想猜密码?先猜用户吧.<br>在sshd_config中修改如下就可以了:<br>      PermitRootLogin  no<br>2)禁止空密码登陆<br>再有就是空密码.一般来说linux系统都会内置很多帐号,而这些用户的密码我们是不知道的.谁知道哪天哪个linux的发行版,对其中的帐号设置空密码或者指定的密码呢?所以还是禁止为妙,省得夜长梦多.<br>在sshd_config这样修改:<br>      PermitEmptyPasswords  no<br>3)使用非默认端口，非22端口<br>  其实吧很多时候你的服务器被盯上,并不是有人特别跟你过不去.人家随机的用软件扫了一个ip段,而你的ip正好在里面.而人家的扫描规则就是:是否开启22端口.这个时候,如果你没有禁止root登陆,root的密码又是简单的123456或者000000,111111这些地球人都知道的密码的话,你的服务器不黑,谁的被黑?所以安全从简单的小事儿做起,你向前移动一小步,你的服务器安全就进步一大步.还等什么?先修改默认端口呗,打开sshd_config文件,修改成:<br>      Port 30003<br>  根据你的心情,port随机的选一个,除了你自己,鬼知道你当时选的哪个端口.再打开/var/log/secure,看下世界是不是一下子清静了?再也没有烦人的用不同的帐号和密码尝试登陆的日志了.这招百试不爽.<br>4)限制ssh监听的ip<br>  在服务器有多个ip的时候.设置ssh服务器只监听在指定的ip,未尝不是一个好办法.例如一组服务器中,肯定会组成内网和外网两个小的局域网.这时候只让不起眼的一两台机器的ssh服务监听到公网ip上.其它的机器ssh只监听内网ip,通过另外的一两台机器登陆进行管理,是不是很安全保守的做法呢?<br>在sshd_config中修改如下:<br>      ListenAddress 192.168.1.5<br>如上的写法,是ssh服务器只监听192.168.1.5这个ip.</p><p>5)使用的协议版本2： ssh v2<br>  ssh协议有两个版本.肯定v2要比v1安全高效的多了.ssh服务器默认会接受两种协议的连接.为了保证服务器的安全,咱们可以定义服务器只使用v2:<br>在sshd_config中修改如下:<br>      Protocol 2<br>6)禁用密码登陆，推荐使用密钥登录，并且私钥使用强密码加密<br>  其实经过前面几步简单的设置,个人认为ssh服务器的安全已经有了一个质的提高.但是在不使用其它复杂的手段的情况下,还有一些加固的小技巧,例如这一条:禁止使用密码登陆.什么?是不是写错了,或者弄迷糊了?ssh服务器竟然要禁止使用密码登陆?那怎么管理服务器呢?当然还是用ssh啦.ssh服务器不单支持密码认证,还支持通过key的认证方式,而且是默认的哟.关于怎样生成key的方法参见:&lt;&lt;使ssh不用输入密码&gt;&gt;</p><p>在sshd_config中修改如下:<br>      PasswordAuthentication no<br>  经过这点小的改动,你的ssh服务绝对又是一个质的提升.能够拿到你的私key,又知道服务器登陆的用户名和端口,这绝对不是一件简单的事儿吧.<br>7)限制连接IP，仅保证有限的机器能够远程访问<br>  现在再拿出最后一招杀手锏:限制ssh服务连接的ip.我们前面提到一组服务器我们只留一两台机器可以远程访问.这样这两台机器的安全又成了重中之重.怎样再保证一下这两台机器的安全呢?我们可以限制连接这两台机器的ip.例如:这两台机器只允许公司的出口ip进行访问.这样就再次提高了服务器的安全系数.想想如果有一个黑客,能够进入你们公司的办公网络,能够拿到你的私key,又能知道只有你才知道的服务器的用户名和登陆的端口,以及登陆的方式,如果有这样的牛X的黑客,还有什么好防的呢?因为防不胜防啊.扯远了,看下限制ip的做法:<br>      在/etc/hosts.allow输入<br>      sshd:192.168.1.5:allow(其中192.168.1.5是你要允许登陆ssh的ip,或者是一个网段192.168.1.0/24)<br>      在/etc/hosts.deny输入<br>      sshd:ALL(表示除了hosts.allow中允许的，其他的ip拒绝登陆ssh)<br>      呵呵,这是传统的做法,因为开了防火墙所以笔者更喜欢直接在防火墙上做设置:)</p><p>使用 iptables 设置 ssh 服务安全访问策略。<br>8) 日志<br>记录好日志，经常做日志分析。<br>用户登录成功日志： /var/log/wtmp  , 使用 # last 命令查看<br>用户登录失败日志： /var/log/btmp , 使用 # lastb 命令查看<br>查看所有用户上次登录情况： 使用  #lastlog [-u User]</p><p>SSH 最佳实践<br><blockquote><p>Port 30003<br>ListenAddress 192.168.1.5<br>Protocol 2</p><p>#白名单<br>AllowUsers user1 user2</p><p>#黑名单<br>denyUser user3 user4<br>PasswordAuthentication no<br>PermitEmptyPasswords no<br>PermitRootLogin  no<br>UseDNS no</p></blockquote></p><p>脚本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 配置sshd的参数</span></span><br><span class="line">/bin/cp  /etc/ssh/sshd_config   /etc/ssh/sshd_config.bak.$(date +<span class="string">"%Y-%m-%d-%H-%m-%S"</span>)</span><br><span class="line">/bin/sed -i <span class="string">'s/#Port 22/Port 30003/g'</span>  /etc/ssh/sshd_config</span><br><span class="line">/bin/sed -i <span class="string">'s/#LogLevel INFO/LogLevel VERBOSE/g'</span>  /etc/ssh/sshd_config</span><br><span class="line">/bin/sed -i <span class="string">"s/PasswordAuthentication yes/PasswordAuthentication no/g"</span>  /etc/ssh/sshd_config</span><br><span class="line">/bin/sed -i <span class="string">"s/#PermitEmptyPasswords no/PermitEmptyPasswords no/g"</span>  /etc/ssh/sshd_config</span><br><span class="line">/bin/sed -i <span class="string">"s/#PermitRootLogin yes/PermitRootLogin no/g"</span>  /etc/ssh/sshd_config</span><br><span class="line">/bin/sed -i <span class="string">"s/#UseDNS yes/UseDNS no/"</span> /etc/ssh/sshd_config</span><br><span class="line"> </span><br><span class="line">/sbin/service sshd reload</span><br></pre></td></tr></table></figure></p><p><a href="https://blog.csdn.net/xiaoluoshan/article/details/78177217?locationNum=8&amp;fps=1" target="_blank" rel="noopener">参考文章</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CA证书</title>
      <link href="/2018/09/12/%E8%AF%81%E4%B9%A6%E7%AE%A1%E7%90%86/"/>
      <url>/2018/09/12/%E8%AF%81%E4%B9%A6%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>电子商务认证授权机构（CA, Certificate Authority），也称为电子商务认证中心，是负责发放和管理数字证书的权威机构，并作为电子商务交易中受信任的第三方，承担公钥体系中公钥的合法性检验的责任。</p></blockquote><a id="more"></a><h1 id="https请求的过程"><a href="#https请求的过程" class="headerlink" title="https请求的过程"></a>https请求的过程</h1><ol><li><p>客户端发起HTTPS请求<br>这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。</p></li><li><p>服务端的配置<br>　　采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</p></li><li><p>传送证书<br>　这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</p></li><li><p>客户端解析证书<br>　这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</p></li><li><p>传送加密信息<br>　这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p></li><li><p>服务段解密信息<br>　服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p></li><li><p>传输加密后的信息<br>　这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</p></li><li><p>客户端解密信息<br>　客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。</p></li></ol><h1 id="证书申请步骤"><a href="#证书申请步骤" class="headerlink" title="证书申请步骤"></a>证书申请步骤</h1><p>证书申请及签署步骤：<br>1、客户端生成申请请求文件包含公钥，国家，省市，邮箱<br>2、服务端RA核验确认身份<br>3、CA使用CA根证书的私钥签名生成证书<br>4、把证书下发给客户端</p><h1 id="openssl"><a href="#openssl" class="headerlink" title="openssl"></a>openssl</h1><p>OpenSSL：开源项目<br>三个组件：<br>openssl: 多用途的命令行工具，包openssl<br>libcrypto: 加密算法库，包openssl-libs<br>libssl：加密模块应用库，实现了ssl及tls，包nss<br>加密f1<br>openssl enc -e -des3 -a -salt -in f1 -out testfile.cipher<br>解密f1<br>openssl enc -d -des3 -a -salt -in testfile.cipher -out f1</p><h2 id="dgst"><a href="#dgst" class="headerlink" title="dgst"></a>dgst</h2><p>哈希算法<br>openssl dgst -md5 f1<br>等价于<br>md5sum f1 </p><h2 id="生成密码"><a href="#生成密码" class="headerlink" title="生成密码"></a>生成密码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl passwd -1</span><br></pre></td></tr></table></figure><p>加盐<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl passwd -1 –salt centos</span><br></pre></td></tr></table></figure></p><h2 id="生成随机数"><a href="#生成随机数" class="headerlink" title="生成随机数"></a>生成随机数</h2><p>生成12位的随机数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rand -base64 12</span><br></pre></td></tr></table></figure></p><h2 id="生成私钥"><a href="#生成私钥" class="headerlink" title="生成私钥"></a>生成私钥</h2><p>生成私有key<br>openssl genrsa -out test.key 1024<br>-des 加密</p><ol><li>(umask 066;openssl genrsa -out test.key -des 1024)</li><li>openssl rsa -in test.key -out test3.key <h2 id="从私钥中取出公钥"><a href="#从私钥中取出公钥" class="headerlink" title="从私钥中取出公钥"></a>从私钥中取出公钥</h2>openssl rsa -in test.key -pubout -out test3.pub<h2 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h2>echo -n “ab”|base64<h2 id="生成密码随机数"><a href="#生成密码随机数" class="headerlink" title="生成密码随机数"></a>生成密码随机数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /dev/urandom |tr -dc <span class="string">'A-Za-z0-9'</span>|head -c 12</span><br><span class="line">openssl passwd -1 -salt fdsfdsfds|tr -d <span class="string">'/+'</span>|head -c 12</span><br></pre></td></tr></table></figure></li></ol><h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><p>Message Authentication Code，单向加密的一种延伸应用，用于实现<br>网络通信中保证所传输数据的完整性机制</p><h1 id="搭建CA认证中心"><a href="#搭建CA认证中心" class="headerlink" title="搭建CA认证中心"></a>搭建CA认证中心</h1><p>openssl req -new -x509 –key /etc/pki/CA/private/cakey.pem -days 7300 -out /etc/pki/CA/cacert.pem<br>-new: 生成新证书签署请求<br>-x509: 专用于CA生成自签证书<br>-key: 生成请求时用到的私钥文件<br>-days n：证书的有效期限<br>-out /PATH/TO/SOMECERTFILE: 证书的保存路径</p><p>跟ca有关的配置文件<br>cat /etc/pki/tls/openssl.cnf<br>我们看到默认的CA目录是/etc/pki/CA</p><ol><li><p>首先创建这2个文件，因为默认是不存在的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/pki/CA</span><br><span class="line">touch index.txt </span><br><span class="line"><span class="built_in">echo</span> 01 &gt; serial</span><br></pre></td></tr></table></figure></li><li><p>cd /etc/pik/CA</p></li><li>CA服务器生成私钥<br>(umask 066;openssl genrsa -out private/cakey.pem -des 2048)</li><li>生成自签名证书<br>-new 生成新证书签署请求<br>openssl req -new -x509 -key /etc/pki/CA/private/cakey.pem -days 7300 -out /etc/pki/CA/cacert.pem </li><li>查看ca证书信息<br>openssl x509 -in cacert.pem -noout -text<br>到此认证中心就完成了。<h1 id="客户端向服务端申请证书"><a href="#客户端向服务端申请证书" class="headerlink" title="客户端向服务端申请证书"></a>客户端向服务端申请证书</h1></li><li>生成私钥<br>(umask 066;openssl genrsa -out app.key -des 2048)</li><li>生成证书申请文件<br>openssl req -new -key /data/app.key -out /data/app.csr </li><li>把申请的证书发送到服务端<br>scp app.csr 192.168.1.111:/data</li><li>服务端进行颁发证书，发布的证书必须放到certs文件夹下<br>openssl ca -in /data/app.csr -out /etc/pki/CA/certs/app.crt -days 100<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 CA]<span class="comment"># openssl ca -in /data/app.csr -out /etc/pki/CA/certs/app.crt -days 100</span></span><br><span class="line">Using configuration from /etc/pki/tls/openssl.cnf</span><br><span class="line">Enter pass phrase <span class="keyword">for</span> /etc/pki/CA/private/cakey.pem:</span><br><span class="line">Check that the request matches the signature</span><br><span class="line">Signature ok</span><br><span class="line">The organizationName field needed to be the same <span class="keyword">in</span> the</span><br><span class="line">CA certificate (Default Company Ltd) and the request (mage)</span><br></pre></td></tr></table></figure></li></ol><p>报错是因为客户端填写的省跟认证中心的不一样。<br><code color="red">注意：默认国家，省，公司名称三项必须和CA一致</code><br>修改下认证规则即可<br>vim /etc/pki/tls/openssl.cnf<br>修改<br>policy = policy_anything<br>再次执行命令<br>openssl ca -in /data/app.csr -out /etc/pki/CA/certs/app.crt -days 100</p><p><strong>查看颁发的证书</strong><br>openssl x509 -in /etc/pki/CA/certs/app.crt  -noout -text<br><strong>验证证书的有效性</strong><br>openssl verify -CAfile /etc/pki/CA/cacert.pem<br>到此 app.crt 客户端证书已经生成。</p><p>同一个申请证书  申请多个ca认证<br>cat index.txt.attr  改为no</p><h1 id="吊销证书"><a href="#吊销证书" class="headerlink" title="吊销证书"></a>吊销证书</h1><ol><li>找到需要吊销的证书编号<br>openssl x509 -in certs/app.crt -serial</li><li>吊销证书<br>openssl ca -revoke /etc/pki/CA/newcerts/01.pem</li><li>指定第一个吊销证书的编号,注意：第一次更新证书吊销列表前，才需要执行<br>echo 01 &gt; /etc/pki/CA/crlnumber</li><li>生成证书吊销列表更新到数据库crl<br>openssl ca -gencrl -out /etc/pki/CA/crl.pem</li><li>查看吊销crl文件<br>openssl crl -in /etc/pki/CA/crl.pem -noout -text<h1 id="客户端使用证书"><a href="#客户端使用证书" class="headerlink" title="客户端使用证书"></a>客户端使用证书</h1>使用证书搭建https  后边补充<h1 id="免费证书"><a href="#免费证书" class="headerlink" title="免费证书"></a>免费证书</h1>freessl.org</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CA证书 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>加密安全</title>
      <link href="/2018/09/12/%E5%8A%A0%E5%AF%86%E5%AE%89%E5%85%A8/"/>
      <url>/2018/09/12/%E5%8A%A0%E5%AF%86%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>主要介绍对称加密，非对称加密，以及gpg的使用</p></blockquote><a id="more"></a><p> 数据加密的基本过程就是对原来为明文的文件或数据按某种算法进行处理，使其成为不可读的一段代码，通常称为“密文”，使其只能在输入相应的密钥之后才能显示出本来内容，通过这样的途径来达到保护数据不被非法人窃取、阅读的目的。 该过程的逆过程为解密，即将该编码信息转化为其原来数据的过程。</p><p>墨菲定律：<br>一种心理学效应，是由爱德华·墨菲（Edward A. Murphy）提出的，<br>原话：如果有两种或两种以上的方式去做某件事情，而其中一种选择方式将导致灾难，则必定有人会做出这种选择</p><ol><li>任何事都没有表面看起来那么简单</li><li>所有的事都会比你预计的时间长</li><li>会出错的事总会出错</li><li>如果你担心某种情况发生，那么它就更有可能发生</li></ol><p>安全防护环节<br>物理安全：各种设备/主机、机房环境<br>系统安全：主机或设备的操作系统<br>应用安全：各种网络服务、应用程序<br>网络安全：对网络访问的控制、防火墙规则<br>数据安全：信息的备份与恢复、加密解密<br>管理安全：各种保障性的规范、流程、方法</p><h1 id="安全算法"><a href="#安全算法" class="headerlink" title="安全算法"></a>安全算法</h1><h2 id="对称机密"><a href="#对称机密" class="headerlink" title="对称机密"></a>对称机密</h2><p>以下常见的算法</p><ol><li>DES：Data Encryption Standard，56bits，速度较快，适用于加密大量数据的场合；</li><li>3DES：是基于DES的对称算法，对一块数据用三个不同的密钥进行三次加密，强度更高</li><li>AES：Advanced (128, 192, 256bits) 高级加密标准，对称算法，是下一代的加密算法标准，速度快，安全级别高</li><li>Blowfish，Twofish 它使用变长的密钥，长度可达448位，运行速度很快；</li><li>IDEA，RC6，CAST5<br>特性：</li><li>加密、解密使用同一个密钥，效率高</li><li>将原始数据分割成固定大小的块，逐个进行加密<br>缺陷：</li><li>密钥过多</li><li>密钥分发</li><li>数据来源无法确认<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2>以下常见的算法</li><li>RSA（加密，数字签名）</li><li>DSA（数字签名）</li><li>ELGamal<br>公钥加密：密钥是成对出现<ol><li>公钥：公开给所有人；public key</li><li>私钥：自己留存，必须保证其私密性；secret key<br>特点：用公钥加密数据，只能使用与之配对的私钥解密；反之亦然<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2>对称加密算法相比非对称加密算法来说，加解密的效率要高得多。但是缺陷在于对于秘钥的管理上，以及在非安全信道中通讯时，密钥交换的安全性不能保障。所以在实际的网络环境中，会将两者混合使用.</li></ol></li></ol><p>例如针对C/S模型， </p><ol><li>服务端计算出一对秘钥pub/pri。将私钥保密，将公钥公开。 </li><li>客户端请求服务端时，拿到服务端的公钥pub。 </li><li>客户端通过AES计算出一个对称加密的秘钥X。 然后使用pub将X进行加密。 </li><li>客户端将加密后的密文发送给服务端。服务端通过pri解密获得X。 </li><li>然后两边的通讯内容就通过对称密钥X以对称加密算法来加解密。<h2 id="单向散列"><a href="#单向散列" class="headerlink" title="单向散列"></a>单向散列</h2>将任意数据缩小成固定大小的“指纹”<br>• 任意长度输入<br>• 固定长度输出<br>• 若修改数据，指纹也会改变（“不会产生冲突”）<br>• 无法从指纹中重新生成数据（“单向”）<br>常见的算法<br>md5: 128bits、sha1: 160bits、sha224、sha256、sha384、sha512<br>常用的工具<br>md5sum，sha1sum [ –check ] file，openssl、gpg，rpm -V<h1 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a>rpm</h1>查看文件完整性</li><li><p>导入GPG公钥签名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 <span class="built_in">cd</span>]<span class="comment"># rpm --import /misc/cd/RPM-GPG-KEY-CentOS-6</span></span><br></pre></td></tr></table></figure></li><li><p>严重安装包的正确性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 <span class="built_in">cd</span>]<span class="comment"># rpm -K /misc/cd/Packages/tree-1.5.3-3.el6.x86_64.rpm </span></span><br><span class="line">/misc/<span class="built_in">cd</span>/Packages/tree-1.5.3-3.el6.x86_64.rpm: rsa sha1 (md5) pgp md5 OK</span><br></pre></td></tr></table></figure></li></ol><p>也可以执行rpm –verify package_name (or -V)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm --verify tree</span><br></pre></td></tr></table></figure></p><h1 id="校验文件是否修改"><a href="#校验文件是否修改" class="headerlink" title="校验文件是否修改"></a>校验文件是否修改</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 <span class="built_in">test</span>]<span class="comment"># echo 123 &gt; f1</span></span><br><span class="line">[root@centos6 <span class="built_in">test</span>]<span class="comment"># echo 456 &gt; f2</span></span><br><span class="line">[root@centos6 <span class="built_in">test</span>]<span class="comment"># sha1sum f1</span></span><br><span class="line">a8fdc205a9f19cc1c7507a60c4f01b13d11d7fd0  f1</span><br><span class="line">[root@centos6 <span class="built_in">test</span>]<span class="comment"># sha1sum f1 &gt; sha1.log</span></span><br><span class="line">[root@centos6 <span class="built_in">test</span>]<span class="comment"># sha1sum f2 &gt;&gt; sha1.log</span></span><br><span class="line">[root@centos6 <span class="built_in">test</span>]<span class="comment"># cat sha1.log</span></span><br><span class="line">a8fdc205a9f19cc1c7507a60c4f01b13d11d7fd0  f1</span><br><span class="line">f9e21473daaa2674d862b67a1339f4570e86de17  f2</span><br><span class="line">[root@centos6 <span class="built_in">test</span>]<span class="comment"># echo 1234 &gt; f1</span></span><br><span class="line">[root@centos6 <span class="built_in">test</span>]<span class="comment"># sha1sum --check sha1.log</span></span><br><span class="line">f1: FAILED</span><br><span class="line">f2: OK</span><br><span class="line">sha1sum: WARNING: 1 of 2 computed checksums did NOT match</span><br></pre></td></tr></table></figure><h1 id="gpg"><a href="#gpg" class="headerlink" title="gpg"></a>gpg</h1><p>gpg  pki 公用的密钥加密体系<br><strong>对称密钥</strong></p><ol><li><p>加密</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg -c file</span><br></pre></td></tr></table></figure></li><li><p>解密</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg -o file -d file.gpg</span><br></pre></td></tr></table></figure></li></ol><p><strong>生成非对称密钥</strong><br>在hostB主机上用公钥加密，在hostA主机上解密</p><ol><li><p>在hostA主机上生成公钥/私钥对</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --gen-key</span><br></pre></td></tr></table></figure></li><li><p>在hostA主机上查看公钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --list-key</span><br></pre></td></tr></table></figure></li><li><p>把公钥导出可读的文本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg -a --<span class="built_in">export</span> -o fengtao.pubkey</span><br></pre></td></tr></table></figure></li><li><p>发送给对方hostB</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp fengtao.pubkey 192.169.11.222:/data</span><br></pre></td></tr></table></figure></li></ol><p><strong>hostB</strong></p><ol><li><p>同样在hostB主机上生成公钥/私钥对</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --gen-key</span><br></pre></td></tr></table></figure></li><li><p>导入hostA发送过来的key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --import fengtao.pubkey</span><br></pre></td></tr></table></figure></li><li><p>用从hostA主机导入的公钥，加密hostB主机的文件fstab,生成fstab.gpg</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg -e -r fengtao fstab</span><br></pre></td></tr></table></figure></li><li><p>复制加密文件到hostA主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp fstab.gpg 192.169.11.333:/data</span><br></pre></td></tr></table></figure></li><li><p>在hostA解密文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg -o fstab -d fstab.gpg</span><br></pre></td></tr></table></figure></li></ol><p><strong>删除指定公钥</strong><br>删除公钥<br>gpg –delete-keys fengtao<br>删除私钥<br>gpg –delete-secret-keys fengtao </p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密安全 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SELinux</title>
      <link href="/2018/09/11/selinux/"/>
      <url>/2018/09/11/selinux/</url>
      
        <content type="html"><![CDATA[<blockquote><p>用户权限管理中，分为root账户跟普通账户，这2中身份能否有访问资源的权限，取决于rwx的配置，不过要注意各种配置对root是无效的，当某个程序要对文件进行存取时，系统就会根据该程序的所属者，所属主判断文件的权限，如果权限通过就可以存取该文件了。<br>这种存取文件系统的方式称为 DAC：Discretionary Access Control自由访问控制，基本上就是依据程序的拥有者与文件资源的rwx权限来决定有无存取权限。不过DAC有些弊端，大概有2种情况：</p><ol><li>root 具有最高权限，如果root 账号被盗，那么后果很糟糕</li><li>如果不小心把某一文件权限设置成777，那么该目录任何人都可以任意存取。<br>这些问题非常严重， 因此我们使用 MAC：Mandatory Access Control 强制访问控制 来解决这些问题。</li></ol></blockquote><a id="more"></a><h1 id="什么是SELinux"><a href="#什么是SELinux" class="headerlink" title="什么是SELinux"></a>什么是SELinux</h1><p>SELinux是美国国家安全局(NSA=The NationalSecurity Agency)和SCC(Secure Computing Corporation)开发的 Linux的一<br>个强制访问控制的安全模块。2000年以GNU GPL发布，Linux内核2.6版本后集成在内核中</p><p>举例来默认情况下，httpd仅能在 /var/www/ 这个目录底下存取文件，如果 httpd 这个程序想要到其他目录去存取数据时， 除了配置要开放外，目标目录也得要配置成 httpd 可读取的模式 (type) 才行！限制非常多！ 所以，即使不小心 httpd 被 cracker 取得了控制权，他也无权浏览 /etc/shadow 等重要的配置！</p><h1 id="SELinux工作类型"><a href="#SELinux工作类型" class="headerlink" title="SELinux工作类型"></a>SELinux工作类型</h1><p>SELinux有四种工作类型：</p><ol><li>strict: centos5,每个进程都受到selinux的控制</li><li>targeted: 用来保护常见的网络服务,仅有限进程受到selinux控制，只监控容<br>易被入侵的进程，centos4只保护13个服务，centos5保护88个服务</li><li>minimum：centos7,修改的targeted，只对选择的网络服务</li><li>mls:提供MLS（多级安全）机制的安全性<br>targeted为默认类型，minimum和mls稳定性不足，未加以应用，strict已不再<br>使用<h1 id="安全上下文"><a href="#安全上下文" class="headerlink" title="安全上下文"></a>安全上下文</h1>传统Linux，一切皆文件，由用户，组，权限控制访问</li><li>在SELinux中，一切皆对象（object），由存放在inode的扩展属性域的安全元<br>素所控制其访问</li><li>所有文件和端口资源和进程都具备安全标签：安全上下文（security context）<br>安全上下文有五个元素组成：</li><li>user:role:type:sensitivity:category</li><li>user_u:object_r:tmp_t:s0:c0</li><li>实际上下文：存放在文件系统中，ls –Z;ps –Z</li><li>期望(默认)上下文：存放在二进制的SELinux策略库（映射目录和期望安全上下<br>文）中。</li></ol><p>说明五个安全元素</p><ol><li>User：指示登录系统的用户类型,进程：如system_u为系统服务进程，是受到管<br>制的，unconfined_u为不管制的进程，用户自己开启的，如 bash，文件：<br>system_u系统进程创建的文件， unconfined_u为用户自已创建的文件</li><li>Role：定义文件，进程和用户的用途：进程：system_r为系统服务进程，受到<br>管制。unconfined_r 为不管制进程，通常都是用户自己开启的，如 bash，文<br>件:object_r</li><li>Type：指定数据类型，规则中定义何种进程类型访问何种文件Target策略基于<br>type实现,多服务共用：public_content_t</li><li>Sensitivity：限制访问的需要，由组织定义的分层安全级别，如<br>unclassified,secret,top,secret, 一个对象有且只有一个sensitivity,分0-15级，<br>s0最低,Target策略默认使用s0</li><li>Category：对于特定组织划分不分层的分类，如FBI Secret，NSA secret, 一个<br>对象可以有多个categroy， c0-c1023共1024个分类， Target 策略不使用<br>category<h1 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h1></li><li>获取selinux当前状态<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getenforce</span><br></pre></td></tr></table></figure></li></ol><p>查看selinux状态<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sestatus</span><br></pre></td></tr></table></figure></p><p>设置selinux模式<br>setenforce 0|1<br>0: 设置为permissive<br>1: 设置为enforcing</p><p>配置文件<br>/boot/grub/grub.conf<br>在kernel行使用selinux=0禁用SELinux<br>/etc/sysconfig/selinux<br>SELINUX={disabled|enforcing|permissive}</p><p>centos6 安装semanage<br>yum provides /usr/sbin/semanage<br>yum install policycoreutils-python-2.0.83-30.1.el6_8.x86_64</p><h1 id="SELinux文件安全标签"><a href="#SELinux文件安全标签" class="headerlink" title="SELinux文件安全标签"></a>SELinux文件安全标签</h1><p> chcon [OPTION]… [-u USER] [-r ROLE] [-t TYPE] FILE…<br> 修改文件标签<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chcon -t var_log_t /var/<span class="built_in">log</span>/messages</span><br></pre></td></tr></table></figure></p><p> 重新启动使用这个文件的服务<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart rsyslog</span><br></pre></td></tr></table></figure></p><p> 也可以参考一个文件改另外一个文件<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chcon --reference /var/<span class="built_in">log</span>/messages /data/f1.txt</span><br></pre></td></tr></table></figure></p><h2 id="实例：httpd-默认的目录是-var-www-html-如果我想改成-data-目录"><a href="#实例：httpd-默认的目录是-var-www-html-如果我想改成-data-目录" class="headerlink" title="实例：httpd 默认的目录是/var/www/html 如果我想改成/data/ 目录"></a>实例：httpd 默认的目录是/var/www/html 如果我想改成/data/ 目录</h2><ol><li>向策略中新增一条规则<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">semanage fcontext -a -t  httpd_sys_content_t <span class="string">'/data(/.*)?'</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>查看data 目录的策略</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">semanage fcontext –l|grep <span class="string">"/data"</span></span><br></pre></td></tr></table></figure></li><li><p>由于策略里数据库里已经有了data目录了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restorecon –Rv /data</span><br></pre></td></tr></table></figure></li><li><p>查看是否生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll -Z /data -d</span><br></pre></td></tr></table></figure></li></ol><p>如果要删除<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">semanage fcontext -d –t httpd_sys_content_t <span class="string">'/data(/.*)?'</span></span><br></pre></td></tr></table></figure></p><p>selinux 的配置文件在 /etc/selinux 中。</p><h1 id="SELinux端口标签"><a href="#SELinux端口标签" class="headerlink" title="SELinux端口标签"></a>SELinux端口标签</h1><ol><li><p>查看端口标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">semanage port –l</span><br></pre></td></tr></table></figure></li><li><p>添加端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">semanage port -a -t port_label -p tcp|udp PORT</span><br><span class="line">semanage port -a -t http_port_t -p tcp 9527</span><br></pre></td></tr></table></figure></li><li><p>删除端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">semanage port -d -t port_label -p tcp|udp PORT</span><br><span class="line">semanage port -d -t http_port_t -p tcp 9527</span><br></pre></td></tr></table></figure></li><li><p>修改现有端口为新标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">semanage port -m -t port_label -p tcp|udp PORT</span><br><span class="line">semanage port -m -t http_port_t -p tcp 9527</span><br></pre></td></tr></table></figure></li></ol><h2 id="实例修改httpd-默认的端口"><a href="#实例修改httpd-默认的端口" class="headerlink" title="实例修改httpd 默认的端口"></a>实例修改httpd 默认的端口</h2><ol><li><p>查看http端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">semanage port -l|grep http</span><br></pre></td></tr></table></figure></li><li><p>修改http默认端口为9527</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/httpd/conf/httpd.conf</span><br></pre></td></tr></table></figure></li><li><p>新增9527端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">semanage port -a -t http_port_t -p tcp 9527</span><br></pre></td></tr></table></figure></li><li><p>重启http服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart httpd</span><br></pre></td></tr></table></figure></li></ol><h1 id="管理SELinux布尔值开关"><a href="#管理SELinux布尔值开关" class="headerlink" title="管理SELinux布尔值开关"></a>管理SELinux布尔值开关</h1><p>查看bool命令：<br>getsebool [-a] [boolean]<br>semanage boolean –l<br>semanage boolean -l –C 查看修改过的布尔值<br>设置bool值命令：<br>setsebool [-P] boolean value（on,off）<br>setsebool [-P] Boolean=value（0，1）<br>-P 表示又改当前状态，也改数据库<br>比如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsebool -P samba_enable_home_dirs on</span><br></pre></td></tr></table></figure></p><h1 id="管理日志"><a href="#管理日志" class="headerlink" title="管理日志"></a>管理日志</h1><p>yum install setroubleshoot（重启生效）</p><ol><li>将错误的信息写入/var/log/message<br>grep setroubleshoot /var/log/messages</li><li>查看安全事件日志说明<br>sealert -l UUID</li><li>扫描并分析日志<br>sealert -a /var/log/audit/audit.log</li></ol><p>写入日志<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger <span class="string">"messages"</span></span><br></pre></td></tr></table></figure></p><p>监控日志<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f /var/<span class="built_in">log</span>/messages</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SELinux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>awk</title>
      <link href="/2018/09/11/awk/"/>
      <url>/2018/09/11/awk/</url>
      
        <content type="html"><![CDATA[<blockquote><p>awk是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入(stdin)、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是linux/unix下的一个强大编程工具。它在命令行中使用，但更多是作为脚本来使用。awk有很多内建的功能，比如数组、函数等，这是它和C语言的相同之处，灵活性是awk最大的优势。</p></blockquote><a id="more"></a><h1 id="awk命令格式和选项"><a href="#awk命令格式和选项" class="headerlink" title="awk命令格式和选项"></a>awk命令格式和选项</h1><p><strong>语法形式</strong><br><blockquote><p>awk [options] ‘program’ var=value file…<br>awk [options] -f programfile var=value file…<br>awk [options] ‘BEGIN{ action;… } pattern{ action;… } END{ action;… }’ file …</p><p>awk 程序通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块，共3部分组成<br>program通常是被单引号或双引号中</p></blockquote></p><p><strong>常用选项</strong></p><ul><li>-F fs   fs指定输入分隔符，fs可以是字符串或正则表达式，如-F:</li><li>-v var=value   赋值一个用户定义变量，将外部变量传递给awk</li><li>-f scripfile  从脚本文件中读取awk命令</li></ul><p><strong>模式</strong></p><ul><li>/正则表达式/：使用通配符的扩展集。</li><li>关系表达式：使用运算符进行操作，可以是字符串或数字的比较测试。</li><li>模式匹配表达式：用运算符~（匹配）和~!（不匹配）。</li><li>BEGIN语句块、pattern语句块、END语句块</li></ul><p><strong>awk基本结构</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN&#123; print "start" &#125; pattern&#123; commands &#125; END&#123; print "end" &#125;'</span> file</span><br></pre></td></tr></table></figure></p><p>一个awk脚本通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块3部分组成，这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被单引号或双引号中，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN&#123; i=0 &#125; &#123; i++ &#125; END&#123; print i &#125;'</span> filename</span><br><span class="line">awk <span class="string">"BEGIN&#123; i=0 &#125; &#123; i++ &#125; END&#123; print i &#125;"</span> filename</span><br></pre></td></tr></table></figure></p><p><strong>awk工作原理</strong><br>awk ‘BEGIN{ commands } pattern{ commands } END{ commands }’</p><ul><li>第一步：执行BEGIN{ commands }语句块中的语句；</li><li>第二步：从文件或标准输入(stdin)读取一行，然后执行pattern{ commands }语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕。</li><li>第三步：当读至输入流末尾时，执行END{ commands }语句块。</li></ul><p>BEGIN语句块在awk开始从输入流中读取行之前被执行，这是一个可选的语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中。</p><p>END语句块在awk从输入流中读取完所有的行之后即被执行，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成，它也是一个可选语句块。</p><p>pattern语句块中的通用命令是最重要的部分，它也是可选的。如果没有提供pattern语句块，则默认执行{ print }，即打印每一个读取到的行，awk读取的每一行都会执行该语句块。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">echo</span> -e <span class="string">"A line 1\nA line 2"</span> | awk <span class="string">'BEGIN&#123; print "Start" &#125; &#123; print &#125; END&#123; print "End" &#125;'</span></span><br><span class="line"> Start</span><br><span class="line"> A line 1</span><br><span class="line"> A line 2</span><br><span class="line"> End</span><br><span class="line">``` </span><br><span class="line">当使用不带参数的<span class="built_in">print</span>时，它就打印当前行，当<span class="built_in">print</span>的参数是以逗号进行分隔时，打印时则以空格作为定界符。在awk的<span class="built_in">print</span>语句块中双引号是被当作拼接符使用，例如：</span><br><span class="line">```bash</span><br><span class="line"><span class="built_in">echo</span> | awk <span class="string">'&#123; var1="v1"; var2="v2"; var3="v3"; print var1,var2,var3; &#125;'</span> </span><br><span class="line">v1 v2 v3</span><br></pre></td></tr></table></figure></p><p>{ }类似一个循环体，会对文件中的每一行进行迭代，通常变量初始化语句（如：i=0）以及打印文件头部的语句放入BEGIN语句块中，将打印的结果等语句放在END语句块中。</p><p><strong>awk内置变量</strong></p><ul><li>FS：输入字段分隔符，默认为空白字符<br>awk -v FS=’:’ ‘{print $1,FS,$3}’ /etc/passwd<br>awk –F: ‘{print $1,$3,$7}’ /etc/passwd</li><li>OFS：输出字段分隔符，默认为空白字符<br>awk -v FS=‘:’ -v OFS=‘:’ ‘{print $1,$3,$7}’ /etc/passwd</li><li>RS：输入记录分隔符，指定输入时的换行符<br>awk -v RS=’ ‘ ‘{print }’ /etc/passwd</li><li>ORS：输出记录分隔符，输出时用指定符号代替换行符<br>awk -v RS=’ ‘ -v ORS=’###’‘{print }’ /etc/passwd</li><li>NF：字段数量<br>awk -F： ‘{print NF}’ /etc/fstab,引用内置变量不用$<br>awk -F: ‘{print $(NF-1)}’ /etc/passwd</li><li>NR：记录号<br>awk ‘{print NR}’ /etc/fstab ; awk END’{print NR}’ /etc/fstab</li><li>FNR：各文件分别计数,记录号<br>awk ‘{print FNR}’ /etc/fstab /etc/inittab</li><li>FILENAME：当前文件名<br>awk ‘{print FILENAME}’ /etc/fstab</li><li>ARGC：命令行参数的个数<br>awk ‘{print ARGC}’ /etc/fstab /etc/inittab<br>awk ‘BEGIN {print ARGC}’ /etc/fstab /etc/inittab</li><li>ARGV：数组，保存的是命令行所给定的各参数<br>awk ‘BEGIN {print ARGV[0]}’ /etc/fstab /etc/inittab<br>awk ‘BEGIN {print ARGV[1]}’ /etc/fstab /etc/inittab</li></ul><p>统计文件中的行数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'END&#123;print NR&#125;'</span> f2</span><br></pre></td></tr></table></figure></p><p>一个每一行中第一个字段值累加的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">seq 5 | awk <span class="string">'BEGIN&#123; sum=0; print "总和：" &#125; &#123; print $1"+"; sum+=$1 &#125; END&#123; print "等于"; print sum &#125;'</span> </span><br><span class="line">总和：</span><br><span class="line">1+</span><br><span class="line">2+</span><br><span class="line">3+</span><br><span class="line">4+</span><br><span class="line">5+</span><br><span class="line">等于</span><br><span class="line">15</span><br></pre></td></tr></table></figure></p><h1 id="将外部变量值传递给awk"><a href="#将外部变量值传递给awk" class="headerlink" title="将外部变量值传递给awk"></a>将外部变量值传递给awk</h1><p>借助-v选项，可以将外部值（并非来自stdin）传递给awk<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VAR=10000</span><br><span class="line"><span class="built_in">echo</span> | awk -v VARIABLE=<span class="variable">$VAR</span> <span class="string">'&#123; print VARIABLE &#125;'</span></span><br></pre></td></tr></table></figure></p><p>另外一种<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var1=<span class="string">"aaa"</span></span><br><span class="line">var2=<span class="string">"bbb"</span></span><br><span class="line"><span class="built_in">echo</span> | awk <span class="string">'&#123; print v1,v2 &#125;'</span> v1=<span class="variable">$var1</span> v2=<span class="variable">$var2</span></span><br></pre></td></tr></table></figure></p><p>当输入来自于文件时使用：<br>awk ‘{ print v1,v2 }’ v1=$var1 v2=$var2 filename</p><h1 id="awk运算与判断"><a href="#awk运算与判断" class="headerlink" title="awk运算与判断"></a>awk运算与判断</h1><h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost data]<span class="comment"># awk 'BEGIN&#123;a="b";print a++,++a;&#125;'</span></span><br><span class="line">0 2</span><br></pre></td></tr></table></figure><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN&#123;a=1;b=2;print (a&gt;5 &amp;&amp; b&lt;=2),(a&gt;5 || b&lt;=2);&#125;'</span></span><br><span class="line">0 1</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F: <span class="string">'$3 &gt;300 &#123;print $3&#125;'</span> /etc/passwd</span><br></pre></td></tr></table></figure><h2 id="正则运算"><a href="#正则运算" class="headerlink" title="正则运算"></a>正则运算</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN&#123;a="100testa";if(a ~ /^100*/)&#123;print "ok";&#125;&#125;'</span></span><br><span class="line">ok</span><br></pre></td></tr></table></figure><h2 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN&#123;a=11;if(a &gt;= 9)&#123;print "ok";&#125;&#125;'</span></span><br><span class="line">ok</span><br></pre></td></tr></table></figure><h2 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h2><p>awk -F: ‘$0 ~ /root/{print $0}’ /etc/passwd</p><h2 id="大于等于"><a href="#大于等于" class="headerlink" title="大于等于"></a>大于等于</h2><p>awk -F: ‘$3 &gt;= 100{print $0}’ /etc/passwd</p><h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><p>awk -F: ‘$0 !~ /^root/{print $0}’ /etc/passwd</p><h2 id="表示不匹配"><a href="#表示不匹配" class="headerlink" title="! 表示不匹配"></a>! 表示不匹配</h2><p>df |awk -F” +|%” ‘$0 ~ /^\/dev\/sd/{print $1,$5}’ </p><h2 id="取反要加"><a href="#取反要加" class="headerlink" title="取反要加()"></a>取反要加()</h2><p>awk -F: ‘! ($3 &gt;300) {print $3}’ /etc/passwd</p><h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><p>awk -F: ‘{$3&gt;=1000?usertype=”Common User”:usertype=”Sysadmin or SysUser”;printf “%15s:%-s\n”,$1,usertype}’ /etc/passwd</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>awk -F: ‘$0 !~ /^root/{print $0}’ /etc/passwd<br>df |awk -F” +|%” ‘/^\/dev\/sd/{print $1,$5}’ </p><h2 id="真假-i为0-不打印"><a href="#真假-i为0-不打印" class="headerlink" title="真假 i为0 不打印"></a>真假 i为0 不打印</h2><p>awk -F: ‘i=0{print $0}’ /etc/passwd</p><h2 id="打印行范围"><a href="#打印行范围" class="headerlink" title="打印行范围"></a>打印行范围</h2><p>awk ‘NR&gt;=1 &amp;&amp; NR&lt;=3’ /etc/passwd</p><h2 id="打印匹配行范围"><a href="#打印匹配行范围" class="headerlink" title="打印匹配行范围"></a>打印匹配行范围</h2><p>awk ‘/^b/,/^f/‘ /etc/passwd </p><h2 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h2><p>awk -v test=’hello gawk’ ‘{print test}’ /etc/fstab<br>seq 5 | awk ‘BEGIN{ sum=0; print “总和：” } { print $1”+”; sum+=$1 } END{ print “等于”; print sum }’</p><h1 id="awk高级输入输出"><a href="#awk高级输入输出" class="headerlink" title="awk高级输入输出"></a>awk高级输入输出</h1><h2 id="读取下一条记录"><a href="#读取下一条记录" class="headerlink" title="读取下一条记录"></a>读取下一条记录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat text.txt</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">awk <span class="string">'NR%2==1&#123;next&#125;&#123;print NR,$0;&#125;'</span> text.txt</span><br><span class="line">2 b</span><br><span class="line">4 d</span><br></pre></td></tr></table></figure><h2 id="简单读取一条记录"><a href="#简单读取一条记录" class="headerlink" title="简单读取一条记录"></a>简单读取一条记录</h2><p>执行linux的date命令，并通过管道输出给getline，然后再把输出赋值给自定义变量out，并打印它：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN&#123; "date" | getline out; print out &#125;'</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p><p>awk中允许在程序中关闭一个输入或输出文件，方法是使用awk的close语句。<br>close(“filename”)<br>filename可以是getline打开的文件，也可以是stdin</p><h2 id="输出到一个文件"><a href="#输出到一个文件" class="headerlink" title="输出到一个文件"></a>输出到一个文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> | awk <span class="string">'&#123;printf("hello word!n") &gt; "datafile"&#125;'</span></span><br><span class="line">或</span><br><span class="line"><span class="built_in">echo</span> | awk <span class="string">'&#123;printf("hello word!n") &gt;&gt; "datafile"&#125;'</span></span><br></pre></td></tr></table></figure><h2 id="设置字段的界定符"><a href="#设置字段的界定符" class="headerlink" title="设置字段的界定符"></a>设置字段的界定符</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN&#123; FS=":" &#125; &#123; print $NF &#125;'</span> /etc/passwd</span><br></pre></td></tr></table></figure><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><p><strong>if</strong><br>if(表达式)<br>  {语句1}<br>else if(表达式)<br>  {语句2}<br>else<br>  {语句3}<br><strong>实例</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN&#123;</span></span><br><span class="line"><span class="string">test=100;</span></span><br><span class="line"><span class="string">if(test&gt;90)&#123;</span></span><br><span class="line"><span class="string">  print "very good";</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  else if(test&gt;60)&#123;</span></span><br><span class="line"><span class="string">    print "good";</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  else&#123;</span></span><br><span class="line"><span class="string">    print "no pass";</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure></p><p><strong>for</strong><br>for(变量 in 数组)<br>  {语句}<br><strong>实例</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN&#123;</span></span><br><span class="line"><span class="string">total=0;</span></span><br><span class="line"><span class="string">for(i=0;i&lt;=100;i++)&#123;</span></span><br><span class="line"><span class="string">  total+=i;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">print total;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br><span class="line">5050</span><br><span class="line">```  </span><br><span class="line">**<span class="keyword">while</span>**</span><br><span class="line"><span class="keyword">while</span>(表达式)</span><br><span class="line">  &#123;语句&#125;</span><br><span class="line"> **实例** </span><br><span class="line">```bash</span><br><span class="line">awk <span class="string">'BEGIN&#123;</span></span><br><span class="line"><span class="string">test=100;</span></span><br><span class="line"><span class="string">total=0;</span></span><br><span class="line"><span class="string">while(i&lt;=test)&#123;</span></span><br><span class="line"><span class="string">  total+=i;</span></span><br><span class="line"><span class="string">  i++;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">print total;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br><span class="line">5050</span><br></pre></td></tr></table></figure></p><p>break 当 break 语句用于 while 或 for 语句时，导致退出程序循环。<br>continue 当 continue 语句用于 while 或 for 语句时，使程序循环移动到下一个迭代。<br>next 能能够导致读入下一个输入行，并返回到脚本的顶部。这可以避免对当前输入行执行其他的操作过程。<br>exit 语句使主输入循环退出并将控制转移到END,如果END存在的话。如果没有定义END规则，或在END中应用exit语句，则终止脚本的执行。</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是awk的灵魂，处理文本中最不能少的就是它的数组处理。因为数组索引（下标）可以是数字和字符串在awk中数组叫做关联数组(associative arrays)。awk 中的数组不必提前声明，也不必声明大小。数组元素用0或空字符串来初始化，这根据上下文而定。<br><strong>数字做下标</strong><br>Array[1]=”sun”<br>Array[2]=”kai”<br><strong>字符串做下标</strong><br>Array[“first”]=”www”<br>Array[“last”]=”name”<br>Array[“birth”]=”1987”<br><strong>读取值</strong><br>{ for(item in array) {print array[item]}; } #输出的顺序是随机的<br><strong>得到数组的长度</strong><br>awk ‘BEGIN{info=”it is a test”;lens=split(info,tA,” “);print length(tA),lens;}’<br><strong>判断是否存在</strong><br>awk ‘BEGIN{tB[“a”]=”a1”;tB[“b”]=”b1”;if( “c” in tB){print “ok”;};for(k in tB){print k,tB[k];}}’<br><strong>删除</strong><br>awk ‘BEGIN{tB[“a”]=”a1”;tB[“b”]=”b1”;delete tB[“a”];for(k in tB){print k,tB[k];}}’</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>sub( Ere, Repl, [ In ] )<br>用 Repl 参数指定的字符串替换 In 参数指定的字符串中的由 Ere 参数指定的扩展正则表达式的第一个具体值。sub 函数返回替换的数量。出现在 Repl 参数指定的字符串中的 &amp;（和符号）由 In 参数指定的与 Ere 参数的指定的扩展正则表达式匹配的字符串替换。如果未指定 In 参数，缺省值是整个记录（$0 记录变量）。<br>gsub( Ere, Repl, [ In ] )<br>除了正则表达式所有具体值被替代这点，它和 sub 函数完全一样地执行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN&#123;info="this is a test2010test!";gsub(/[0-9]+/,"!",info);print info&#125;'</span></span><br><span class="line">this is a <span class="built_in">test</span>!<span class="built_in">test</span>!</span><br></pre></td></tr></table></figure></p><p>substr<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN&#123;info="this is a test2010test!";print substr(info,4,10);&#125;'</span></span><br><span class="line">s is a tes</span><br></pre></td></tr></table></figure></p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li><p>cat /etc/fstab 统计下文件系统的数量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'/^UUID/&#123;print $3&#125;'</span> /etc/fstab |sort|uniq -c</span><br><span class="line">awk <span class="string">'&#123;for(i=1;i&lt;=NF;i++)word[$i]++&#125;END&#123;for (i in word)&#123;print i,word[i]&#125;&#125;'</span> /etc/fstab</span><br></pre></td></tr></table></figure></li><li><p>netstat -nt 每个ip连接次数统计  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -nt|awk -F<span class="string">" +|:"</span> <span class="string">'/^tcp/&#123;print $6&#125;'</span>|sort|uniq -c</span><br></pre></td></tr></table></figure></li><li><p>取出分区利用率</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df |awk -F<span class="string">" +|%"</span> <span class="string">'/^\/dev/sd/&#123;if($5&gt;5)&#123;print $5;print full&#125;'</span></span><br></pre></td></tr></table></figure></li><li><p>日志文件access_log访问ip次数大于1000的 加到防火墙里。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123;ip[$1]++&#125;END&#123;for( i in ip)&#123;if(ip[i]&gt;=1000)system("iptables -A INPUT -s "i" -j REJECT")&#125;&#125;'</span> /var/<span class="built_in">log</span>/httpd/access_log</span><br></pre></td></tr></table></figure></li><li><p>计算1到100的和</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN&#123;sum=0;for(i=1;i&lt;=100;i++)&#123;sum+=i&#125;print sum&#125;'</span></span><br></pre></td></tr></table></figure></li><li><p>打印奇数<br>seq 10 |awk ‘i=!i’</p></li><li>打印偶数<br>seq 10 |awk -v i=1 ‘i=!i’</li><li><p>取出磁盘利用率的3种方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df |grep <span class="string">"^/dev/sd"</span>|awk <span class="string">'&#123;print $1,$5&#125;'</span> |awk  -F% <span class="string">'&#123;print $1&#125;'</span></span><br><span class="line"></span><br><span class="line">df |grep <span class="string">"^/dev/sd"</span>|awk -F<span class="string">'[ %]+'</span> <span class="string">'&#123;print $1,$5&#125;'</span>  </span><br><span class="line"></span><br><span class="line">df |grep <span class="string">"^/dev/sd"</span>|awk -F<span class="string">' +|%'</span> <span class="string">'&#123;print $1,$5&#125;'</span></span><br></pre></td></tr></table></figure></li><li><p>算出每个性别的平均成绩</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'!/^name/&#123;if($3=="m")&#123;score_m+=$2;number_m++&#125;else&#123;score_f+=$2;number_f++&#125;&#125;END&#123;print "avg_m="score_m/number_m,"avg_f="score_f/number_f&#125;'</span> score.txt</span><br><span class="line">avg_m=96.3333 avg_f=98.5</span><br><span class="line">awk <span class="string">'NR!=1&#123;score[$3]+=$2;num[$3]++&#125;END&#123;for(sex in num)&#123;print sex":avg="score[sex]/num[sex]&#125;&#125;'</span> score.txt</span><br></pre></td></tr></table></figure></li><li><p>算出最大值最小值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F<span class="string">","</span> <span class="string">'&#123;max=$1;min=$1;i=2;while(i&lt;=NF)&#123;if($i&gt;max)&#123;max=$i&#125;;if($i&lt;min)&#123;min=$i&#125;;i++;&#125;&#125;END&#123;print "max="max,"min="min&#125;'</span> f1.txt</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> awk </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux启动排错</title>
      <link href="/2018/09/05/Linux%E5%90%AF%E5%8A%A8%E6%8E%92%E9%94%99/"/>
      <url>/2018/09/05/Linux%E5%90%AF%E5%8A%A8%E6%8E%92%E9%94%99/</url>
      
        <content type="html"><![CDATA[<blockquote><p> linux启动排错，前提要把防火墙，selinux 关闭掉。<br> chkconfig iptables off<br>把 /etc/sysconfig/selinux selinux 改为 disabled</p></blockquote><a id="more"></a><h1 id="一·-删除-boot-initramfs-2-6-32-754-el6-x86-64-img-文件进行恢复"><a href="#一·-删除-boot-initramfs-2-6-32-754-el6-x86-64-img-文件进行恢复" class="headerlink" title="一· 删除/boot/initramfs-2.6.32-754.el6.x86_64.img 文件进行恢复"></a>一· 删除/boot/initramfs-2.6.32-754.el6.x86_64.img 文件进行恢复</h1><ol><li><p>进入救援模式执行</p></li><li><p>chroot /mnt/sysimage</p></li><li><p>为当前正在使用的内核重新制作ramdisk文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkinitrd /boot/initramfs-$(uname -r).img $(uname -r)</span><br></pre></td></tr></table></figure></li></ol><h1 id="二·-把-boot-vmlinuz-2-6-32-754-el6-x86-64-文件删除，怎么恢复呢？"><a href="#二·-把-boot-vmlinuz-2-6-32-754-el6-x86-64-文件删除，怎么恢复呢？" class="headerlink" title="二· 把/boot/vmlinuz-2.6.32-754.el6.x86_64 文件删除，怎么恢复呢？"></a>二· 把/boot/vmlinuz-2.6.32-754.el6.x86_64 文件删除，怎么恢复呢？</h1><ol><li>进入救援模式</li><li><p>挂载光盘</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mnt/cdrom</span><br><span class="line">mount /dev/sr0 /mnt/cdrom</span><br></pre></td></tr></table></figure></li><li><p>进入/mnt/cdrom/isolinux,我们发现有我们刚删除的内核文件,然后拷贝到我们的/boot下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /mnt/cdrom/isolinux/vmlinuz  /mnt/sysimage/boot/vmlinuz-`uname -r`</span><br></pre></td></tr></table></figure></li><li><p>切根 chroot /mnt/sysimage</p></li><li>cd /boot/ 发现跟其他文件的版本号一样</li><li>exit</li><li>reboot</li></ol><h1 id="三·-修改-etc-inittab文件，id-6，开机就重启，怎么恢复正常？"><a href="#三·-修改-etc-inittab文件，id-6，开机就重启，怎么恢复正常？" class="headerlink" title="三· 修改/etc/inittab文件，id:6，开机就重启，怎么恢复正常？"></a>三· 修改/etc/inittab文件，id:6，开机就重启，怎么恢复正常？</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/inittab </span><br><span class="line">id:6:initdefault:</span><br></pre></td></tr></table></figure><ol><li>我们在启动的时候按任意键进入<br><img src="/Linux/linux启动.png" alt="logo"></li><li>输入a ,然后输入 5，回车<br><img src="/Linux/linux启动1.png" alt="logo"></li></ol><h1 id="四·-centos6-单用户破解口令"><a href="#四·-centos6-单用户破解口令" class="headerlink" title="四· centos6 单用户破解口令"></a>四· centos6 单用户破解口令</h1><ol><li>我们在启动的时候按任意键进入<br><img src="/Linux/linux启动.png" alt="logo"></li><li>输入a ,然后输入 1，回车</li><li>输入passwd修改密码<br><img src="/Linux/单用户模式破解口令.png" alt="logo"></li></ol><h1 id="五·-破坏分区表前446个字节"><a href="#五·-破坏分区表前446个字节" class="headerlink" title="五· 破坏分区表前446个字节"></a>五· 破坏分区表前446个字节</h1><h2 id="有备份的情况"><a href="#有备份的情况" class="headerlink" title="有备份的情况"></a>有备份的情况</h2><ol><li><p>备份分区表前446个字节</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/sda of=/data/grubstage1 bs=1 count=446</span><br></pre></td></tr></table></figure><p>查看是否已经备份</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexdump -C /data/grubstage1</span><br></pre></td></tr></table></figure></li><li><p>删除分区表前446个字节</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=/dev/sda bs=1 count=446</span><br></pre></td></tr></table></figure><p>查看前面446个字节</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexdump -C /dev/sda -n 446 -v</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>重启进入救援模式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chroot /mnt/sysimage</span><br><span class="line"> dd <span class="keyword">if</span>=/mnt/sysimage/data/grubstage1 of=/dev/sda</span><br></pre></td></tr></table></figure></li></ol><h2 id="无备份的情况"><a href="#无备份的情况" class="headerlink" title="无备份的情况"></a>无备份的情况</h2><ol><li><p>备份分区表前446个字节</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/sda of=/data/grubstage1 bs=1 count=446</span><br></pre></td></tr></table></figure><p>查看是否已经备份</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexdump -C /data/grubstage1</span><br></pre></td></tr></table></figure></li><li><p>删除分区表前446个字节</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=/dev/sda bs=1 count=446</span><br></pre></td></tr></table></figure><p>查看前面446个字节</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexdump -C /dev/sda -n 446 -v</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>重启进入救援模式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#grub-install --root-directory=/mnt/sysimage /dev/sda </span></span><br><span class="line">chroot /mnt/sysimage</span><br><span class="line">grub-install /dev/sda</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用grub命令恢复"><a href="#使用grub命令恢复" class="headerlink" title="使用grub命令恢复"></a>使用grub命令恢复</h2><ol><li><p>备份分区表前446个字节</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/sda of=/data/grubstage1 bs=1 count=446</span><br></pre></td></tr></table></figure><p>查看是否已经备份</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexdump -C /data/grubstage1</span><br></pre></td></tr></table></figure></li><li><p>删除分区表前446个字节</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=/dev/sda bs=1 count=446</span><br></pre></td></tr></table></figure><p>查看前面446个字节</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexdump -C /dev/sda -n 446 -v</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>重启进入救援模式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grub </span><br><span class="line">root (hd0,0)</span><br><span class="line">setup (hd0)</span><br><span class="line">sync</span><br></pre></td></tr></table></figure></li></ol><h1 id="六·-删除-boot-grub-目录，恢复"><a href="#六·-删除-boot-grub-目录，恢复" class="headerlink" title="六· 删除/boot/grub 目录，恢复"></a>六· 删除/boot/grub 目录，恢复</h1><ol><li>rm -fr /boot/grub</li><li>重启进入救援模式</li><li>chroot /mnt/sysimage</li><li>grub-install /dev/sda</li><li>vim /boot/grub/grub.conf<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">default=0  </span><br><span class="line">timeout=5  </span><br><span class="line">title=<span class="string">"wanglinux"</span></span><br><span class="line">root (hd0,0)</span><br><span class="line">kernel /vmlinuz root=/dev/sda2</span><br><span class="line">initrd /initramfs</span><br><span class="line">:! ls /boot/vmlinuz /boot/initramfs</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure></li></ol><h1 id="七·-删除-boot目录"><a href="#七·-删除-boot目录" class="headerlink" title="七· 删除/boot目录"></a>七· 删除/boot目录</h1><ol><li>rm -fr /boot/</li><li>重启进入救援模式</li><li><p>挂载光盘</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sr0 /mnt/</span><br></pre></td></tr></table></figure></li><li><p>切根</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chroot /mnt/sysimage</span><br></pre></td></tr></table></figure></li><li><p>把光盘的里vmlinuz文件拷贝回来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /mnt/isolinux/vmlinuz /boot/</span><br></pre></td></tr></table></figure></li><li><p>生成initramfs文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkinitrd /boot/initramfs.img `uname -r`</span><br></pre></td></tr></table></figure></li><li><p>生成grub文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-install /dev/sda</span><br></pre></td></tr></table></figure></li><li><p>创建grub.conf 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /boot/grub/grub.conf</span><br><span class="line">default=0  </span><br><span class="line">timeout=5  </span><br><span class="line">title=<span class="string">"wanglinux"</span></span><br><span class="line">root (hd0,0)</span><br><span class="line">kernel /vmlinuz root=/dev/sda2</span><br><span class="line">initrd /initramfs</span><br></pre></td></tr></table></figure></li><li><p>exit 重启</p></li></ol><h1 id="八·-删除-etc-fstab-文件"><a href="#八·-删除-etc-fstab-文件" class="headerlink" title="八· 删除/etc/fstab 文件"></a>八· 删除/etc/fstab 文件</h1><ol><li><p>删除/etc/fstab</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f /etc/fstab</span><br></pre></td></tr></table></figure></li><li><p>重启系统</p></li><li>进入救援模式</li><li>找到系统的根<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blkid</span><br></pre></td></tr></table></figure></li></ol><p>我们依次挂载找到根<br>mount /dev/sda1 /mnt/temp<br>ls /mnt/temp</p><ol start="5"><li><p>把根目录下生成fstab文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim /mnt/temp/etc/fstab </span><br><span class="line">/dev/sda1 /boot ext4 defaults 0 0 </span><br><span class="line">/dev/sda2 / ext4 defaults 0 0 </span><br><span class="line">/dev/sda3 /data ext4 defaults 0 0 </span><br><span class="line">/dev/sda5 /swap swap defaults 0 0</span><br></pre></td></tr></table></figure></li><li><p>重启，让系统自动区挂载光盘</p></li><li><p>切根</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chroot /mnt/sysimage</span><br></pre></td></tr></table></figure></li><li><p>挂载光盘</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sr0 /mnt</span><br></pre></td></tr></table></figure></li><li><p>安装内核文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh /mnt/Packages/kernel-2.6.32-754.c16.x86_64.rpm --force</span><br></pre></td></tr></table></figure></li><li><p>生成grub文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-install /dev/sda</span><br></pre></td></tr></table></figure></li><li><p>创建grub.conf 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /boot/grub/grub.conf</span><br><span class="line">default=0  </span><br><span class="line">timeout=5  </span><br><span class="line">title=<span class="string">"wanglinux"</span></span><br><span class="line">root (hd0,0)</span><br><span class="line">kernel /vmlinuz root=/dev/sda2</span><br><span class="line">initrd /initramfs</span><br></pre></td></tr></table></figure></li><li><p>sync</p></li><li>重启 </li></ol><h1 id="九·-删除-boot-grub2-目录（centos7）"><a href="#九·-删除-boot-grub2-目录（centos7）" class="headerlink" title="九· 删除/boot/grub2 目录（centos7）"></a>九· 删除/boot/grub2 目录（centos7）</h1><ol><li>重启进入救援模式</li><li>grub2-install /dev/sda</li><li><p>生成grub 配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure></li><li><p>重启</p><h1 id="十·-删除-boot-目录（centos7）"><a href="#十·-删除-boot-目录（centos7）" class="headerlink" title="十· 删除/boot 目录（centos7）"></a>十· 删除/boot 目录（centos7）</h1></li><li>重启进入救援模式</li><li><p>加载光盘</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sr0 /mnt</span><br></pre></td></tr></table></figure></li><li><p>安装内核文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh /mnt/Packages/kernel-3.10.0.862.e17.x86_64.rpm --force</span><br></pre></td></tr></table></figure></li><li><p>执行同步</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sync</span><br></pre></td></tr></table></figure></li><li><p>生成grub 目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-install /dev/sda</span><br></pre></td></tr></table></figure></li><li><p>生成grub配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure></li><li><p>重启</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 启动排错 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux内核编译</title>
      <link href="/2018/09/05/%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/"/>
      <url>/2018/09/05/%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<blockquote><p>单内核体系设计、但充分借鉴了微内核设计体系的优点，为内核引入模块化机制，我们可以进行内核的定制化，比如把docker等集成到内核里，也可以去掉一些不想要的功能。</p></blockquote><a id="more"></a><h1 id="内核的组成部分"><a href="#内核的组成部分" class="headerlink" title="内核的组成部分"></a>内核的组成部分</h1><p>kernel: 内核核心，一般为bzImage，通常在/boot目录下，名称为vmlinuzVERSION-RELEASE<br>kernel object: 内核对象，一般放置于<br>/lib/modules/VERSION-RELEASE/<br>辅助文件：ramdisk<br>initrd<br>initramfs<br>locate ext4.ko<br>ls  /lib/modules/2.6.32-754.el6.x86_64/kernel/fs</p><h1 id="内核的版本"><a href="#内核的版本" class="headerlink" title="内核的版本"></a>内核的版本</h1><p>uname命令：<br>uname - print system information<br>uname [OPTION]…<br>-n: 显示节点名称<br>-r: 显示VERSION-RELEASE<br>-a:显示所有信息</p><h1 id="内核模块命令"><a href="#内核模块命令" class="headerlink" title="内核模块命令"></a>内核模块命令</h1><p>lsmod命令：<br>显示由核心已经装载的内核模块<br>显示的内容来自于: /proc/modules文件</p><p>modinfo命令：<br>显示模块的详细描述信息<br>modinfo [ -k kernel ] [ modulename|filename… ]<br>-n: 只显示模块文件路径<br>-p: 显示模块参数<br>-a: author<br>-d: description<br>-l: license</p><p>lsmod |grep xfs;modinfo xfs</p><h1 id="内核模块管理"><a href="#内核模块管理" class="headerlink" title="内核模块管理"></a>内核模块管理</h1><p>modprobe命令：<br>装载或卸载内核模块<br>modprobe [ -C config-file ] [ modulename ] [ module parame-ters… ]<br>配置文件：/etc/modprobe.conf, /etc/modprobe.d/*.conf<br>modprobe [ -r ] modulename…<br>depmod命令：<br>内核模块依赖关系文件及系统信息映射文件的生成工具<br>insmod命令：指定模块文件，不自动解决依赖模块<br>insmod [ filename ] [ module options… ]<br>insmod <code>modinfo –n exportfs</code><br>lnsmod <code>modinfo –n xfs</code><br>rmmod命令：卸载模块<br>rmmod [ modulename ]<br>rmmod xfs<br>rmmod exportfs</p><h1 id="内核的编译"><a href="#内核的编译" class="headerlink" title="内核的编译"></a>内核的编译</h1><p>在 cat /boot/config-2.6.32-754.el6.x86_64 定义了当前内核启用了什么功能，没有启用什么功能。<br>文件分2部分存放：</p><ol><li>vmlinuz 文件里</li><li>核心的模块文件放在了/lib/modules/<code>unaem -r</code></li></ol><p>等于y 的放在vmlinuz文件种<br>等于m的放在/lib/modules/<code>uname -r</code>下</p><p><strong>编译前提环境准备</strong></p><p>(1) 获取内核源代码包<br> <a href="http://www.kernel.org" target="_blank" rel="noopener">www.kernel.org</a><br> <a href="https://fengxinhua.cn//Linux/linux-4.18.5.tar.xz" target="_blank" rel="noopener">内核包下载</a></p><p>（2） 解压源码<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvf linux-4.18.5.tar.xz</span><br></pre></td></tr></table></figure></p><p>（3） 进入解压目录，把/boot/config-2.6.32-754.el6.x86_64 复制到当前目录，改名叫.config </p><p>（4）安装必要的工具包<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum groupinstall <span class="string">"development tools"</span>  -y</span><br><span class="line">yum install ncurses-devel </span><br><span class="line">yum install elfutils-libelf-devel</span><br><span class="line">yum install openssl-devel</span><br></pre></td></tr></table></figure></p><p>（5） make menuconfig<br> 打开之后我们使用空格来修改，带*表示已经启用的功能。<br>（6）开始编译。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j 8</span><br></pre></td></tr></table></figure></p><p>（6）模块安装<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make modules_install</span><br></pre></td></tr></table></figure></p><p> （7）生成内核文件<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure></p><h1 id="卸载内核"><a href="#卸载内核" class="headerlink" title="卸载内核"></a>卸载内核</h1><ol><li>删除/lib/modules/目录下不需要的内核库文件</li><li>删除/usr/src/linux/目录下不需要的内核源码</li><li>删除/boot目录下启动的内核和内核映像文件</li><li>更改grub的配置文件，删除不需要的内核启动列表</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内核编译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux自制</title>
      <link href="/2018/09/05/Linux%E8%87%AA%E5%88%B6/"/>
      <url>/2018/09/05/Linux%E8%87%AA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>利用现有的系统，我们使用一块干净的硬盘，把这块硬盘制作一个操作系统，接到别的电脑上就可以使用。也可以用LFS从头开始制作一个始于自己的linux 系统。</p></blockquote><a id="more"></a><ol><li><p>添加一块新硬盘到虚拟机的Centos6.9系统上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsblk</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"- - -"</span> &gt; /sys/class/scsi_host/host0/scan</span><br></pre></td></tr></table></figure></li><li><p>分区格式化并挂载，boot分区200M，根分区2G</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 -L boot /dev/sdb1</span><br><span class="line">mkfs.ext4 -L root /dev/sdb2</span><br><span class="line">mkdir /mnt/boot</span><br><span class="line">mkdir /mnt/root</span><br><span class="line">mount /dev/sdb1 /mnt/boot</span><br><span class="line">mount /dev/sdb2 /mnt/root</span><br></pre></td></tr></table></figure></li><li><p>创建boot分区的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /boot/vmlinuz-2.6.32-642.el6.x86_64 /boot/initramfs-2.6.32-642.el6.x86_64.img /mnt/boot</span><br></pre></td></tr></table></figure></li><li><p>安装grub</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-install --root-directory=/mnt /dev/sdb</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /mnt/boot/grub/grub.conf</span><br><span class="line">  default=0</span><br><span class="line">  timeout=3</span><br><span class="line">  title Centos6.8--lovefirewall</span><br><span class="line">  root (hd0,0)</span><br><span class="line">  kernel /vmlinuz-2.6.32-642.el6.x86_64 selinux=0 init=/bin/bash</span><br><span class="line">  initrd /initramfs-2.6.32-642.el6.x86_64.img</span><br></pre></td></tr></table></figure><ol start="5"><li><p>创建根分区的一级目录，创建fstab文件，复制自制linux系统上所需要的命令及其库文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">拷贝主要的文件到/mnt/root 下，比如ls  cat  tree mount cp mkdir 等</span><br></pre></td></tr></table></figure></li><li><p>创建网卡模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">updatedb </span><br><span class="line">locate e1000.ko </span><br><span class="line">cp /lib/modules/2.6.32-754.el6.x86_64/kernel/drivers/net/e1000/e1000.ko /mnt/root/lib</span><br></pre></td></tr></table></figure></li><li><p>我们把硬盘文件拷贝出来</p></li><li>创建新虚拟机</li><li>把磁盘挂载上去 </li><li>启动</li><li>让启动就自带网卡功能<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /sbin/init </span><br><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line">insmod /lib/e1000.ko </span><br><span class="line">ifconfig eth1000 1.1.1.1/24</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux内核启动流程以及grub故障修复</title>
      <link href="/2018/09/05/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
      <url>/2018/09/05/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>centos 系统本质上是由内核跟各种相关的工具组合而成的。本文主要介绍内核的启动流程以及grub的故障修复。</p></blockquote><a id="more"></a><h1 id="LINUX-组成"><a href="#LINUX-组成" class="headerlink" title="LINUX 组成"></a>LINUX 组成</h1><p>Linux: kernel+rootfs（根文件系统）<br>kernel: 进程管理、内存管理、网络管理、驱动程序、文件系统、安全功能<br>rootfs:程序和glibc（glibc是GNU发布的libc库，即c运行库。glibc是linux系统中最底层的api）</p><h1 id="CENTOS5-6"><a href="#CENTOS5-6" class="headerlink" title="CENTOS5,6"></a>CENTOS5,6</h1><h2 id="内核启动流程"><a href="#内核启动流程" class="headerlink" title="内核启动流程"></a>内核启动流程</h2><ol><li>单内核(monolithic kernel)：Linux<br>把所有功能集成于同一个程序</li><li><p>微内核(micro kernel)：Windows, Solaris<br>每种功能使用一个单独子系统实现<br><strong>Linux内核特点：</strong><br>支持模块化：.ko（内核对象）<br>如：文件系统，硬件驱动，网络协议等支持内核模块的动态装载和卸载<br><strong>组成部分</strong><br>核心文件：/boot/vmlinuz-VERSION-release<br>ramdisk：辅助的伪根系统<br>CentOS 5: /boot/initrd-VERSION-release.img<br>CentOS 6,7: /boot/initramfs-VERSION-release.img<br>模块文件：/lib/modules/VERSION-release<br><strong>启动流程</strong><br>在/boot 下面有2个主要的文件<br>vmlinuz-2.6.32-754.el6.x86_64 内核文件<br>initramfs-2.6.32-754.el6.x86_64.img  启动内核的时候加载系统必要的驱动文件，实际上是一个伪操作系统。识别根文件系统。<br>把文件initramfs-2.6.32-754.el6.x86_64.img<br>解压后我们使用cpio -tv &lt; 文件  查看文件里的内容<br>cpio -idv initramfs-2.6.32-754.el6.x86_64.img<br>可以看到里边是驱动文件。<br><strong>centos5,6启动流程</strong><br><strong>RAM</strong><br>CMOS互补金属氧化物半导体，保存各项参数的设定，按次序查找引导设备，第一个有引导程序的设备为本次启动的设备。<br>注意：可修改的<br><strong>ROM</strong><br>存放的内容叫BIOS，基本的输入跟输出，保存着有关计算机系统最重要的基本输入跟输出，系统信息设置，开机加电自检程序等。注意：只读的</p><p><img src="/Linux/centos启动流程.png" alt="logo"><br>从上图可以看到流程</p></li><li>首先是POST加电自检，检测硬件比如CPU,内存,主板,硬盘子系统，键盘等情况的检测。是BIOS功能的一个主要部分。</li><li>接下来就是MBR（放在硬盘最前面的512个字节，即一个扇区），MBR分为3大块（前446个字节的主引导程序，中间64个字节的分区表即硬盘分几个区，每个分区的大小，2个字节的55AA标记位）</li><li>GRUB（bootloader 引导加载器）引导计算机启动。<br>实际上MBR 引导程序的446个字节就是存放这grub的某一部分，grub 比较功能复杂，不是一个单一的文件。<br>grub引导分为3个阶段：<br>（1）mbr的 446个字节属于第一阶段<br>（2）1.5 阶段 在mbr后面的27个扇区，找内核文件 /boot/vmlinuz/，内核要找到根文件系统的驱动加载进来，那么需要通过initramfs 文件，这个文件里放的驱动程序，模拟的是一个伪文件系统。<br>（3）2阶段   分区文件也就是根分区</li><li>启动/sbin/init 进程</li><li>读取/etc/inittab文件 这个文件定义了系统启动的默认模式（runlevel）</li><li>/etc/rc.d/rc.sysinit 初始化脚本，比如逻辑卷，raid等</li><li>/etc/rc.d/rc 脚本 用户生成中的各种服务都在这个里，比如ssh httpd mysql服务。–&gt;/etc/rc#.d下的所有脚本，# 为默认级别。</li><li>/etc/rc.d/rc.local 末尾执行这个脚本。</li><li>最后执行/bin/login程序，进入登陆界面。<br>实际上登陆完以后还要执行跟用户登陆相关的脚本，比如：/etc/bashrc,/etc/profile,/etc/profile.d,~bashrc,~.bashprofile等初始化脚本文件。</li></ol><p><strong>init程序的类型：</strong></p><ol><li>SysV: init, CentOS 5之前<br>配置文件：/etc/inittab</li><li>Upstart: init,CentOS 6<br>配置文件：/etc/inittab, /etc/init/*.conf</li><li>Systemd：systemd, CentOS 7<br>配置文件：/usr/lib/systemd/system<br>/etc/systemd/system<br>系统init进程启动后，加载的第一个配置文件/etc/inittab<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># cat /etc/inittab</span></span><br><span class="line"><span class="comment"># inittab is only used by upstart for the default runlevel.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ADDING OTHER CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># System initialization is started by /etc/init/rcS.conf</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Individual runlevels are started by /etc/init/rc.conf</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Ctrl-Alt-Delete is handled by /etc/init/control-alt-delete.conf</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Terminal gettys are handled by /etc/init/tty.conf and /etc/init/serial.conf,</span></span><br><span class="line"><span class="comment"># with configuration in /etc/sysconfig/init.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For information on how to write upstart event handlers, or how</span></span><br><span class="line"><span class="comment"># upstart works, see init(5), init(8), and initctl(8).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Default runlevel. The runlevels used are:</span></span><br><span class="line"><span class="comment">#   0 - halt (Do NOT set initdefault to this) </span></span><br><span class="line"><span class="comment">#   1 - Single user mode</span></span><br><span class="line"><span class="comment">#   2 - Multiuser, without NFS (The same as 3, if you do not have networking)</span></span><br><span class="line"><span class="comment">#   3 - Full multiuser mode</span></span><br><span class="line"><span class="comment">#   4 - unused</span></span><br><span class="line"><span class="comment">#   5 - X11</span></span><br><span class="line"><span class="comment">#   6 - reboot (Do NOT set initdefault to this)</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">id:5:initdefault:</span><br></pre></td></tr></table></figure></li></ol><p>说明<br>id 行的编号<br>5  开机在什么模式下运行<br>initdefault 执行的命令</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ol><li>系统开机初始化脚本<br>/etc/rc.d/rc.sysinit</li><li>然后根据模式运行执行不同的脚本<br>l0:0:wait:/etc/rc.d/rc 0<br>l1:1:wait:/etc/rc.d/rc 1<br>l1:1:wait:/etc/rc.d/rc 5<br>l6:6:wait:/etc/rc.d/rc 6</li><li>/etc/rc 是一个脚本<br>ls /etc/rc5.d<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># ls /etc/rc5.d</span></span><br><span class="line">K01smartd        K50kdump       K84wpa_supplicant  S02lvm2-monitor  S13irqbalance        S25cups       S70spice-vdagentd</span><br><span class="line">K02oddjobd       K60nfs         K87restorecond     S05rdma          S13rpcbind           S25netfs      S80postfix</span><br><span class="line">K05wdaemon       K61nfs-rdma    K88sssd            S08ip6tables     S15mdmonitor         S26acpid      S82abrtd</span><br></pre></td></tr></table></figure></li></ol><p>从/etc/rc脚本中看出，当运行模式是5的时候，把S开头的服务启动，K打头的停止。<br>那么怎么把S95atd改成开机不启动呢？</p><ol><li><p>cat /etc/rc5.d/S95atd</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># cat /etc/rc5.d/S95atd</span></span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># atd Starts/stop the "at" daemon</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># chkconfig:   345(什么模式下的启动的) 95(S开头) 5（K开头）</span></span><br><span class="line"><span class="comment"># description: Runs commands scheduled by the "at" command at the time \</span></span><br><span class="line"><span class="comment">#    specified when "at" was run, and runs batch commands when the load \</span></span><br><span class="line"><span class="comment">#    average is low enough.</span></span><br></pre></td></tr></table></figure></li><li><p>我们把S95atd重命名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv S95atd K05atd</span><br></pre></td></tr></table></figure></li><li><p>reboot 重启后发现atd服务是停止的。<br>注意  我们是在5模式下改的。</p></li></ol><h2 id="ntsysv"><a href="#ntsysv" class="headerlink" title="ntsysv"></a>ntsysv</h2><p>实际上我没有专门的工具 ntsysv,我们可以指定模式，如果不指定默认就是当前模式。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntsysv --level=5</span><br></pre></td></tr></table></figure></p><p><img src="/Linux/ntsysv.png" alt="logo"><br>没有*表示开机进入当前模式是不启动的。<br>我们可以通过空格键来修改他的值。</p><h2 id="chkconfig"><a href="#chkconfig" class="headerlink" title="chkconfig"></a>chkconfig</h2><p>这种模式修改也是比较麻烦我们使用chkcofig比较方便。<br>我们列出所有模式下每个服务的状态<br>chkconfig:345(什么模式下的启动的) 95(S开头) 5（K开头）<br>如果345 改成- 表示所有模式下都是禁止的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --list</span><br></pre></td></tr></table></figure></p><p>我们向把atd 服务在模式3，5下，开机的时候都自动启动。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --level 23 atd on</span><br></pre></td></tr></table></figure></p><p>当然我们也可以只看atd<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --list  atd</span><br></pre></td></tr></table></figure></p><p><strong>如何写一个服务脚本,让开机自动运行</strong></p><ol><li>cd /etc/init.d</li><li><p>vim testsrv</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># chkconfig: 345 96 3 </span></span><br><span class="line"><span class="comment"># description test service</span></span><br><span class="line">. /etc/init.d/<span class="built_in">functions</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">start) </span><br><span class="line">  action <span class="string">"启动服务"</span> <span class="literal">true</span></span><br><span class="line">   sleep 10</span><br><span class="line">  ;;</span><br><span class="line">stop)</span><br><span class="line">  action  <span class="string">"服务停止"</span> <span class="literal">false</span></span><br><span class="line">  ;;</span><br><span class="line"> restart)  </span><br><span class="line">  action  <span class="string">"服务停止"</span> <span class="literal">false</span></span><br><span class="line">  action <span class="string">"启动服务"</span> <span class="literal">true</span></span><br><span class="line">  ;;</span><br><span class="line">  *)</span><br><span class="line">  <span class="built_in">echo</span> $<span class="string">"usage:<span class="variable">$0</span> &#123;start|stop|restart&#125;"</span></span><br><span class="line">  exit2</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure></li><li><p>加到开机服务列表里</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --add testsrv</span><br></pre></td></tr></table></figure></li><li><p>关掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig  testsrv off</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --del testsrv</span><br></pre></td></tr></table></figure></li></ol><p>等所有的服务都运行完以后会执行一个脚本<br>/etc/rc.local<br>如果我们有需求，需要一个服务开机自动运行，那么我们写到这个文件里就可以了。</p><p>这2种方式是完全等价的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service sshd start </span><br><span class="line">etc/init.d/ssd start</span><br></pre></td></tr></table></figure></p><h2 id="xinetd"><a href="#xinetd" class="headerlink" title="xinetd"></a>xinetd</h2><p>Xinetd 托管服务。又名：超级守护进程，可以把一些小服务放到xinetd里进行托管。拖管后的好处就是可以使用xinetd强大的参数来控制这些服务，并且增强安全性。（比如一个小服务没有一些控制功能，但支持xinetd拖管，你就可以拖管并使用xinetd的参数来控制它)。</p><p>Xinetd提供类似于inetd + TCP Wrappers的功能，但是更加强大和安全。后面xinetd已经取代了inetd，并且提供了访问控制、加强的日志和资源管理功能。</p><p>TCP Wrappers是一个应用层的访问控制程序，其原理是在服务器向外提供的TCP服务上包裹一层安全检测机制。外来的连接请求首先要通过这层安全检测，获得认证之后才能被系统服务接收。TCP Wrappers的功能有两种实现方式：一种是由tcpd守护进程实现的，常被用于inetd + TCP Wrappers的系统中（如FreeBSD等）；另一种是通过每种服务程序调用libwrap.so链接库实现的，即libwrap.so库支持的网络服务程序都能使用TCP Wrappers来实现访问控制，常用于xinetd + TCP Wrappers的系统中（如CentOS等）。</p><p>在CentOS中，TCP Wrappers一般是默认安装的，若未安装成功，可以使用如下命令安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum  –y  install  tcp_wrappers</span><br></pre></td></tr></table></figure></p><p>安装xinetd服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum  -y  install  xinetd</span><br></pre></td></tr></table></figure></p><p>xinetd服务的主配置文件： /etc/xinetd.conf     –保持默认即可</p><p>用于存放被托管的服务的目录：/etc/xinetd.d/</p><h2 id="grub"><a href="#grub" class="headerlink" title="grub"></a>grub</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># cat /boot/grub/grub.conf</span></span><br><span class="line"><span class="comment"># grub.conf generated by anaconda</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that you do not have to rerun grub after making changes to this file</span></span><br><span class="line"><span class="comment"># NOTICE:  You have a /boot partition.  This means that</span></span><br><span class="line"><span class="comment">#          all kernel and initrd paths are relative to /boot/, eg.</span></span><br><span class="line"><span class="comment">#          root (hd0,0)</span></span><br><span class="line"><span class="comment">#          kernel /vmlinuz-version ro root=/dev/sda2</span></span><br><span class="line"><span class="comment">#          initrd /initrd-[generic-]version.img</span></span><br><span class="line"><span class="comment">#boot=/dev/sda</span></span><br><span class="line">default=0 默认菜单项</span><br><span class="line">timeout=5 倒计时</span><br><span class="line">splashimage=(hd0,0)/grub/splash.xpm.gz</span><br><span class="line">hiddenmenu</span><br><span class="line">title CentOS 6 (2.6.32-754.el6.x86_64) 启动菜单</span><br><span class="line">        root (hd0,0) boot 分区在哪里</span><br><span class="line">        kernel /vmlinuz-2.6.32-754.el6.x86_64 ro root=UUID=b93c6ed5-0fb7-4f37-89e1-f84dd7da8c54 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet</span><br><span class="line">        initrd /initramfs-2.6.32-754.el6.x86_64.img</span><br></pre></td></tr></table></figure><p>生产环境种rhgb quiet 建议去掉。<br>为了防止破解口令 我们可以在grub.conf 文件种增加<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># grub-crypt</span></span><br><span class="line">Password: </span><br><span class="line">Retype password: </span><br><span class="line"><span class="variable">$6</span><span class="variable">$3wEg6jiyJ8NILPxf</span><span class="variable">$zjjMNKsxoQjxHb</span>/sxYgILhC6Vt0CrH0pUXJ04Rny264vgjS8ZsEx/WjkKdf1mgIS7tK2xDe6XAegXceb0vB84/</span><br><span class="line">[root@centos6 ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>password –encrypted ssha密码</p><h2 id="proc-目录"><a href="#proc-目录" class="headerlink" title="/proc 目录"></a>/proc 目录</h2><p> cd /proc/sys  很重要<br> cat /etc/sysctl.conf 用于保存sys 目录下的内容<br> sysctl -p 生效<br> 优化网络，内存  等<br> 常用的参数<br> net.ipv4.ip_forward<br> net.ipv4.icmp_echo_ignore_all<br> vm/drop_caches 清空缓存<br> echo 1 &gt;  vm/drop_caches<br> sysctl -a 查看所有有效的配置</p><h2 id="sys-目录"><a href="#sys-目录" class="headerlink" title="/sys 目录"></a>/sys 目录</h2><p>sysfs：为用户使用的伪文件系统，输出内核识别出的各硬件设备的相关属<br>性信息，也有内核对硬件特性的设定信息；有些参数是可以修改的，用于调整硬件<br>工作特性<br> udev通过此路径下输出的信息动态为各设备创建所需要设备文件，udev是<br>运行用户空间程序<br>专用工具：udevadmin, hotplug<br> udev为设备创建设备文件时，会读取其事先定义好的规则文件，一般在<br>/etc/udev/rules.d及/usr/lib/udev/rules.d目录下<br>比如网卡名称</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内核启动grub故障修复 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>shell进阶</title>
      <link href="/2018/09/03/%E8%A1%A5%E5%85%85shell/"/>
      <url>/2018/09/03/%E8%A1%A5%E5%85%85shell/</url>
      
        <content type="html"><![CDATA[<blockquote><p> shell是操作系统提供给我们的一种语言，用来将用户的命令输送到内核中执行，下面主要介绍shell 判断，循环，数组以及函数的使用。<br>初级shell:<a href="http://fengxinhua.cn/2018/08/02/shell/" target="_blank" rel="noopener">初级shell</a></p></blockquote><a id="more"></a><h1 id="if"><a href="#if" class="headerlink" title="if"></a>if</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 判断条件1; <span class="keyword">then</span></span><br><span class="line">条件1为真的分支代码</span><br><span class="line"><span class="keyword">elif</span> 判断条件2; <span class="keyword">then</span></span><br><span class="line">条件2为真的分支代码</span><br><span class="line"><span class="keyword">elif</span> 判断条件3; <span class="keyword">then</span></span><br><span class="line">条件3为真的分支代码</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">以上条件都为假的分支代码</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ping -c1 -W2 127.0.0.1 &amp;&gt; /dev/null;<span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"127.0.0.1 is up"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"127.0.0.1 is down"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h1 id="case"><a href="#case" class="headerlink" title="case"></a>case</h1><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> 变量引用 <span class="keyword">in</span></span><br><span class="line">PAT1)</span><br><span class="line">分支1</span><br><span class="line">;;</span><br><span class="line">PAT2)</span><br><span class="line">分支2</span><br><span class="line">;;</span><br><span class="line">...</span><br><span class="line">*)</span><br><span class="line">默认分支</span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><h1 id="for"><a href="#for" class="headerlink" title="for"></a>for</h1><h2 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量名 <span class="keyword">in</span> 列表;<span class="keyword">do</span></span><br><span class="line"> 循环体</span><br><span class="line"> <span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><ol><li>扫描172.20.129这个网段的ip<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; /data/iplist.log</span><br><span class="line">net=172.20.129</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..254&#125;;<span class="keyword">do</span></span><br><span class="line">        &#123; <span class="keyword">if</span> ping -c1 -W1 <span class="variable">$net</span>.<span class="variable">$i</span> &amp;&gt; /dev/null ;<span class="keyword">then</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="variable">$net</span>.<span class="variable">$i</span> is up</span><br><span class="line">                <span class="built_in">echo</span> <span class="variable">$net</span>.<span class="variable">$i</span> &gt;&gt; /data/iplist.log</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="variable">$net</span>.<span class="variable">$i</span> is down</span><br><span class="line">        <span class="keyword">fi</span> &#125; &amp;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">wait</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="while"><a href="#while" class="headerlink" title="while"></a>while</h1><h2 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> CONDITION; <span class="keyword">do</span></span><br><span class="line">循环体</span><br><span class="line"> <span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span></span><br><span class="line">循环体</span><br><span class="line"><span class="keyword">done</span> &lt; /PATH/FROM/SOMEFILE</span><br></pre></td></tr></table></figure><p>依次读取/PATH/FROM/SOMEFILE文件中的每一行，且将行赋值给变量line</p><ol start="2"><li><p>扫描/etc/passwd文件每一行，如发现GECOS字段为空，则填充用户名和单位电<br>话为62985600，并提示该用户的GECOS信息修改成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line;<span class="keyword">do</span></span><br><span class="line">  null=`<span class="built_in">echo</span> <span class="variable">$line</span>|cut -d: -f5`</span><br><span class="line">  user=`<span class="built_in">echo</span> <span class="variable">$line</span>|cut -d: -f1`</span><br><span class="line">  <span class="keyword">if</span>[ -z <span class="variable">$user</span> ];<span class="keyword">then</span></span><br><span class="line">    chfn -f <span class="variable">$user</span> <span class="variable">$null</span></span><br><span class="line">    chfn -p 12800138000 <span class="variable">$user</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span>&lt;/etc/passwd</span><br></pre></td></tr></table></figure></li><li><p>判断登陆失败次数大于5次的禁止登陆</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">WARNING=5</span><br><span class="line">lastb |sed -rn <span class="string">'s/.* (([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;) .*/\1/p'</span> |sort|uniq -c &gt; iplist.txt</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line ;<span class="keyword">do</span></span><br><span class="line">        TIME=`<span class="built_in">echo</span> <span class="string">"<span class="variable">$line</span>"</span> | sed -nr <span class="string">'s/([0-9]+) +(.*)/\1/p'</span>`</span><br><span class="line">        IP=`<span class="built_in">echo</span> <span class="string">"<span class="variable">$line</span>"</span> | sed -nr <span class="string">'s/([0-9]+) +(.*)/\2/p'</span>`</span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$TIME</span> -gt <span class="variable">$WARNING</span> ];<span class="keyword">then</span></span><br><span class="line">                [[ <span class="variable">$IP</span> =~ ^192.168.32 ]] &amp;&amp; <span class="built_in">continue</span></span><br><span class="line">                grep -q <span class="string">"<span class="variable">$IP</span>"</span> /etc/hosts.deny ||  <span class="built_in">echo</span> <span class="string">"sshd:<span class="variable">$IP</span>"</span> &gt;&gt; /etc/hosts.deny</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span> &lt; iplist.txt</span><br></pre></td></tr></table></figure></li><li><p>判断连接次数大于5次的 加入到防火墙里</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ss -nt &gt; access.txt</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line;</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">ipCount=<span class="built_in">echo</span> <span class="variable">$line</span>| ss -nt|tr -s <span class="string">" "</span>|cut -d<span class="string">" "</span> -f5|grep -o <span class="string">"^[0-9.]*"</span>|uniq -c</span><br><span class="line"></span><br><span class="line">count=<span class="built_in">echo</span> <span class="string">"<span class="variable">$ipCount</span>"</span>|tr -d<span class="string">" "</span> -f1</span><br><span class="line">ip=<span class="built_in">echo</span> <span class="string">"<span class="variable">$ipCount</span>"</span>|tr -d<span class="string">" "</span> -f2</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$count</span> -gt 5 ];<span class="keyword">then</span> </span><br><span class="line">  iptables -A INPUT -s <span class="variable">$ip</span> -j REJECT; </span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span> &lt; access.txt</span><br></pre></td></tr></table></figure></li></ol><h1 id="until"><a href="#until" class="headerlink" title="until"></a>until</h1><h2 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">until CONDITION; <span class="keyword">do</span></span><br><span class="line"> 循环体</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>进入条件： CONDITION 为false<br>退出条件： CONDITION 为true</p><h2 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">until [ -z <span class="string">"<span class="variable">$1</span>"</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line"> <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span></span><br></pre></td></tr></table></figure><ol><li>计算ip地址跟mask的与<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ip=<span class="built_in">read</span> -p <span class="string">"请输入ip地址"</span> ip</span><br><span class="line">netmask=<span class="built_in">read</span> -p <span class="string">"请输入ip地址"</span> netmask</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..4&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  ip=<span class="built_in">echo</span> <span class="variable">$ip</span>|cut -d. -f<span class="variable">$i</span></span><br><span class="line">  netmaskp=<span class="built_in">echo</span> <span class="variable">$netmask</span>|cut -d. -f<span class="variable">$i</span></span><br><span class="line">  <span class="keyword">if</span> [<span class="variable">$i</span> -eq 1];<span class="keyword">then</span></span><br><span class="line">    netid=$[ip&amp;netmask]</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    netid=<span class="variable">$netid</span>.[ip&amp;netmask]</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$netid</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><h2 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select variable <span class="keyword">in</span> list</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">循环体命令</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="练习-4"><a href="#练习-4" class="headerlink" title="练习"></a>练习</h2><ol><li>打印菜单<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  PS3=<span class="string">"pLease choose a digit: "</span></span><br><span class="line">select MENU <span class="keyword">in</span> jiaozi lamian  mifan daoxiaomain quit;<span class="keyword">do</span> </span><br><span class="line">        <span class="keyword">case</span> <span class="variable">$MENU</span> <span class="keyword">in</span></span><br><span class="line">        jiaozi)</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"Your choose is <span class="variable">$REPLY</span>"</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="variable">$MENU</span> price is 20</span><br><span class="line">                ;;</span><br><span class="line">        lamian)</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"Your choose is <span class="variable">$REPLY</span>"</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="variable">$MENU</span> price is 15</span><br><span class="line">                ;;</span><br><span class="line">        mifan)</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"Your choose is <span class="variable">$REPLY</span>"</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="variable">$MENU</span> price is 18</span><br><span class="line">                ;;</span><br><span class="line">        daoxiaomain)</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"Your choose is <span class="variable">$REPLY</span>"</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="variable">$MENU</span> price is 12</span><br><span class="line">                ;;</span><br><span class="line">        quit)</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"Your choose is <span class="variable">$REPLY</span>"</span></span><br><span class="line">                <span class="built_in">break</span>;;</span><br><span class="line">        *)</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"Your choose is <span class="variable">$REPLY</span>"</span></span><br><span class="line">                <span class="built_in">echo</span> choose again</span><br><span class="line">                ;;</span><br><span class="line">        <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h1><h2 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h2><p>用于将参量列表 list 左移指定次数，缺省为左移一次<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shift</span>[n]</span><br></pre></td></tr></table></figure></p><h2 id="练习-5"><a href="#练习-5" class="headerlink" title="练习"></a>练习</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ <span class="variable">$#</span> -gt 0 ] <span class="comment"># or (( $# &gt; 0 ))</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"> <span class="built_in">echo</span> $*</span><br><span class="line"> <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>输出结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 data]<span class="comment"># bash doit.sh 1 2 4 5</span></span><br><span class="line">1 2 4 5</span><br><span class="line">2 4 5</span><br><span class="line">4 5</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p><h1 id="生成随机数"><a href="#生成随机数" class="headerlink" title="生成随机数"></a>生成随机数</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl rand -base64 12 </span><br><span class="line">tr -dc <span class="string">'0-9a-zA-Z'</span> &lt;/dev/urandom |head -c8</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> f_name （） &#123;</span><br><span class="line">...函数体...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim function.sh</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func1</span></span>()&#123;<span class="built_in">echo</span> <span class="built_in">test</span> <span class="keyword">function</span>; &#125;</span><br></pre></td></tr></table></figure></p><p><strong>调用</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">. <span class="keyword">function</span> 导入</span><br><span class="line">func1   调用</span><br></pre></td></tr></table></figure></p><p><strong>查看</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -f func1</span><br></pre></td></tr></table></figure></p><p><strong>删除</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> func1</span><br></pre></td></tr></table></figure></p><p><strong>传给子进程使用</strong><br>declare -xf function(函数名)<br>local 本地变量，只在当前函数内有效</p><h2 id="练习-6"><a href="#练习-6" class="headerlink" title="练习"></a>练习</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">findit()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> [ <span class="variable">$#</span> -lt 1 ] ; <span class="keyword">then</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">"Usage:findit file"</span></span><br><span class="line"> <span class="built_in">return</span> 1</span><br><span class="line"> <span class="keyword">fi</span></span><br><span class="line"> find / -name <span class="variable">$1</span> –<span class="built_in">print</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">declare -a array_name 普通数字</span><br><span class="line">declare -A array_name 关联数组</span><br></pre></td></tr></table></figure><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array_name=(&quot;1&quot; &quot;2&quot; &quot;3&quot;) 一次性赋值</span><br><span class="line">array_name=([0]=&quot;1&quot; &quot;2&quot; &quot;3&quot;) 稀疏格式</span><br></pre></td></tr></table></figure><p>按下标赋值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">declare -a title </span><br><span class="line">title[0]=&quot;ceo&quot;</span><br><span class="line">title[1]=&quot;coo&quot;</span><br><span class="line">title[2]=&quot;cto&quot;</span><br><span class="line">列表赋值</span><br><span class="line">digit=(&#123;1..10&#125;)</span><br><span class="line">echo $&#123;digit[*]&#125;</span><br></pre></td></tr></table></figure></p><h2 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h2><p>列出元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;title[0]&#125;  显示下标为0的元素</span><br><span class="line">echo $&#123;title[*/@]&#125; 全部显示</span><br><span class="line">列出数组元素个数</span><br><span class="line">echo $&#123;#title[*]&#125;</span><br></pre></td></tr></table></figure></p><h2 id="交互式"><a href="#交互式" class="headerlink" title="交互式"></a>交互式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read -a array</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">删除第1个元素</span><br><span class="line">unset  digit[1]</span><br><span class="line">删除所有元素</span><br><span class="line">unset  digit</span><br></pre></td></tr></table></figure><h2 id="数组切片"><a href="#数组切片" class="headerlink" title="数组切片"></a>数组切片</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123;ARRAY[@]:offset:number&#125;</span><br><span class="line">offset: 要跳过的元素个数</span><br><span class="line">number: 要取出的元素个数</span><br></pre></td></tr></table></figure><h2 id="追加数组"><a href="#追加数组" class="headerlink" title="追加数组"></a>追加数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## 关联数组</span><br></pre></td></tr></table></figure><p>declare -A ARRAY_NAME<br>ARRAY_NAME=([idx_name1]=’val1’ [idx_name2]=’val2‘…)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 练习</span><br><span class="line">1. 取出磁盘利用率，大于5%报警</span><br><span class="line">```bash</span><br><span class="line">df |grep &apos;^/dev/sd&apos; &gt; df.log</span><br><span class="line">declare -A used</span><br><span class="line">while read line;do</span><br><span class="line">  index=`echo $line|cut -d&quot; &quot; -f1`</span><br><span class="line">  used[$index]=`echo $line| sed -rn &apos;s/.* ([0-9]+)%.*/\1/p&apos;`</span><br><span class="line">  if [ $&#123;used[&quot;$index&quot;]&#125; -gt 5 ];then</span><br><span class="line">      echo $index will be full,used:$&#123;used[&quot;$index&quot;]&#125;</span><br><span class="line">  fi</span><br><span class="line">done&lt; df.log</span><br><span class="line">echo $&#123;used[*]&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>生成10个随机数，取出最大值跟最小值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -a rand </span><br><span class="line"><span class="keyword">for</span> ((i=0;i&lt;10;i++));<span class="keyword">do</span></span><br><span class="line">  rand[<span class="variable">$i</span>]=<span class="variable">$RANDOM</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="variable">$i</span> -eq 0 ];<span class="keyword">then</span> </span><br><span class="line">      max=<span class="variable">$&#123;rand[$i]&#125;</span></span><br><span class="line">      min=<span class="variable">$&#123;rand[$i]&#125;</span></span><br><span class="line">      <span class="built_in">continue</span></span><br><span class="line">   <span class="keyword">fi</span></span><br><span class="line">   <span class="keyword">if</span> [  <span class="string">"<span class="variable">$max</span>"</span> -lt <span class="string">"<span class="variable">$&#123;rand[$i]&#125;</span>"</span> ];<span class="keyword">then</span></span><br><span class="line">        max=rand[<span class="variable">$i</span>]</span><br><span class="line">    <span class="keyword">elif</span> [  <span class="string">"<span class="variable">$min</span>"</span> -gt <span class="string">"<span class="variable">$&#123;rand[$i]&#125;</span>"</span> ];<span class="keyword">then</span></span><br><span class="line">        min=rand[<span class="variable">$i</span>]</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        <span class="literal">true</span>      </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> max=<span class="variable">$max</span></span><br><span class="line"><span class="built_in">echo</span> min=<span class="variable">$min</span></span><br><span class="line"><span class="built_in">echo</span> all random:<span class="variable">$&#123;rand[*]&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>编写脚本，定义一个数组，数组中的元素是/var/log目录下所有以.log结尾的文件；<br>统计出其下标为偶数的文件中的行数之和</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">declare</span> -a files</span><br><span class="line">files=(/var/<span class="built_in">log</span>/*.<span class="built_in">log</span>)</span><br><span class="line"><span class="built_in">declare</span> -i lines=0</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 0 $[<span class="variable">$&#123;#files[*]&#125;</span>-1]); <span class="keyword">do</span></span><br><span class="line"> <span class="keyword">if</span> [ $[<span class="variable">$i</span>%2] -eq 0 ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">let</span> lines+=$(wc -l <span class="variable">$&#123;files[$i]&#125;</span> | cut -d<span class="string">' '</span> -f1)</span><br><span class="line"> <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Lines: <span class="variable">$lines</span>."</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h1><p><strong>字符串切片</strong></p><ol><li><p>返回字符串变量var的长度</p><figure class="highlight plain"><figcaption><span>```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2. 返回字符串变量var中从第offset个字符后（不包括第offset个字符）的字</span><br><span class="line">符开始，到最后的部分，offset的取值在0 到 $&#123;#var&#125;-1 之间</span><br><span class="line">  ```$&#123;var:offset&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回字符串变量var中从第offset个字符后（不包括第offset个<br>字符）的字符开始，长度为number的部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4. 取字符串的最右侧几个字符</span><br><span class="line"> ```$&#123;var: -length&#125;</span><br></pre></td></tr></table></figure></li></ol><p>注意：冒号后必须有一空白字符</p><ol start="5"><li>从最左侧跳过offset字符，一直向右取到距离最右侧lengh个字<br>符之前的内容<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6. 先从最右侧向左取到length个字符开始，再向右取到距离最</span><br><span class="line">右侧offset个字符之间的内容</span><br><span class="line">```$&#123;var: -length:-offset&#125;</span><br></pre></td></tr></table></figure></li></ol><p>注意：-length前空格<br><strong>基于模式取子串</strong></p><ol><li><p>${var#*word}：其中word可以是指定的任意字符<br>功能：自左而右，查找var变量所存储的字符串中，第一次出现的word, 删<br>除字符串开头至第一次出现word字符之间的所有字符</p></li><li><p>${var##<em>word}：同上，贪婪模式，不同的是，删除的是字符串开头至最后<br>一次由word指定的字符之间的所有内容<br>file=“var/log/messages”<br>${file#</em>/}: log/messages<br>${file##*/}: messages</p></li></ol><p><strong>字符串处理</strong></p><ol><li><p>${var%word<em>}：其中word可以是指定的任意字符<br>功能：自右而左，查找var变量所存储的字符串中，第一次出现的word, 删<br>除字符串最后一个字符向左至第一次出现word字符之间的所有字符<br>file=”/var/log/messages”<br>${file%/</em>}: /var/log</p></li><li><p>${var%%word<em>}：同上，只不过删除字符串最右侧的字符向左至最后一次出现<br>word字符之间的所有字符；<br>url=<a href="http://192.168.0.1:80" target="_blank" rel="noopener">http://192.168.0.1:80</a><br>${url##</em>:} 80<br>${url%%:*} http</p></li></ol><p><strong>查找替换</strong></p><ol><li>${var/pattern/substr}：查找var所表示的字符串中，第一次被pattern所匹<br>配到的字符串，以substr替换之</li><li>${var//pattern/substr}: 查找var所表示的字符串中，所有能被pattern所匹<br>配到的字符串，以substr替换之</li><li>${var/#pattern/substr}：查找var所表示的字符串中，行首被pattern所匹<br>配到的字符串，以substr替换之</li><li>${var/%pattern/substr}：查找var所表示的字符串中，行尾被pattern所匹<br>配到的字符串，以substr替换之<br><strong>查找删除</strong></li><li>${var/pattern}：删除var表示的字符串中第一次被pattern匹配到的字符串</li><li>${var//pattern}：删除var表示的字符串中所有被pattern匹配到的字符串</li><li>${var/#pattern}：删除var表示的字符串中所有以pattern为行首匹配到的<br>字符串</li><li>${var/%pattern}：删除var所表示的字符串中所有以pattern为行尾所匹配<br>到的字符串<br><strong>字符大小写转换</strong></li><li>${var^^}：把var中的所有小写字母转换为大写</li><li>${var,,}：把var中的所有大写字母转换为小写</li></ol><h1 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h1><p>eval命令将会首先扫描命令行进行所有的置换，然后再执行该命令。该命令适用于<br>那些一次扫描无法实现其功能的变量.该命令对变量进行两次扫描<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># n=10             </span></span><br><span class="line">[root@centos6 ~]<span class="comment"># echo &#123;0..$n&#125;     </span></span><br><span class="line">&#123;0..10&#125;</span><br><span class="line">[root@centos6 ~]<span class="comment"># eval echo &#123;0..$n&#125; </span></span><br><span class="line">0 1 2 3 4 5 6 7 8 9 10</span><br></pre></td></tr></table></figure></p><p><strong>间接变量引用</strong><br>如果第一个变量的值是第二个变量的名字，从第一个变量引用第二个变量的值<br>就称为间接变量引用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># N=NAME</span></span><br><span class="line">[root@centos6 ~]<span class="comment"># NAME=FENGXINHUA</span></span><br><span class="line">[root@centos6 ~]<span class="comment"># N1=$&#123;!N&#125;</span></span><br><span class="line">[root@centos6 ~]<span class="comment"># echo $N1</span></span><br><span class="line">FENGXINHUA</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment">#  eval N2=\$$N</span></span><br><span class="line">[root@centos6 ~]<span class="comment"># echo $N2</span></span><br><span class="line">FENGXINHUA</span><br></pre></td></tr></table></figure></p><h1 id="mktemp"><a href="#mktemp" class="headerlink" title="mktemp"></a>mktemp</h1><p>mktemp命令：创建并显示临时文件，可避免冲突<br>mktemp [OPTION]… [TEMPLATE]<br>TEMPLATE: filenameXXX<br>X至少要出现三个<br>OPTION：<br>-d: 创建临时目录<br>-p DIR或–tmpdir=DIR：指明临时文件所存放目录位置<br>mktemp /tmp/testXXX<br>tmpdir=<code>mktemp –d /tmp/testdirXXX</code><br>mktemp –tmpdir=/testdir testXXXXXX</p><h2 id="练习-7"><a href="#练习-7" class="headerlink" title="练习"></a>练习</h2><ol><li>创建临时文件夹，执行rm操作的时候默认把文件移动到临时文件夹中<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line">cmd=<span class="variable">$1</span></span><br><span class="line">temp=$(mktemp -d /data/dir`date +%F`XXXXX)</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$#</span> -ne 0 ];<span class="keyword">do</span></span><br><span class="line">    mv <span class="variable">$1</span> <span class="variable">$temp</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="install"><a href="#install" class="headerlink" title="install"></a>install</h1><p>install命令的作用是安装或升级软件或备份数据，它的使用权限是所有用户。install命令和cp命令类似，都可以将文件/目录拷贝到指定的地点。但是，install允许你控制目标文件的属性。install通常用于程序的makefile，使用它来将程序拷贝到目标（安装）目录。</p><h2 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h2><p>install [OPTION]… [-T] SOURCE DEST<br>install [OPTION]… SOURCE… DIRECTORY<br>install [OPTION]… -t DIRECTORY SOURCE…<br>install [OPTION]… -d DIRECTORY…<br>在前两种格式中，会将&lt;来源&gt;复制至&lt;目的地&gt;或将多个&lt;来源&gt;文件复制至已存在的&lt;目录&gt;，同时设定权限模式及所有者/所属组。在第三种格式中，会创建所有指定的目录及它们的主目录。长选项必须用的参数在使用短选项时也是必须的。</p><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p>–backup[=CONTROL]：为每个已存在的目的地文件进行备份。<br>-b：类似 –backup，但不接受任何参数。<br>-c：(此选项不作处理)。<br>-d，–directory：所有参数都作为目录处理，而且会创建指定目录的所有主目录。<br>-D：创建&lt;目的地&gt;前的所有主目录，然后将&lt;来源&gt;复制至 &lt;目的地&gt;；在第一种使用格式中有用。<br>-g，–group=组：自行设定所属组，而不是进程目前的所属组。<br>-m，–mode=模式：自行设定权限模式 (像chmod)，而不是rwxr-xr-x。<br>-o，–owner=所有者：自行设定所有者 (只适用于超级用户)。<br>-p，–preserve-timestamps：以&lt;来源&gt;文件的访问/修改时间作为相应的目的地文件的时间属性。<br>-s，–strip：用strip命令删除symbol table，只适用于第一及第二种使用格式。<br>-S，–suffix=后缀：自行指定备份文件的&lt;后缀&gt;。<br>-v，–verbose：处理每个文件/目录时印出名称。<br>–help：显示此帮助信息并离开。<br>–version：显示版本信息并离开。</p><h2 id="练习-8"><a href="#练习-8" class="headerlink" title="练习"></a>练习</h2><ol><li>复制SOURCE文件（测试不能是目录）到DEST file（文件）：<br>install a/e c<br>结果类似：<br>cp a/e c    #注意c必须是文件。</li><li>选项-D<br>install -D x a/b/c<br>效果类似：<br>mkdir -p a/b &amp;&amp; cp x a/b/c</li><li>复制多个SOURCE文件到目的目录：d是目录<br>install a/* d</li><li>复制文件并且指定权限<br>install -m 700 -o wang -g admins srcfile desfile</li><li>创建/testdir/installdir 空目录，并且指定权限<br>install -m 770 -d /testdir/installdir <h1 id="expect"><a href="#expect" class="headerlink" title="expect"></a>expect</h1>expect 是由Don Libes基于Tcl（ Tool Command Language ）语言开发的，<br>主要应用于自动化交互式操作的场景，借助Expect处理交互的命令，可以将交互<br>过程如：ssh登录，ftp登录等写在一个脚本上，使之自动化完成。尤其适用于需<br>要对多台服务器执行相同操作的环境中，可以大大提高系统管理人员的工作效率<h2 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h2>expect [选项] [ -c cmds ] [ [ -[f|b] ] cmdfile ] [ args ]<h2 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h2>-c：从命令行执行expect脚本，默认expect是交互地执行的<br>-d：可以输出输出调试信息<br>spawn：启动新的进程<br>send：用于向进程发送字符串<br>expect：从进程接收字符串<br>interact：允许用户交互<br>exp_continue 匹配多个字符串在执行动作后加此命令<h2 id="练习-9"><a href="#练习-9" class="headerlink" title="练习"></a>练习</h2></li><li>ssh key 实现</li><li>匹配hi,hello,bye任意字符串时，执行相应输出。等同如下<br>expect {<br>“hi” { send “You said hi\n”}<br>“hehe” { send “Hehe yourself\n”}<br>“bye” { send “Good bye\n”}<br>}</li><li><p>远程登陆主机 不需要询问我们每次都输入用户名 密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/expect</span></span><br><span class="line">spawn ssh 192.168.8.100</span><br><span class="line">expect &#123;</span><br><span class="line"> <span class="string">"yes/no"</span> &#123; send <span class="string">"yes\n"</span>;exp_continue &#125;</span><br><span class="line"> <span class="string">"password"</span> &#123; send “magedu\n<span class="string">" &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">interact</span></span><br><span class="line"><span class="string">#expect eof</span></span><br></pre></td></tr></table></figure></li><li><p>位置参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/expect</span></span><br><span class="line"><span class="built_in">set</span> ip [lindex <span class="variable">$argv</span> 0]</span><br><span class="line"><span class="built_in">set</span> user [lindex <span class="variable">$argv</span> 1]</span><br><span class="line"><span class="built_in">set</span> password [lindex <span class="variable">$argv</span> 2]</span><br><span class="line">spawn ssh <span class="variable">$user</span>@<span class="variable">$ip</span></span><br><span class="line">expect &#123;</span><br><span class="line"> <span class="string">"yes/no"</span> &#123; send <span class="string">"yes\n"</span>;exp_continue &#125;</span><br><span class="line"> <span class="string">"password"</span> &#123; send <span class="string">"<span class="variable">$password</span>\n"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">interact</span><br><span class="line"><span class="comment">#./ssh3.exp 192.168.8.100 root magedu</span></span><br></pre></td></tr></table></figure></li><li><p>执行多个命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/expect</span></span><br><span class="line"><span class="built_in">set</span> ip [lindex <span class="variable">$argv</span> 0]</span><br><span class="line"><span class="built_in">set</span> user [lindex <span class="variable">$argv</span> 1]</span><br><span class="line"><span class="built_in">set</span> password [lindex <span class="variable">$argv</span> 2]</span><br><span class="line"><span class="built_in">set</span> timeout 10</span><br><span class="line">spawn ssh <span class="variable">$user</span>@<span class="variable">$ip</span></span><br><span class="line">expect &#123;</span><br><span class="line"> <span class="string">"yes/no"</span> &#123; send <span class="string">"yes\n"</span>;exp_continue &#125;</span><br><span class="line"> <span class="string">"password"</span> &#123; send <span class="string">"<span class="variable">$password</span>\n"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">expect <span class="string">"]#"</span> &#123; send <span class="string">"useradd haha\n"</span> &#125;</span><br><span class="line">expect <span class="string">"]#"</span> &#123; send <span class="string">"echo magedu |passwd --stdin haha\n"</span> &#125;</span><br><span class="line">send <span class="string">"exit\n"</span></span><br><span class="line">expect eof</span><br><span class="line"><span class="comment">#./ssh4.exp 192.168.8.100 root magedu</span></span><br></pre></td></tr></table></figure></li><li><p>shell脚本调用expect</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">ip=<span class="variable">$1</span></span><br><span class="line">user=<span class="variable">$2</span></span><br><span class="line">password=<span class="variable">$3</span></span><br><span class="line">expect &lt;&lt;EOF</span><br><span class="line"><span class="built_in">set</span> timeout 10</span><br><span class="line">spawn ssh <span class="variable">$user</span>@<span class="variable">$ip</span></span><br><span class="line">expect &#123;</span><br><span class="line"> <span class="string">"yes/no"</span> &#123; send <span class="string">"yes\n"</span>;exp_continue &#125;</span><br><span class="line"> <span class="string">"password"</span> &#123; send <span class="string">"<span class="variable">$password</span>\n"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">expect <span class="string">"]#"</span> &#123; send <span class="string">"useradd hehe\n"</span> &#125;</span><br><span class="line">expect <span class="string">"]#"</span> &#123; send <span class="string">"echo magedu |passwd --stdin hehe\n"</span> &#125;</span><br><span class="line">expect <span class="string">"]#"</span> &#123; send <span class="string">"exit\n"</span> &#125;</span><br><span class="line">expect eof</span><br><span class="line">EOF</span><br><span class="line"><span class="comment">#./ssh5.sh 192.168.8.100 root magedu</span></span><br></pre></td></tr></table></figure></li><li><p>变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/expect</span></span><br><span class="line"><span class="built_in">set</span> ip 192.168.8.100</span><br><span class="line"><span class="built_in">set</span> user root</span><br><span class="line"><span class="built_in">set</span> password magedu</span><br><span class="line"><span class="built_in">set</span> timeout 10</span><br><span class="line">spawn ssh <span class="variable">$user</span>@<span class="variable">$ip</span></span><br><span class="line">expect &#123;</span><br><span class="line"> <span class="string">"yes/no"</span> &#123; send <span class="string">"yes\n"</span>;exp_continue &#125;</span><br><span class="line"> <span class="string">"password"</span> &#123; send <span class="string">"<span class="variable">$password</span>\n"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure></li></ol><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><ol><li>编写脚本/root/bin/createuser.sh，实现如下功能：使用一个用户名做为参<br>数，如果指定参数的用户存在，就显示其存在，否则添加之；显示添加的用户<br>的id号等信息</li><li>编写脚本/root/bin/yesorno.sh，提示用户输入yes或no,并判断用户输入的<br>是yes还是no,或是其它信息</li><li>编写脚本/root/bin/filetype.sh,判断用户输入文件路径，显示其文件类型<br>（普通，目录，链接，其它文件类型）</li><li>编写脚本/root/bin/checkint.sh,判断用户输入的参数是否为正整数</li><li>判断/var/目录下所有文件的类型</li><li>添加10个用户user1-user10，密码为8位随机字符</li><li>/etc/rc.d/rc3.d目录下分别有多个以K开头和以S开头的文件；分别读取每个文件，<br>以K开头的输出为文件加stop，以S开头的输出为文件名加start，如K34filename stop<br>S66filename start</li><li>编写脚本，提示输入正整数n的值，计算1+2+…+n的总和</li><li>计算100以内所有能被3整除的整数之和</li><li>编写脚本，提示请输入网络地址，如192.168.0.0，判断输入的网段中主机在线状态</li><li>打印九九乘法表</li><li>在/testdir目录下创建10个html文件,文件名格式为数字N（从1到10）加随机8个字<br>母，如：1AbCdeFgH.html</li><li>打印等腰三角形</li><li>编写脚本，求100以内所有正奇数之和</li><li>编写脚本，提示请输入网络地址，如192.168.0.0，判断输入的网段中主机<br>在线状态，并统计在线和离线主机各多少</li><li>编写脚本，打印九九乘法表</li><li>编写脚本，利用变量RANDOM生成10个随机数字，输出这个10数字，并显<br>示其中的最大值和最小值</li><li>编写脚本，实现打印国际象棋棋盘</li><li>后续六个字符串：efbaf275cd、4be9c40b8b、44b2395c46、<br>f8c8873ce0、b902c16c8b、ad865d2f63是通过对随机数变量RANDOM随机<br>执行命令： echo $RANDOM|md5sum|cut –c1-10 后的结果，请破解这些<br>字符串对应的RANDOM值</li><li>每隔3秒钟到系统上获取已经登录的用户的信息；如果发现用户hacker登录，<br>则将登录时间和主机记录于日志/var/log/login.log中,并退出脚本</li><li>随机生成10以内的数字，实现猜字游戏，提示比较大或小，相等则退出</li><li>用文件名做为参数，统计所有参数文件的总行数</li><li>用二个以上的数字为参数，显示其中的最大值和最小值</li><li><p>编写服务脚本/root/bin/testsrv.sh，完成如下要求<br>(1) 脚本可接受参数：start, stop, restart, status<br>(2) 如果参数非此四者之一，提示使用格式后报错退出<br>(3) 如是start:则创建/var/lock/subsys/SCRIPT_NAME, 并显示“启动成功”<br>考虑：如果事先已经启动过一次，该如何处理？<br>(4) 如是stop:则删除/var/lock/subsys/SCRIPT_NAME, 并显示“停止完成”<br>考虑：如果事先已然停止过了，该如何处理？<br>(5) 如是restart，则先stop, 再start<br>考虑：如果本来没有start，如何处理？<br>(6) 如是status, 则如果/var/lock/subsys/SCRIPT_NAME文件存在，则显示“SCRIPT_NAME is<br>running…”<br>如果/var/lock/subsys/SCRIPT_NAME文件不存在，则显示“SCRIPT_NAME is stopped…”<br>其中：SCRIPT_NAME为当前脚本名<br>(7)在所有模式下禁止启动该服务，可用chkconfig 和 service命令管理</p></li><li><p>编写脚本/root/bin/copycmd.sh<br>(1) 提示用户输入一个可执行命令名称<br>(2) 获取此命令所依赖到的所有库文件列表<br>(3) 复制命令至某目标目录(例如/mnt/sysroot)下的对应路径下<br>如：/bin/bash ==&gt; /mnt/sysroot/bin/bash<br>/usr/bin/passwd ==&gt; /mnt/sysroot/usr/bin/passwd<br>(4) 复制此命令依赖到的所有库文件至目标目录下的对应路径下： 如：/lib64/ldlinux-x86-64.so.2<br>==&gt; /mnt/sysroot/lib64/ld-linux-x86-64.so.2<br>(5)每次复制完成一个命令后，不要退出，而是提示用户键入新的要复制的命令，<br>并重复完成上述功能；直到用户输入quit退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">copyCmd</span></span>()&#123;</span><br><span class="line">  cpCmd=`<span class="built_in">which</span> <span class="variable">$cmd</span>`</span><br><span class="line">  cp <span class="variable">$cpCmd</span> /mnt/sysroot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">copyResult</span></span>()&#123;</span><br><span class="line"> <span class="built_in">echo</span> <span class="variable">$cmd</span></span><br><span class="line">  <span class="keyword">for</span> libfile <span class="keyword">in</span> $( ldd $(<span class="built_in">which</span> <span class="string">"<span class="variable">$cmd</span>"</span> | grep -v <span class="string">"alias"</span> ) | grep -o <span class="string">"/lib[^[:space:]]*"</span>);</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">      cp <span class="variable">$libfile</span> /mnt/sysroot/</span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> <span class="built_in">read</span> -p <span class="string">"请输入一个可执行的命令："</span> cmd;<span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">"<span class="variable">$cmd</span>"</span> = <span class="string">"quit"</span> ];<span class="keyword">then</span></span><br><span class="line">   <span class="built_in">break</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">which</span> <span class="variable">$cmd</span> &amp;&gt; /dev/null</span><br><span class="line">  <span class="keyword">if</span> [ $? -ne 0 ];<span class="keyword">then</span></span><br><span class="line">   <span class="built_in">continue</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> [ ! -d <span class="string">"/mnt/sysroot/"</span> ];<span class="keyword">then</span></span><br><span class="line">    mkdir -p /mnt/sysroot/</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">   copyCmd --复制命令</span><br><span class="line">   copyResult --复制依赖库文件</span><br><span class="line"> <span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p>编写函数实现两个数字做为参数，返回最大值</p></li><li>斐波那契数列又称黄金分割数列，因数学家列昂纳多·斐波那契以兔子繁殖为例<br>子而引入，故又称为“兔子数列”，指的是这样一个数列：0、1、1、2、3、5、<br>8、13、21、34、……，斐波纳契数列以如下被以递归的方法定义：F（0）=0，<br>F（1）=1，F（n）=F(n-1)+F(n-2)（n≥2）利用函数，求n阶斐波那契数列</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SHELL进阶 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux定时任务</title>
      <link href="/2018/08/29/linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2018/08/29/linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前后台任务，定时任务<br>crontab命令被用来提交和管理用户的需要周期性执行的任务，与windows下的计划任务类似，当安装完成操作系统后，默认会安装此服务工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。</p></blockquote><a id="more"></a><h1 id="jobs"><a href="#jobs" class="headerlink" title="jobs"></a>jobs</h1><p>jobs命令用于显示Linux中的任务列表及任务状态，包括后台运行的任务。该命令可以显示任务号及其对应的进程号。其中，任务号是以普通用户的角度进行的，而进程号则是从系统管理员的角度来看的。一个任务可以对应于一个或者多个进程号。</p><p>在Linux系统中执行某些操作时候，有时需要将当前任务暂停调至后台，或有时须将后台暂停的任务重启开启并调至前台，这一序列的操作将会使用到 jobs、bg、和 fg 三个命令以及两个快捷键来完成。</p><p><strong>选项</strong><br>-l：显示进程号；<br>-p：仅任务对应的显示进程号；<br>-n：显示任务状态的变化；<br>-r：仅输出运行状态（running）的任务；<br>-s：仅输出停止状态（stoped）的任务。</p><p><strong>使用jobs命令显示当前系统的任务列表，输入如下命令：</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">jobs</span> -l</span><br><span class="line">[root@centos6 ~]<span class="comment"># jobs -l</span></span><br><span class="line">[1]-  3520 Stopped (tty output)    nice -n -5 vi</span><br><span class="line">[2]+  3524 Stopped (tty output)    nice -n -5 vim</span><br><span class="line">[3]   5021 Done                    find / -name passwd</span><br></pre></td></tr></table></figure></p><p>注意必须在执行jobs命令之前执行命令find / -name password &amp;，要不jobs 看不到信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name password &amp;</span><br></pre></td></tr></table></figure><h2 id="fg"><a href="#fg" class="headerlink" title="fg"></a>fg</h2><p>fg命令用于将后台作业（在后台运行的或者在后台挂起的作业）放到前台终端运行。与bg命令一样，若后台任务中只有一个，则使用该命令时，可以省略任务号。</p><p><strong>使用fg命令将任务号为1的任务从后台执行转换到前台执行，输入如下命令：</strong><br>fg 1  1代表任务号 </p><h2 id="bg"><a href="#bg" class="headerlink" title="bg"></a>bg</h2><p>bg命令用于将作业放到后台运行，使前台可以执行其他任务。该命令的运行效果与在指令后面添加符号&amp;的效果是相同的，都是将其放到系统后台执行。<br><strong>使用bg命令将任务号为1的任务放到后台继续执行，输入如下命令：</strong><br>bg 1  1代表任务号 </p><p>实际上bg 命令跟指令后边加&amp; 效果是一样的。</p><h2 id="删除后台进程"><a href="#删除后台进程" class="headerlink" title="删除后台进程"></a>删除后台进程</h2><p>kill %任务编号</p><h1 id="任务计划"><a href="#任务计划" class="headerlink" title="任务计划"></a>任务计划</h1><h2 id="at"><a href="#at" class="headerlink" title="at"></a>at</h2><p>at命令用于在指定时间执行命令。at允许使用一套相当复杂的指定时间的方法。它能够接受在当天的hh:mm（小时:分钟）式的时间指定。假如该时间已过去，那么就放在第二天执行。当然也能够使用midnight（深夜），noon（中午），teatime（饮茶时间，一般是下午4点）等比较模糊的 词语来指定时间。用户还能够采用12小时计时制，即在时间后面加上AM（上午）或PM（下午）来说明是上午还是下午。 也能够指定命令执行的具体日期，指定格式为month day（月 日）或mm/dd/yy（月/日/年）或dd.mm.yy（日.月.年）。指定的日期必须跟在指定时间的后面。</p><p>上面介绍的都是绝对计时法，其实还能够使用相对计时法，这对于安排不久就要执行的命令是很有好处的。指定格式为：now + count time-units，now就是当前时间，time-units是时间单位，这里能够是minutes（分钟）、hours（小时）、days（天）、weeks（星期）。count是时间的数量，究竟是几天，还是几小时，等等。 更有一种计时方法就是直接使用today（今天）、tomorrow（明天）来指定完成命令的时间。<br><strong>选项</strong><br>-f：指定包含具体指令的任务文件；<br>-q：指定新任务的队列名称；<br>-l：显示待执行任务的列表；<br>-d：删除指定的待执行任务；<br>-m：任务执行完成后向用户发送E-mail。</p><p>查看是否开始的时候atd 服务启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --list atd</span><br></pre></td></tr></table></figure></p><p>runlevel 看运行模式<br>chkconfig atd on  可以设置是开机自动运行</p><p><strong>开机自动启动</strong><br>chkconfig atd on<br>systemctl enable atd</p><p><strong>查看是否开机自动启动</strong><br>chkconfig –list atd<br>systemctl is-enabled atd</p><p><strong>是否当前是启动状态</strong><br>service atd status<br>systemctl status atd</p><p><strong>启动当前服务</strong><br>service atd start<br>systemctl start atd </p><p><strong>关闭防火墙</strong><br>centos7<br>chkconfig iptables off<br>systemctl disable firewalld  </p><p>centos6<br>servcie iptables stop<br>chkconfig iptables off </p><p>vim /etc/sysconfig/selinux<br>SELINUX=disabled</p><p><strong>三天后的下午5点执行/bin/ls：</strong><br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># at 5pm+3 days</span></span><br><span class="line">at&gt; ls -l</span><br><span class="line">at&gt; &lt;EOT&gt;</span><br><span class="line">job 2 at 2018-09-04 17:00</span><br></pre></td></tr></table></figure></p><p> <strong>明天17点钟，输出时间到指定文件内,使用多行重定向</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># at 17:20 tomorrow &lt;&lt; EOF</span></span><br><span class="line">at&gt; date &gt; /root/2013.log</span><br><span class="line">&gt;EOF</span><br><span class="line">job 3 at 2018-09-02 17:20</span><br></pre></td></tr></table></figure></p><p> <strong>明天17点钟，输出时间到指定文件内,也可以使用管道</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># cat 1.txt |at 17:00</span></span><br></pre></td></tr></table></figure></p><p> <strong>明天17点钟，输出时间到指定文件内,也可以使用-f</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># at -f at.job 17:00</span></span><br></pre></td></tr></table></figure></p><p> <strong>明天17点钟，输出时间到指定文件内,也可以使用-t 年月日小时分.秒</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># at -t 201809022109.12</span></span><br></pre></td></tr></table></figure></p><p>计划任务设定后，在没有执行之前我们可以用atq 或者 at -l 命令来查看系统没有执行工作任务：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># atq</span></span><br><span class="line">3       2018-09-02 17:20 a root</span><br><span class="line">1       2018-09-04 17:00 a root</span><br><span class="line">2       2018-09-04 17:00 a root</span><br></pre></td></tr></table></figure></p><p>删除已经设置的任务：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atrm 2</span><br></pre></td></tr></table></figure></p><p>显示已经设置的任务内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at -c 3</span><br></pre></td></tr></table></figure></p><p>通过mail 可以查看计划任务是否执行,但是要加选项-m<br><strong>at计划任务的控制</strong><br> cat /etc/at.deny<br> cat /etc/at.allow  先查白名单，不在白名单里的禁止执行</p><h2 id="周期性的运行某任务"><a href="#周期性的运行某任务" class="headerlink" title="周期性的运行某任务"></a>周期性的运行某任务</h2><p>crontab命令被用来提交和管理用户的需要周期性执行的任务，与windows下的计划任务类似，当安装完成操作系统后，默认会安装此服务工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。<br><strong>选项</strong><br>-e：编辑该用户的计时器设置；<br>-l：列出该用户的计时器设置；<br>-r：删除该用户的计时器设置；<br>-u&lt;用户名称&gt;：指定要设定计时器的用户名称。<br>Linux下的任务调度分为两类：系统任务调度和用户任务调度</p><p>系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。<br>/etc/crontab文件包括下面几行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># cat /etc/crontab</span></span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br><span class="line">HOME=/</span><br><span class="line"></span><br><span class="line"><span class="comment"># For details see man 4 crontabs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Example of job definition:</span></span><br><span class="line"><span class="comment"># .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="comment"># |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="comment"># |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="comment"># |  |  |  |  |</span></span><br><span class="line"><span class="comment"># *  *  *  *  * user-name command to be executed</span></span><br></pre></td></tr></table></figure></p><p>前四行是用来配置crond任务运行的环境变量，<br>第一行SHELL变量指定了系统要使用哪个shell，这里是bash，<br>第二行PATH变量指定了系统执行命令的路径，<br>第三行MAILTO变量指定了crond的任务执行信息将通过电子邮件发送给root用户，如果MAILTO变量的值为空，则表示不发送任务执行信息给用户，<br>第四行的HOME变量指定了在执行命令或者脚本时使用的主目录。</p><p>用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab文件都被保存在/var/spool/cron目录中。其文件名与用户名一致，使用者权限文件如下：<br>/etc/cron.deny     该文件中所列用户不允许使用crontab命令<br>/etc/cron.allow    该文件中所列用户允许使用crontab命令<br>/var/spool/cron/   所有用户crontab文件存放的目录,以用户名命名</p><p>crontab文件的含义：用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：<br>minute   hour   day   month   week   command     顺序：分 时 日 月 周<br>minute： 表示分钟，可以是从0到59之间的任何整数。<br>hour：表示小时，可以是从0到23之间的任何整数。<br>day：表示日期，可以是从1到31之间的任何整数。<br>month：表示月份，可以是从1到12之间的任何整数。<br>week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。<br>user-name:以谁的身份执行<br>command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。</p><p>星号（<em>）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。<br>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”<br>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”<br>正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如</em>/10，如果用在minute字段，表示每十分钟执行一次。</p><p>/sbin/service crond start    //启动服务<br>/sbin/service crond stop     //关闭服务<br>/sbin/service crond restart  //重启服务<br>/sbin/service crond reload   //重新载入配置</p><p><strong>系统的计划任务</strong><br>/etc/crontab 配置文件<br>/etc/cron.d/ 配置文件<br>/etc/cron.hourly/ 脚本<br>/etc/cron.daily/ 脚本<br>/etc/cron.weekly/ 脚本<br>/etc/cron.monthly/ 脚本</p><p><strong>anacron系统</strong><br>/etc/anacrontab<br>• 字段1：如果在这些日子里没有运行这些任务……<br>• 字段2：在重新引导后等待这么多分钟后运行它<br>• 字段3：任务识别器，在日志文件中标识<br>• 字段4：要执行的任务<br>主要作用是执行关机没有执行的任务。<br><strong>查看wang的定时任务</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -l -u wang</span><br></pre></td></tr></table></figure></p><p>不论谁创建的计划任务都在/var/spool/cron/目录下。<br>日志放在 /var/log/cron<br>执行crontab -e 发现没有颜色，如何加入颜色呢<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> EDITOR=vim</span><br></pre></td></tr></table></figure></p><p>如果要永久保存：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile.d/test.cron</span><br></pre></td></tr></table></figure></p><p><strong>每1分钟执行一次command</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * <span class="built_in">command</span></span><br></pre></td></tr></table></figure></p><p><strong>每小时的第3和第15分钟执行</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 * * * * <span class="built_in">command</span></span><br></pre></td></tr></table></figure></p><p><strong>在上午8点到11点的第3和第15分钟执行</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 8-11 * * * <span class="built_in">command</span></span><br></pre></td></tr></table></figure></p><p><strong>每隔两天的上午8点到11点的第3和第15分钟执行</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 8-11 */2 * * <span class="built_in">command</span></span><br></pre></td></tr></table></figure></p><p><strong>每个星期一的上午8点到11点的第3和第15分钟执行</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 8-11 * * 1 <span class="built_in">command</span></span><br></pre></td></tr></table></figure></p><p><strong>每晚的21:30重启smb</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30 21 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure></p><p><strong>每月1、10、22日的4 : 45重启smb</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">45 4 1,10,22 * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure></p><p><strong>每周六、周日的1:10重启smb</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 1 * * 6,0 /etc/init.d/smb restart</span><br></pre></td></tr></table></figure></p><p><strong>每天18 : 00至23 : 00之间每隔30分钟重启smb</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0,30 18-23 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure></p><p><strong>每星期六的晚上11:00 pm重启smb</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 23 * * 6 /etc/init.d/smb restart</span><br></pre></td></tr></table></figure></p><p><strong>每一小时重启smb</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* */1 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure></p><p><strong>晚上11点到早上7点之间，每隔一小时重启smb</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">23-7/1 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure></p><p><strong>每月的4号与每周一到周三的11点重启smb</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 11 4 * mon-wed /etc/init.d/smb restart</span><br></pre></td></tr></table></figure></p><p><strong>一月一号的4点重启smb</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 4 1 jan * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure></p><p><strong>每小时执行/etc/cron.hourly目录内的脚本</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01 * * * * root run-parts /etc/cron.hourly</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 定时任务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>进程</title>
      <link href="/2018/08/29/%E8%BF%9B%E7%A8%8B/"/>
      <url>/2018/08/29/%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>进程（process）指的是执行中程序的一个实例。新进程由fork()与execve()等系统调用所起始，然后执行，知道他们下达exit()系统调用为止。<br>unix 系统都支持多进程，虽然计算机看来像是一次做了很多很多事情，除非你的计算机有多个CPU，否则这只是错觉。事实上，每个进程仅容许在一个极短的期间执行，我们称为时间片段（time slice）,之后进程会先暂时搁置，让其他等待中的进程执行。时间片段极短，通常只有几微秒，所以人们很少感觉到进程将控制权交回kernel,再交给另一个进程的这种文本切换。操作系统内核里称为调度器。当出现多个CPU时候，调度器会试着使用所有CPU处理工作负载。。用户除了觉得响应速度改善之外，其他不会有什么察觉。<br>进程会被指定优先权，这么一来，优先级高的进程能比不重要的进程先执行。nice与renice命令用于调整进程的优先权。<br>在任何瞬间，等待执行之进程的平均数，被称为平均负载，可以使用uptime命令显示开机至今的时间，用户数，及平均负载</p></blockquote><a id="more"></a> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># uptime</span></span><br><span class="line">07:05:28 up  2:17,  2 users,  load average: 0.00, 0.00, 0.00</span><br></pre></td></tr></table></figure><p>由于平均负载会一直变化，uptime会回报三个平均时间估算值，分别为最后一分钟，五分钟，十五分钟的估算值。当平均负载持续地超出可用CPU的承载时，表示系统工作已超出它所能负荷了，此时计算机可能陷入停滞著状态。</p><h1 id="进程的建立"><a href="#进程的建立" class="headerlink" title="进程的建立"></a>进程的建立</h1><p>   很多程序都有shell启动；每个命令行里的第一个单词时识别要执行的程序，一个shell 执行都会有以下事项：</p><ul><li>进程具有一个内核上下文，在内核里的数据结构，会记录与进程相关的信息，让内核便于管理与控制进程的执行。</li><li>进程拥有一个私有的被保护的虚拟地址空间。</li><li><p>三个文件描述代码：标准输入，标准输出，标准错误输出都已开启，且立即可用。</p><p>私有地址空间保证进程不受其他进程干扰，保证其数据是独立不共享的。</p></li></ul><h1 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h1><p>系统优先级：数字越小，优先级越高<br>实时优先级: 99-0 值最大优先级最高<br>nice优先级：-19-20<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># ps -l</span></span><br><span class="line">F S   UID    PID   PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">4 S     0   3410   3406  0  80   0 - 27121 do_wai pts/1    00:00:00 bash</span><br><span class="line">4 R     0   3454   3410  0  80   0 - 27037 -      pts/1    00:00:00 ps</span><br></pre></td></tr></table></figure></p><ul><li>UID：代表执行者的身份 </li><li>PID：代表进程的代号 </li><li>PPID：代表这个进程是有那个进程发展衍生而来的，也就是父进程的代号 </li><li>PRI：进程的优先级，大部分系统（Linux、UCOSII）都是数字越低优先级越高，进程就优先运行 ， Linux中的PRI（new） = PRI（old） + nice ，其中 ， PRI（old）为系统算法决定 ，在创建时被赋予不同的值，用户不可修改 ，用户只能通过修改nice</li><li>NI：进程优先级的修正量， -20 ~ 19 ，用户可修改 （root用户可修改nice值-20 ~ 19 ，普通用户只能修改nice值0~19 ）。一般情况下，子进程继承父进程的nice值，由于init进程的nice值为0，所有大部分进程的nice值都为 0。</li></ul><p><strong>改变进程优先级的2种方法</strong></p><ol><li>top命令。输入r，然后根据提示输入进程ID，再输入优先级数值。</li><li>renice命令。renice -n 2 -p 20.  -n，后面是优先级的值；-p，是进程号。<br><strong>指定程序运行的优先级</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nice -n 10 sleep 10</span><br></pre></td></tr></table></figure></li></ol><p>设置后可以通过命令 ps -axo pid,cmd,ni,pri 查看</p><h1 id="进程管理工具-pgrep-ps-psgrep-top-htop"><a href="#进程管理工具-pgrep-ps-psgrep-top-htop" class="headerlink" title="进程管理工具   pgrep ps  psgrep  top  htop"></a>进程管理工具   pgrep ps  psgrep  top  htop</h1><h2 id="进程类型"><a href="#进程类型" class="headerlink" title="进程类型"></a>进程类型</h2><p>守护进程: daemon,在系统引导过程中启动的进程，和终端无关进程<br>前台进程：跟终端相关，通过终端启动的进程</p><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p>前台进程<br>后台进程<br>运行态：running<br>就绪态：ready<br>睡眠态：<br>可中断：interruptable<br>不可中断：uninterruptable<br>停止态：stopped,暂停于内存，但不会被调度，除非手动启动<br>僵死态：zombie，结束进程，父进程结束前，子进程不关闭</p><h1 id="进程的控制跟删除"><a href="#进程的控制跟删除" class="headerlink" title="进程的控制跟删除"></a>进程的控制跟删除</h1><p>在我们生产种经常需要监控cpu ，IO的使用情况。常用的工具有pstree,ps,pidof,pgrep,top,htop,glance,pmap,vmstat,kill,pkill.</p><h2 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h2><p><strong>选项</strong><br>-a：显示每个程序的完整指令，包含路径，参数或是常驻服务的标示；<br>-c：不使用精简标示法；<br>-G：使用VT100终端机的列绘图字符；<br>-h：列出树状图时，特别标明现在执行的程序；<br>-H&lt;程序识别码&gt;：此参数的效果和指定”-h”参数类似，但特别标明指定的程序；<br>-l：采用长列格式显示树状图；<br>-n：用程序识别码排序。预设是以程序名称来排序；<br>-p：显示程序识别码；<br>-u：显示用户名称；<br>-U：使用UTF-8列绘图字符；<br>-V：显示版本信息。<br><strong>实例</strong><br>显示当前所有进程的进程号和进程id<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstree -p</span><br></pre></td></tr></table></figure></p><p>显示所有进程的所有详细信息，遇到相同的进程名可以压缩显示,包含路径，参数或是常驻服务的标示.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstree -a</span><br></pre></td></tr></table></figure></p><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p> ps命令用于报告当前系统的进程状态。可以搭配kill指令随时中断、删除不必要的程序。ps命令是最基本同时也是非常强大的进程查看命令，使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等，总之大部分信息都是可以通过执行该命令得到的。<br> Linux 系统各进程的相关信息均保存在/proc/PID目录下的各个文件中。<br><strong>选项</strong><br>    支持三种选项：<br>    UNIX选项 如-A -e<br>    BSD选项 如a<br>    GNU选项 如–help<br>BSD 风格<br>• a 选项包括所有终端中的进程<br>• x 选项包括不链接终端的进程<br>• u 选项显示进程所有者的信息<br>• f 选项显示进程树,相当于 –forest<br>• k|–sort 属性 对属性排序,属性前加- 表示倒序<br>• o 属性… 选项显示定制的信息 pid、cmd、%cpu、%mem<br>• L 显示支持的属性列表</p><p>UXIX 风格<br>常见的选项<br>• -C cmdlist 指定命令，多个命令用，分隔<br>• -L 显示线程<br>• -e: 显示所有进程，相当于-A<br>• -f: 显示完整格式程序信息<br>• -F: 显示更完整格式的进程信息<br>• -H: 以进程层级格式显示进程相关信息<br>• -u userlist 指定有效的用户ID或名称<br>• -U userlist 指定真正的用户ID或名称<br>• -g gid或groupname 指定有效的gid或组名称<br>• -G gid或groupname 指定真正的gid或组名称<br>• -p pid 显示指pid的进程<br>• –ppid pid 显示属于pid的子进程<br>• -M 显示SELinux信息，相当于Z<br><strong>实例</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 proc]<span class="comment"># ls /proc</span></span><br><span class="line">1     1364  2     2338  2594  2725  28    3406  49   9            irq           partitions</span><br><span class="line">10    1365  20    2354  2595  2727  288   3410  5    acpi         kallsyms      sched_debug</span><br><span class="line">100   1370  2000  2370  26    2728  289   35    50   asound       kcore         schedstat</span><br></pre></td></tr></table></figure></p><p>每个数字其实对应的就是一个进程，我们以httpd为例  pstree -p 看到进程编号是 4013<br>我们执行  cd 4013<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 4013]# ls</span><br><span class="line">attr        comm             fd        mem         numa_maps      root       stat</span><br><span class="line">autogroup   coredump_filter  fdinfo    mountinfo   oom_adj        sched      statm</span><br><span class="line">auxv        cpuset           io        mounts      oom_score      schedstat  status</span><br><span class="line">cgroup      cwd              limits    mountstats  oom_score_adj  sessionid  syscall</span><br><span class="line">clear_refs  environ          loginuid  net         pagemap        smaps      task</span><br><span class="line">cmdline     exe</span><br></pre></td></tr></table></figure></p><p>最常用的组合就是ps aux<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 4013]<span class="comment"># ps -axu</span></span><br><span class="line">Warning: bad syntax, perhaps a bogus <span class="string">'-'</span>? See /usr/share/doc/procps-3.2.8/FAQ</span><br><span class="line">USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root          1  0.0  0.0  19348  1568 ?        SNs  08:43   0:01 /sbin/init</span><br><span class="line">root          2  0.0  0.0      0     0 ?        SN   08:43   0:00 [kthreadd]</span><br><span class="line">root          3  0.0  0.0      0     0 ?        S    08:43   0:00 [migration/0]</span><br><span class="line">root          4  0.0  0.0      0     0 ?        S    08:43   0:00 [ksoftirqd/0]</span><br><span class="line">root          5  0.0  0.0      0     0 ?        S    08:43   0:00 [stopper/0]</span><br><span class="line">root          6  0.0  0.0      0     0 ?        S    08:43   0:00 [watchdog/0]</span><br><span class="line">root          7  0.0  0.0      0     0 ?        S    08:43   0:00 [migration/1]</span><br><span class="line">root          8  0.0  0.0      0     0 ?        S    08:43   0:00 [stopper/1]</span><br><span class="line">root          9  0.0  0.0      0     0 ?        S    08:43   0:00 [ksoftirqd/1]</span><br><span class="line">root         10  0.0  0.0      0     0 ?        S    08:43   0:00 [watchdog/1]</span><br></pre></td></tr></table></figure></p><p>USER 默认情况下USER执行程序的有效用户，而不是发起程序的执行者。<br>PID  进程编号<br>%CPU  cpu<br>%MEM  内存<br>VSZ 虚拟内存<br>RSS 物理实际使用的内存数<br>STAT：进程状态<br>R：running<br>S: interruptable sleeping<br>D: uninterruptable sleeping<br>T: stopped<br>Z: zombie<br>+: 前台进程<br>l: 多线程进程<br>L：内存分页并带锁<br>N：低优先级进程<br>&lt;: 高优先级进程<br>s: session leader，会话（子进程）发起者<br>我们可以显示指定项<br>ps axo pid,cmd,%cpu,%mem k k用于排序<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 4013]<span class="comment"># ps axo pid,cmd,%cpu,%mem </span></span><br><span class="line">   PID CMD                         %CPU %MEM</span><br><span class="line">     1 /sbin/init                   0.0  0.0</span><br><span class="line">     2 [kthreadd]                   0.0  0.0</span><br><span class="line">     3 [migration/0]                0.0  0.0</span><br><span class="line">     4 [ksoftirqd/0]                0.0  0.0</span><br><span class="line">     5 [stopper/0]                  0.0  0.0</span><br><span class="line">     6 [watchdog/0]                 0.0  0.0</span><br><span class="line">     7 [migration/1]                0.0  0.0</span><br><span class="line">     8 [stopper/1]                  0.0  0.0</span><br><span class="line">     9 [ksoftirqd/1]                0.0  0.0</span><br><span class="line">    10 [watchdog/1]                 0.0  0.0</span><br></pre></td></tr></table></figure></p><p>我们看到图形窗口比较占内存 我们关闭图形界面init 3 .内存下降了。<br>ps -L 用于查看支持的参数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps axo pid,cmd,ruser,euser,ni</span><br></pre></td></tr></table></figure></p><p>ruser 表示程序的发起者<br>euser 表示程序的生效用户<br>ni  表示nice 优先级<br><strong>只列出passwd相关的进程信息</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ps -C passwd</span><br><span class="line">or</span><br><span class="line">ps -C passwd  bash  可以指定多个</span><br><span class="line">or</span><br><span class="line">ps aux |grep .sh  查找执行脚本的进程</span><br></pre></td></tr></table></figure></p><p><strong>显示所有进程</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef</span><br></pre></td></tr></table></figure></p><p><strong>查看程序运行在哪颗CPU</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -axo pid,cmd,psr</span><br></pre></td></tr></table></figure></p><p><strong>0.5秒执行一次</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -n0.5 &apos;ps axo pid,cmd|grep httpd&apos;</span><br></pre></td></tr></table></figure></p><p><strong>模拟想对端服务器发起大量的http请求</strong><br>首先安装httpd-tools<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -c 1000 -n 2000 http://192.168.0.2/</span><br></pre></td></tr></table></figure></p><p><strong>让某个进程绑定在指定0号cpu上执行</strong><br><code>在生产中可以提升性能</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskset -cp 0 进程编号</span><br></pre></td></tr></table></figure></p><p><strong>显示某个用户发起哪些进程</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -fU  root</span><br></pre></td></tr></table></figure></p><p><strong>查看实际用户跟由效用户都是root</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -U  root -u root</span><br></pre></td></tr></table></figure></p><p><strong>列出某个组拥有的所有进程</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -fG nginx</span><br></pre></td></tr></table></figure></p><p><strong>以父进程来显示其下面的所有进程</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -f --ppid 1234</span><br></pre></td></tr></table></figure></p><p><strong>以树状结构显示</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -e --forest</span><br></pre></td></tr></table></figure></p><h2 id="pgrep-搜索进程"><a href="#pgrep-搜索进程" class="headerlink" title="pgrep 搜索进程"></a>pgrep 搜索进程</h2><p>pgrep命令以名称为依据从运行进程队列中查找进程，并显示查找到的进程id。每一个进程ID以一个十进制数表示，通过一个分割字符串和下一个ID分开，默认的分割字符串是一个新行。对于每个属性选项，用户可以在命令行上指定一个以逗号分割的可能值的集合。<br>最灵活：ps 选项 | 其它命令<br>. 按预定义的模式：pgrep<br>  pgrep [options] pattern<br>    -u uid: effective user，生效者<br>    -U uid: real user，真正发起运行命令者<br>    -t terminal: 与指定终端相关的进程<br>    -l: 显示进程名<br>    -a: 显示完整格式的进程名<br>    -P pid: 显示指定进程的子进程<br>    -g：指定进程组；<br>. 按确切的程序名称：/sbin/pidof<br>  pidof bash<br> <strong>查找某个终端上的进程</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pgrep -t pts/0</span><br></pre></td></tr></table></figure></p><p><strong>查找某个用户的进程</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pgrep -lU wang</span><br></pre></td></tr></table></figure></p><p><strong>根据进程的名称把进程的id显示出来</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidof bash   可以用他判断这个进程是否运行</span><br></pre></td></tr></table></figure></p><p><strong>查找包含vi的进程</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pgrep -l <span class="string">"^vi"</span></span><br></pre></td></tr></table></figure></p><h2 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h2><p>uptime命令能够打印系统总共运行了多长时间和系统的平均负载。uptime命令可以显示的信息显示依次为：现在时间、系统已经运行了多长时间、目前有多少登陆用户、系统在过去的1分钟、5分钟和15分钟内的平均负载。<br>[root@centos6 4013]# uptime<br> 12:27:59  系统当前时间<br> up 3:44,  主机已运行时间,时间越大，说明你的机器越稳定。<br> 3 users, 用户连接数，是总连接数而不是用户数<br> load average: 0.00, 0.00, 0.00  系统平均负载，统计最近1，5，15分钟的系统平均负载</p><p>那么什么是系统平均负载呢？ 系统平均负载是指在特定时间间隔内运行队列中的平均进程数。<br>如果每个CPU内核的当前活动进程数不大于3的话，那么系统的性能是良好的。如果每个CPU内核的任务数大于5，那么这台机器的性能有严重问题。<br>如果你的linux主机是1个双核CPU的话，当Load Average 为6的时候说明机器已经被充分使用了。</p><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>top命令可以实时动态地查看系统的整体运行情况，是一个综合了多方信息监测系统性能和运行信息的实用工具。通过top命令所提供的互动式界面，用热键可以管理。<br><strong>选项</strong><br>-b：以批处理模式操作；<br>-c：显示完整的治命令；<br>-d：屏幕刷新间隔时间；<br>-I：忽略失效过程；<br>-s：保密模式；<br>-S：累积模式；<br>-i&lt;时间&gt;：设置间隔时间；<br>-u&lt;用户名&gt;：指定用户名；<br>-p&lt;进程号&gt;：指定进程；<br>-n&lt;次数&gt;：循环显示的次数。<br>交互命令<br>h：显示帮助画面，给出一些简短的命令总结说明；<br>k：终止一个进程；<br>i：忽略闲置和僵死进程，这是一个开关式命令；<br>q：退出程序；<br>r：重新安排一个进程的优先级别；<br>S：切换到累计模式；<br>s：改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成ms。输入0值则系统将不断刷新，默认值是5s；<br>f或者F：从当前显示中添加或者删除项目；<br>o或者O：改变显示项目的顺序；<br>l：切换显示平均负载和启动时间信息；<br>m：切换显示内存信息；<br>t：切换显示进程和CPU状态信息；<br>c：切换显示命令名称和完整命令行；<br>M：根据驻留内存大小进行排序；<br>P：根据CPU使用百分比大小进行排序；<br>T：根据时间/累计时间进行排序；<br>w：将当前设置写入~/.toprc文件中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 4013]<span class="comment"># top</span></span><br><span class="line">top - 12:33:01 up  3:49,  3 users,  load average: 0.00, 0.00, 0.00</span><br><span class="line">Tasks: 191 total,   1 running, 188 sleeping,   2 stopped,   0 zombie</span><br><span class="line">Cpu(s):  0.0%us,  0.2%sy,  0.0%ni, 99.8%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st</span><br><span class="line">Mem:   2037260k total,   649144k used,  1388116k free,    70004k buffers</span><br><span class="line">Swap:  2097148k total,        0k used,  2097148k free,   194348k cached</span><br></pre></td></tr></table></figure></p><p>解释：<br>top - 09:44:56[当前系统时间],<br>16 days[系统已经运行了16天],<br>1 user[个用户当前登录],<br>load average: 9.59, 4.75, 1.92[系统负载，即任务队列的平均长度]<br>Tasks: 145 total[总进程数],<br>2 running[正在运行的进程数],<br>143 sleeping[睡眠的进程数],<br>0 stopped[停止的进程数],<br>0 zombie[冻结进程数],<br>Cpu(s): 99.8%us[用户空间占用CPU百分比],<br>0.1%sy[内核空间占用CPU百分比],<br>0.0%ni[用户进程空间内改变过优先级的进程占用CPU百分比],<br>0.2%id[空闲CPU百分比], 0.0%wa[等待输入输出的CPU时间百分比],<br>0.0%hi[],<br>0.0%st[],<br>Mem: 4147888k total[物理内存总量],<br>2493092k used[使用的物理内存总量],<br>1654796k free[空闲内存总量],<br>158188k buffers[用作内核缓存的内存量]<br>Swap:  5144568k total[交换区总量],<br>56k used[使用的交换区总量],<br>5144512k free[空闲交换区总量],<br>2013180k cached[缓冲的交换区总量]</p><h2 id="pmap"><a href="#pmap" class="headerlink" title="pmap"></a>pmap</h2><p>pmap命令用于报告进程的内存映射关系，是Linux调试及运维一个很好的工具。<br><strong>选项</strong><br>-x：显示扩展格式；<br>-d：显示设备格式；<br>-q：不显示头尾行；<br>-V：显示指定版本。<br><strong>查看某个进程占用的内存空间</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pmap 进程编号</span><br></pre></td></tr></table></figure></p><h2 id="glance"><a href="#glance" class="headerlink" title="glance"></a>glance</h2><p>glances命令：EPEL源<br> glances [-bdehmnrsvyz1] [-B bind] [-c server] [-C conffile] [-p port] [-P password] [–<br>password] [-t refresh] [-f file] [-o output]<br><strong>选项</strong><br>-b: 以Byte为单位显示网卡数据速率<br>-d: 关闭磁盘I/O模块<br>-f /path/to/somefile: 设定输入文件位置<br>-o {HTML|CSV}：输出格式<br>-m: 禁用mount模块<br>-n: 禁用网络模块<br>-t #: 延迟时间间隔<br>-1：每个CPU的相关数据单独显示</p><p>C/S模式下运行glances命令<br>服务器模式：<br>glances -s -B IPADDR<br>IPADDR: 指明监听的本机哪个地址<br>客户端模式：<br>glances -c IPADDR<br>IPADDR：要连入的服务器端地址</p><h2 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h2><p>vmstat命令的含义为显示虚拟内存状态（“Viryual Memor Statics”），但是它可以报告关于进程、内存、I/O等系统整体运行状态。<br><strong>选项</strong><br>-a：显示活动内页；<br>-f：显示启动后创建的进程总数；<br>-m：显示slab信息；<br>-n：头信息仅显示一次；<br>-s：以表格方式显示事件计数器和内存状态；<br>-d：报告磁盘状态；<br>-p：显示指定的硬盘分区状态；<br>-S：输出信息的单位。<br><strong>参数</strong><br>事件间隔：状态信息刷新的时间间隔；<br>次数：显示报告的次数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 4013]<span class="comment"># vmstat 3</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   <span class="keyword">in</span>   cs us sy id wa st</span><br><span class="line"> 0  0      0 1388888  70284 194380    0    0     9     1   14   21  0  0 100  0  0</span><br><span class="line"> 0  0      0 1388832  70284 194408    0    0     0     0   24   36  0  0 100  0  0</span><br><span class="line"> 0  0      0 1388800  70292 194404    0    0     0     4   22   28  0  0 100  0  0</span><br><span class="line"> 0  0      0 1388832  70292 194408    0    0     0     0   26   34  0  0 100  0  0</span><br></pre></td></tr></table></figure></p><p>字段说明：<br>Procs（进程）</p><ul><li>r: 运行队列中进程数量，这个值也可以判断是否需要增加CPU。（长期大于1）</li><li><p>b: 等待IO的进程数量。<br>Memory（内存）</p></li><li><p>swpd: 使用虚拟内存大小，如果swpd的值不为0，但是SI，SO的值长期为0，这种情况不会影响系统性能。</p></li><li>free: 空闲物理内存大小。</li><li>buff: 用作缓冲的内存大小。</li><li><p>cache: 用作缓存的内存大小，如果cache的值大的时候，说明cache处的文件数多，如果频繁访问到的文件都能被cache处，那么磁盘的读IO bi会非常小。<br>Swap</p></li><li><p>si: 每秒从交换区写到内存的大小，由磁盘调入内存。</p></li><li>so: 每秒写入交换区的内存大小，由内存调入磁盘。<br>注意：内存够用的时候，这2个值都是0，如果这2个值长期大于0时，系统性能会受到影响，磁盘IO和CPU资源都会被消耗。有些朋友看到空闲内存（free）很少的或接近于0时，就认为内存不够用了，不能光看这一点，还要结合si和so，如果free很少，但是si和so也很少（大多时候是0），那么不用担心，系统性能这时不会受到影响的。</li></ul><p>IO（现在的Linux版本块的大小为1kb）</p><ul><li>bi: 每秒读取的块数</li><li>bo: 每秒写入的块数<br>注意：随机磁盘读写的时候，这2个值越大（如超出1024k)，能看到CPU在IO等待的值也会越大。</li></ul><p>system（系统）</p><ul><li>in: 每秒中断数，包括时钟中断。</li><li>cs: 每秒上下文切换数。<br>注意：上面2个值越大，会看到由内核消耗的CPU时间会越大。</li></ul><p>CPU（以百分比表示）</p><ul><li>us: 用户进程执行时间百分比(user time)</li><li><p>us的值比较高时，说明用户进程消耗的CPU时间多，但是如果长期超50%的使用，那么我们就该考虑优化程序算法或者进行加速。</p></li><li><p>sy: 内核系统进程执行时间百分比(system time)<br>sy的值高时，说明系统内核消耗的CPU资源多，这并不是良性表现，我们应该检查原因。</p></li><li><p>wa: IO等待时间百分比<br>wa的值高时，说明IO等待比较严重，这可能由于磁盘大量作随机访问造成，也有可能磁盘出现瓶颈（块操作）。</p></li><li><p>id: 空闲时间百分比</p></li></ul><h2 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h2><p>kill命令用来删除执行中的程序或工作。kill可将指定的信息送至程序。预设的信息为SIGTERM(15),可将指定程序终止。若仍无法终止该程序，可使用SIGKILL(9)信息尝试强制删除程序。程序或工作的编号可利用ps指令或job指令查看。</p><p>显示当前系统可用信号： kill –l,trap -l<br>常用信号：man 7 signal<br>1) SIGHUP: 无须关闭进程而让其重读配置文件<br>2) SIGINT: 中止正在运行的进程；相当于Ctrl+c<br>3) SIGQUIT:相当于ctrl+\<br>9) SIGKILL: 强制杀死正在运行的进程<br>15) SIGTERM：终止正在运行的进程<br>18) SIGCONT：继续运行<br>19) SIGSTOP：后台休眠<br>指定信号的方法：<br>(1) 信号的数字标识：1, 2, 9<br>(2) 信号完整名称：SIGHUP (3) 信号的简写名称：HUP</p><p><strong>选项</strong><br>-a：当处理当前进程时，不限制命令名和进程号的对应关系；<br>-l &lt;信息编号&gt;：若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称；<br>-p：指定kill 命令只打印相关进程的进程号，而不发送任何信号；<br>-s &lt;信息名称或编号&gt;：指定要送出的信息；<br>-u：指定用户。<br><strong>列出所有信号名称：</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -l</span><br></pre></td></tr></table></figure></p><p>HUP     1    终端断线<br>INT     2    中断（同 Ctrl + C）<br>QUIT    3    退出（同 Ctrl + \）<br>TERM   15    终止<br>KILL    9    强制终止<br>CONT   18    继续（与STOP相反， fg/bg命令）<br>STOP   19    暂停（同 Ctrl + Z）</p><p>先用ps查找进程，然后用kill杀掉：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep vim</span><br></pre></td></tr></table></figure></p><p><strong>修改网站的目录</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/httpd/conf/httpd.conf</span><br></pre></td></tr></table></figure></p><p>杀死一个进程<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pidof bc  查看进程编号</span><br><span class="line"><span class="built_in">kill</span> -2 29400 </span><br><span class="line">合起来</span><br><span class="line"><span class="built_in">kill</span> -2 `pidof bc`</span><br></pre></td></tr></table></figure></p><h2 id="pkill"><a href="#pkill" class="headerlink" title="pkill"></a>pkill</h2><p>pkill命令可以按照进程名杀死进程。pkill和killall应用方法差不多，也是直接杀死运行中的程序；如果您想杀掉单个进程，请用kill来杀掉。<br><strong>选项</strong><br>-o：仅向找到的最小（起始）进程号发送信号；<br>-n：仅向找到的最大（结束）进程号发送信号；<br>-P：指定父进程号发送信号；<br>-g：指定进程组；<br>-t：指定开启进程的终端。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pgrep -l vim</span><br><span class="line">pkill vim</span><br></pre></td></tr></table></figure></p><p><strong>所有以root用户发起的进程全部杀掉</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkill -U root -9</span><br></pre></td></tr></table></figure></p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h2><p>iostat命令被用于监视系统输入输出设备和CPU的使用情况。它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况。同vmstat一样，iostat也有一个弱点，就是它不能对某个进程进行深入分析，仅对系统的整体情况进行分析。<br><strong>选项</strong><br>-c：仅显示CPU使用情况；<br>-d：仅显示设备利用率；<br>-k：显示状态以千字节每秒为单位，而不使用块每秒；<br>-m：显示状态以兆字节每秒为单位；<br>-p：仅显示块设备和所有被使用的其他分区的状态；<br>-t：显示每个报告产生时的时间；<br>-V：显示版号并退出；<br>-x：显示扩展状态。<br><strong>参数</strong><br>间隔时间：每次报告的间隔时间（秒）；<br>次数：显示报告的次数。<br><strong>实例</strong><br>用iostat -x /dev/sda1来观看磁盘I/O的详细情况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># iostat -x /dev/sda1 </span></span><br><span class="line">Linux 2.6.32-754.el6.x86_64 (centos6)   09/01/2018      _x86_64_        (2 CPU)</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           0.02    0.00    0.18    0.17    0.00   99.63</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s   rsec/s   wsec/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda1              0.00     0.00    0.04    0.00     0.33     0.00     8.60     0.00    1.64    1.65    0.89   1.59   0.01</span><br></pre></td></tr></table></figure></p><p>字段说明<br>标识    说明<br>Device    监测设备名称<br>rrqm/s    每秒需要读取需求的数量<br>wrqm/s    每秒需要写入需求的数量<br>r/s     每秒实际读取需求的数量<br>w/s    每秒实际写入需求的数量<br>rsec/s    每秒读取区段的数量<br>wsec/s    每秒写入区段的数量<br>rkB/s    每秒实际读取的大小，单位为KB<br>wkB/s    每秒实际写入的大小，单位为KB<br>avgrq-sz    需求的平均大小区段<br>avgqu-sz    需求的平均队列长度<br>await    等待I/O平均的时间（milliseconds）<br>svctm    I/O需求完成的平均时间<br>%util    被I/O需求消耗的CPU百分比</p><h1 id="fuser"><a href="#fuser" class="headerlink" title="fuser"></a>fuser</h1><p>fuser命令用于报告进程使用的文件和网络套接字。fuser命令列出了本地进程的进程号，那些本地进程使用file，参数指定的本地或远程文件。对于阻塞特别设备，此命令列出了使用该设备上任何文件的进程。<br><strong>选项</strong><br>-a：显示命令行中指定的所有文件；<br>-k：杀死访问指定文件的所有进程；<br>-i：杀死进程前需要用户进行确认；<br>-l：列出所有已知信号名；<br>-m：指定一个被加载的文件系统或一个被加载的块设备；<br>-n：选择不同的名称空间；<br>-u：在每个进程后显示所属的用户名。<br><strong>实例</strong><br>要列出使用/etc/passwd文件的本地进程的进程号，请执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fuser /etc/passwd</span><br></pre></td></tr></table></figure></p><p>要列出使用/etc/filesystems文件的进程的进程号和用户登录名，请执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fuser -u /etc/filesystems</span><br></pre></td></tr></table></figure></p><p>要终止使用给定文件系统的所有进程，请执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fuser -kxuc /home</span><br></pre></td></tr></table></figure></p><p>任一命令都列出了进程号和用户名，然后终止每个正在使用/dev/hd1 (/home)文件系统的进程。仅有root用户能终止属于另一用户的进程。如果您正在试图卸下/dev/hd1文件系统，而一个正在访问/dev/hd1文件系统的进程不允许这样，您可能希望使用此命令。<br>要列出正在使用已从给定文件系统删除的文件的全部进程，请执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fuser -d /usr文件</span><br></pre></td></tr></table></figure></p><h1 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h1><p>lsof命令用于查看你进程开打的文件，打开文件的进程，进程打开的端口(TCP、UDP)。找回/恢复删除的文件。是十分方便的系统监视工具，因为lsof命令需要访问核心内存和各种文件，所以需要root用户执行。</p><p>在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。所以如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，无论这个文件的本质如何，该文件描述符为应用程序与基础操作系统之间的交互提供了通用接口。因为应用程序打开文件的描述符列表提供了大量关于这个应用程序本身的信息，因此通过lsof工具能够查看这个列表对系统监测以及排错将是很有帮助的。<br><strong>选项</strong><br>-a：列出打开文件存在的进程；<br>-c&lt;进程名&gt;：列出指定进程所打开的文件；<br>-g：列出GID号进程详情；<br>-d&lt;文件号&gt;：列出占用该文件号的进程；<br>+d&lt;目录&gt;：列出目录下被打开的文件；<br>+D&lt;目录&gt;：递归列出目录下被打开的文件；<br>-n&lt;目录&gt;：列出使用NFS的文件；<br>-i&lt;条件&gt;：列出符合条件的进程。（4、6、协议、:端口、 @ip ）<br>-p&lt;进程号&gt;：列出指定进程号所打开的文件；<br>-u：列出UID号进程详情；<br>-h：显示帮助信息；<br>-v：显示版本信息。</p><p><strong>实例</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># lsof |less</span></span><br><span class="line">COMMAND    PID      USER   FD      TYPE             DEVICE SIZE/OFF       NODE NAME</span><br><span class="line">init         1      root  cwd       DIR                8,2     4096          2 /</span><br><span class="line">init         1      root  rtd       DIR                8,2     4096          2 /</span><br><span class="line">init         1      root  txt       REG                8,2   150352    2752572 /sbin/init</span><br><span class="line">init         1      root  mem       REG                8,2    66432    1179680 /lib64/libnss_files-2.12.so</span><br><span class="line">init         1      root  mem       REG                8,2  1930416    1188715 /lib64/libc-2.12.so</span><br><span class="line">init         1      root  mem       REG                8,2    93352    1188734 /lib64/libgcc_s-4.4.7-20120601.so.1</span><br><span class="line">init         1      root  mem       REG                8,2    47760    1188718 /lib64/librt-2.12.so</span><br><span class="line">init         1      root  mem       REG                8,2   146592    1188717 /lib64/libpthread-2.12.so</span><br><span class="line">init         1      root  mem       REG                8,2   268240    1188736 /lib64/libdbus-1.so.3.4.0</span><br><span class="line">init         1      root  mem       REG                8,2    39896    1179811 /lib64/libnih-dbus.so.1.0.0</span><br><span class="line">init         1      root  mem       REG                8,2   106016    1179813 /lib64/libnih.so.1.0.0</span><br><span class="line">init         1      root  mem       REG                8,2   161776    1188015 /lib64/ld-2.12.so</span><br><span class="line">init         1      root    0u      CHR                1,3      0t0       4601 /dev/null</span><br><span class="line">init         1      root    1u      CHR                1,3      0t0       4601 /dev/null</span><br><span class="line">init         1      root    2u      CHR                1,3      0t0       4601 /dev/null</span><br><span class="line">init         1      root    3r     FIFO                0,8      0t0      10027 pipe</span><br><span class="line">init         1      root    4w     FIFO                0,8      0t0      10027 pipe</span><br><span class="line">init         1      root    5r      DIR               0,10        0          1 inotify</span><br><span class="line">init         1      root    6r      DIR               0,10        0          1 inotify</span><br><span class="line">init         1      root    7u     unix 0xffff8800788123c0      0t0      10028 @/com/ubuntu/upstart</span><br><span class="line">init         1      root    9u     unix 0xffff88003649eb00      0t0      14176 socket</span><br><span class="line">kthreadd     2      root  cwd       DIR                8,2     4096          2 /</span><br></pre></td></tr></table></figure></p><p>lsof输出各列信息的意义如下：<br>COMMAND：进程的名称<br>PID：进程标识符<br>PPID：父进程标识符（需要指定-R参数）<br>USER：进程所有者<br>PGID：进程所属组<br>FD：文件描述符，应用程序通过文件描述符识别该文件。<br><strong>查看所有的连接</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i -n</span><br></pre></td></tr></table></figure></p><p><strong>查看80端口哪个进程在使用</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i :80 -n</span><br></pre></td></tr></table></figure></p><p><strong>lsof 恢复删除的文件</strong><br>我们删除/var/log/messages 然后再恢复</p><ol><li><p>执行 lsof /var/log/messages</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># lsof /var/log/messages</span></span><br><span class="line">COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF    NODE NAME</span><br><span class="line">rsyslogd 1787 root    1w   REG    8,2  1748540 2492734 /var/<span class="built_in">log</span>/messages</span><br></pre></td></tr></table></figure></li><li><p>删除 rm -f /var/log/messages</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f /var/<span class="built_in">log</span>/messages</span><br></pre></td></tr></table></figure></li><li><p>lsof |grep messages</p></li><li><p>我们进入proc 下的 进程编号</p></li><li><p>ls fd/ -l</p></li><li><p>cat /proc/6/fd/1 &gt; /var/log/messages</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网络管理</title>
      <link href="/2018/08/22/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/"/>
      <url>/2018/08/22/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p><div align="center"><img src="/Linux/internet.jpg" alt="logo"></div><br>本章主要介绍OSI7层模型，IP地址的分类，以及路由的配置等。</p></blockquote><a id="more"></a><h1 id="一-OSI-7层模型以及各层作用"><a href="#一-OSI-7层模型以及各层作用" class="headerlink" title="一. OSI 7层模型以及各层作用"></a>一. OSI 7层模型以及各层作用</h1><h2 id="下面这幅图介绍了7层协议以及每一层的作用"><a href="#下面这幅图介绍了7层协议以及每一层的作用" class="headerlink" title="下面这幅图介绍了7层协议以及每一层的作用"></a>下面这幅图介绍了7层协议以及每一层的作用</h2><p> <code style="color:red">图片来源于网络</code><br> <img src="/Linux/osi7层.png" alt="logo"><br><strong>应运层</strong><br>  为应运程序提供服务并规定应运程序中通信的相关细节，包括文件传输，电子邮件等协议。<br><strong>表示层</strong><br>  将应运处理的消息转换为适合网络传输的格式，或将来自下一层的协议转换为上一层能够处理的格式，因此他主要负责数据格式转换。<br><strong>会话层</strong><br>  负责建立跟断开通信连接，以及数据的分割等数据的传输相关工作。<br><strong>传输层</strong><br>  起着可靠的传输作用，只在通信双方节点上进行处理，而无需在路由器上处理。<br><strong>网络层</strong><br>  将数据传输到目的地址，目的地址可以是多个网络通过路由器连接而成的某一个地址。因此这一层主要负责寻址跟路由选择。<br><strong>数据链路层</strong><br>  负责物理层面上互连，节点之间的通信传输。例如与一个以太网相连的2个节点通信。<br><strong>物理层</strong><br>  负责0，1比特流与电压的高低，光的闪灭之间的互换。</p><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><p>TCP/IP是指tcp跟ip协议，实际上ip icmp ftp http udp igmp 等都属于tcp/ip 协议。<br>tcp/ip的分层模型<br>   <img src="/Linux/osi7层模型.png" alt="logo"></p><h2 id="tcp-ip-分层模型与通信实例"><a href="#tcp-ip-分层模型与通信实例" class="headerlink" title="tcp/ip 分层模型与通信实例"></a>tcp/ip 分层模型与通信实例</h2><p> <strong>数据包首部</strong><br>  <img src="/Linux/数据包首部9.png" alt="logo"><br>  每个层中都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的地址以及协议相关信息。通常协议提供的信息为包的首部。</p><ol><li>包 包可以说是全能性术语</li><li>帧   用于表示数据链接层包的单位</li><li>数据报  ip和udp等网络层以上的分层中包的单位</li><li>段   tcp 数据流中的信息</li><li>消息  应运协议中数据的单位<br><strong>ip 首部</strong><br><img src="/Linux/ip首部.png" alt="logo"></li><li>版本:占4位,指 IP 协议的版本目前的IP协议版本号为4</li><li>首部长度:占4位,可表示的最大数值是15个单位，一个单位为4字节，因此IP 的<br>首部长度的最大值是60字节</li><li>区分服务:占8位,用来获得更好的服务,在旧标准中叫做服务类型,但实际上一直未<br>被使用过.后改名为区分服务.只有在使用区分服务(DiffServ)时,这个字段才起作<br>用.一般的情况下都不使用</li><li>总长度:占16位,指首部和数据之和的长度,单位为字节,因此数据报的最大长度为<br>65535 字节.总长度必须不超过最大传送单元 MTU</li><li>标识:占16位,它是一个计数器,通常，每发送一个报文，该值会加1， 也用于数<br>据包分片，在同一个包的若干分片中，该值是相同的</li><li>标志(flag):占3位,目前只有后两位有意义</li><li>DF：Don‘t Fragment，中间的一位，只有当 DF=0 时才允许分片</li><li>MF: More Fragment，最高位，MF=1表示后面还有分片。MF=0 表示最后<br>一个分片</li><li>片偏移:占12位,指较长的分组在分片后，该分片在原分组中的相对位置.片偏移<br>以8个字节为偏移单位<ol start="10"><li>生存时间:占8位,记为TTL (Time To Live) 数据报在网络中可通过的路由器数的<br>最大值,TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字<br>RFC 指定,当前值为 64.发送 ICMP 回显应答时经常把 TTL 设为最大值 255 </li><li>协议:占8位,指出此数据报携带的数据使用何种协议以便目的主机的IP层将数据<br>部分上交给哪个处理过程, 1表示为 ICMP 协议, 2表示为 IGMP 协议, 6表示为<br>TCP 协议, 17表示为 UDP 协议</li><li>首部检验和:占16位,只检验数据报的首部不检验数据部分.这里不采用 CRC 检验<br>码而采用简单的计算方法</li><li>源地址和目的地址:都各占4字节,分别记录源地址和目的地址</li></ol></li></ol><h1 id="二-IP地址"><a href="#二-IP地址" class="headerlink" title="二. IP地址"></a>二. IP地址</h1><h2 id="（1）IP详细介绍"><a href="#（1）IP详细介绍" class="headerlink" title="（1）IP详细介绍"></a>（1）IP详细介绍</h2><p>IP地址是指互联网协议地址（英语：Internet Protocol Address，又译为网际协议地址），是IP Address的缩写。IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。目前还有些ip代理软件，但大部分都收费。<br>IP地址是一个32位的二进制数，通常被分割为4个“8位二进制数”（也就是4个字节）。IP地址通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d都是0~255之间的十进制整数。例：点分十进IP地址（100.4.5.6），实际上是32位二进制数（01100100.00000100.00000101.00000110）。</p><p>网络地址的最高位<br>A 0，B 10，C 110 </p><table><thead><tr><th>类别</th><th style="text-align:center">最大网络数</th><th style="text-align:center">IP地址范围</th><th style="text-align:center">最大主机数</th><th style="text-align:left">私有IP地址范围 </th></tr></thead><tbody><tr><td>A</td><td style="text-align:center">126(2^7-2)</td><td style="text-align:center">0.0.0.0-127.255.255.255</td><td style="text-align:center">2^24-2(16777214)</td><td style="text-align:left">10.0.0.0-10.255.255.255</td></tr><tr><td>B</td><td style="text-align:center">16384(2^14)</td><td style="text-align:center">128.0.0.0-191.255.255.255</td><td style="text-align:center">2^18-2(65534)</td><td style="text-align:left">172.16.0.0-172.31.255.255</td></tr><tr><td>C</td><td style="text-align:center">2097152(2^21)</td><td style="text-align:center">192.0.0.0-223.255.255.255</td><td style="text-align:center">2^11-2(254)</td><td style="text-align:left">192.168.0.0-192.168.255.255</td></tr></tbody></table><p><strong>A类IP地址</strong><br>一个A类IP地址是指， 在IP地址的四段号码中，第一段号码为网络号码，剩下的三段号码为本地计算机的号码。如果用二进制表示IP地址的话，A类IP地址就由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是“0”。A类IP地址中网络的标识长度为8位，主机标识的长度为24位，A类网络地址数量较少，有126个网络，每个网络可以容纳主机数达1600多万台。<br>A类IP地址 地址范围1.0.0.0到127.255.255.255 [1]  （二进制表示为：00000001 00000000 00000000 00000000 - 01111111 11111111 11111111 11111111）。最后一个是广播地址。<br>A类IP地址的子网掩码为255.0.0.0，每个网络支持的最大主机数为2^24-2=16777214台。<br><strong>B类IP地址</strong><br>一个B类IP地址是指，在IP地址的四段号码中，前两段号码为网络号码。如果用二进制表示IP地址的话，B类IP地址就由2字节的网络地址和2字节主机地址组成，网络地址的最高位必须是“10”。B类IP地址中网络的标识长度为16位，主机标识的长度为16位，B类网络地址适用于中等规模的网络，有16384个网络，每个网络所能容纳的计算机数为6万多台。<br>B类IP地址地址范围128.0.0.0-191.255.255.255 [3]  （二进制表示为：10000000 00000000 00000000 00000000—-10111111 11111111 11111111 11111111）。 最后一个是广播地址。<br>B类IP地址的子网掩码为255.255.0.0，每个网络支持的最大主机数为256的2次方-2=65534台。<br><strong>C类IP地址</strong><br>一个C类IP地址是指，在IP地址的四段号码中，前三段号码为网络号码，剩下的一段号码为本地计算机的号码。如果用二进制表示IP地址的话，C类IP地址就由3字节的网络地址和1字节主机地址组成，网络地址的最高位必须是“110”。C类IP地址中网络的标识长度为24位，主机标识的长度为8位，C类网络地址数量较多，有209万余个网络。适用于小规模的局域网络，每个网络最多只能包含254台计算机。<br>C类IP地址范围192.0.0.0-223.255.255.255 [3]  （二进制表示为: 11000000 00000000 00000000 00000000 - 11011111 11111111 11111111 11111111）。<br>C类IP地址的子网掩码为255.255.255.0，每个网络支持的最大主机数为256-2=254台<br><strong>D类IP地址</strong><br>D类IP地址在历史上被叫做多播地址(multicast address)，即组播地址。在以太网中，多播地址命名了一组应该在这个网络中应用接收到一个分组的站点。多播地址的最高位必须是“1110”，范围从224.0.0.0到239.255.255.255。<br>特殊的网址</p><ol><li>每一个字节都为0的地址（“0.0.0.0”）对应于当前主机；</li><li>IP地址中的每一个字节都为1的IP地址（“255．255．255．255”）是当前子网的广播地址；</li><li>IP地址中凡是以“11110”开头的E类IP地址都保留用于将来和实验使用。</li><li>IP地址中不能以十进制“127”作为开头，该类地址中数字127．0．0．1到127．255．255．255用于回路测试，如：127.0.0.1可以代表本-机IP地址，用“<a href="http://127.0.0.1”就可以测试本机中配置的Web服务器。" target="_blank" rel="noopener">http://127.0.0.1”就可以测试本机中配置的Web服务器。</a></li><li>网络ID的第一个8位组也不能全置为“0”，全“0”表示本地网络。</li></ol><h2 id="（2）IP网段"><a href="#（2）IP网段" class="headerlink" title="（2）IP网段"></a>（2）IP网段</h2><p>IP地址根据网络ID的不同分为5种类型，A类地址、B类地址、C类地址、D类地址和E类地址。<br>查找ip有个cmd命令：traceroute 后面加ip地址，可以查所经过的路由!<br>在一个局域网中，有两个IP地址比较特殊，一个是网络号，一个是广播地址。网络号是用于三层寻址的地址，它代表了整个网络本身；另一个是广播地址，它代表了网络全部的主机。网络号是网段中的第一个地址，广播地址是网段中的最后一个地址，这两个地址是不能配置在计算机主机上的。<br>例如在192.168.0.0，255.255.255.0这样的网段中，网络号是192.168.0.0，广播地址是192.168.0.255。因此，在一个局域网中，能配置在计算机中的地址比网段内的地址要少两个（网络号、广播地址），这些地址称之为主机地址。在上面的例子中，主机地址就只有192.168.0.1至192.168.0.254可以配置在计算机上了。<br><code style="color:#c7254e">因此我们得出以下公式：</code></p><ol><li>网段数=2^可变的网络id位数</li><li>主机数=2^主机id位数-2</li><li>网络id=ip跟netmask的与</li><li>判断目标主机是否和本主机是否在同一个网段，本机的netmask 分别与双方的ip 相与。再比较。</li><li>划分子网：将一个大网分割成多个子网，网络id 向主机id 借N位。得到2的N次方个子网。<h2 id="（2）2个主机分配同一个ip地址"><a href="#（2）2个主机分配同一个ip地址" class="headerlink" title="（2）2个主机分配同一个ip地址"></a>（2）2个主机分配同一个ip地址</h2></li></ol><p><code style="color:#c7254e">首先我们在2个不同的虚拟机里修改以下ip地址</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 192.168.0.1/24</span><br></pre></td></tr></table></figure></p><p>然后arping</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arping 192.168.0.1</span><br></pre></td></tr></table></figure><p>我们发现2个机器都有回应，我们使用arping 可以探测到是否有2个机器使用同一个ip地址.</p><h2 id="（4）那么我们怎么判断2个网络是不是同一个网段呢？"><a href="#（4）那么我们怎么判断2个网络是不是同一个网段呢？" class="headerlink" title="（4）那么我们怎么判断2个网络是不是同一个网段呢？"></a>（4）那么我们怎么判断2个网络是不是同一个网段呢？</h2><p>  我们平常都使用子网掩码来判断2个ip是否在同一个网段内。如果2个IP进行通信，首先判断在不在一个网段，如果在一个网段那么广播，如果不在一个网段直接找网关。<br>  CIDR无类域名路由，即不属于A,B,C,D,E类中的任意一类。<br>  我们判断一个IP是的网络位是多少可以根据ip范围来判断属于A,B,C,D类，然后找出他的网络位。但是如果网络位不固定，比如网络位位23，30 怎么判断他的网络位呢<br>  子网掩码此时就登场了，子网掩码也是32位的二进制。表现位高位为1，低位为0。<br>  即为1 的为网络id位，为0的为主机id位。<br>  由于CIDR无类域名路由的网络ID是不确定的，那么子网掩码有可能出现如下可能：<br>  00000000     0<br>  10000000     128<br>  11000000     192<br>  11100000     224<br>  11110000     240<br>  11111000     248<br>  11111100     252<br>  11111110     254<br>  11111111     255</p><p>  附：1-100的二进制<br>    1=1<br>    2=10<br>    3=11<br>    4=100<br>    5=101<br>    6=110<br>    7=111<br>    8=1000<br>    9=1001<br>    10=1010<br>    11=1011<br>    12=1100<br>    13=1101<br>    14=1110<br>    15=1111<br>    16=10000<br>    17=10001<br>    18=10010<br>    19=10011<br>    20=10100<br>    另外 网络id=ip 与 netmask  记住任何数与1相与都保留原值，与0相与都是0<br>    比如ip 192.168.32.8  netmask 255.255.255.0<br>    168 转二进制等于160+8   160的二进制10100000  8的二进制位1000<br>    10100000<br>        1000<br>    10101000<br>   168的二进制为 10101000,这里要注意逢二进1<br>    192.168.32.8  转成二进制  11000000.10101000.00100000.00001000<br>    255.255.255.0 转成二进制  11111111.11111111.11111111.00000000<br>                             11000000.10101000.00100000.00000000<br>                      十进制  192.168.32.0<br>    那么得出他的网络id是192.168.32                   </p><h2 id="（5）怎么划分网络"><a href="#（5）怎么划分网络" class="headerlink" title="（5）怎么划分网络"></a>（5）怎么划分网络</h2><p>  <strong>实例1：IP：192.168.200.100 子网掩码：255.255.240.0 此ip所在网段最多有多少主机</strong><br>   首先我们算出网络号多少位，然后（2^32-网络位）-2 就是此网段内最多的主机<br>   前面2个255是16位，后边的240 转成二进制 11110000 我们看到他有4个1，那么我们得出网络位为16+4=20.<br>   此ip所在网段最多有2^12-2=4094个主机。<br>  <strong>实例2：10.0.0.200/19  此ip netmask是多少，所在网络最多有多少主机</strong><br>    19代表网络id为19位，那么我们知道此ip内最多可以存放2^13-2=8190个主机<br>    子网掩码是255.255 这是16位 还差3位11100000， 那么得出子网掩码255.255.224.0<br>  <strong>实例3：ip:203.110.0.163/22 netmask是多少，所在网络最多有多少个主机，网络id多少</strong><br>    首先由网络位是22 ，那么子网掩码是 255.255.11111100.0 得出子网掩码是 255.255.252.0<br>    主机数等于 2^10-2=1022<br>    网络id =ip 与 子网掩码<br>    203.110.0.163<br>    255.255.252.0<br>    203.110.0.0<br>    得出网络id 为   203.110.0.0/22<br>  <strong>实例4：</strong><br>  <strong>有2个ip地址通信，</strong><br>  <strong>A：ip:192.168.32.1 netmask:255.255.0.0</strong><br>  <strong>B: ip:192.168.33.1 netmask:255.255.255.0</strong><br>  假设我现在在B 要与A通信，那么我们线算出B的网络id 是不是属于同一个网段<br>  前面我们说了网络id 是ip地址与netmask<br>  自己的ip地址跟自己的子网掩码与<br>  192.168.33.1<br>  255.255.255.0<br>  192.168.33.0<br>接下来拿A的ip地址跟B的子网掩码与<br>  192.168.32.1<br>  255.255.255.0<br>  192.168.32.0<br> 判断出不在一个网段。</p><p> 如果是A与B通信呢,判断是不是在同一个网段内<br> A的ip       192.168.32.1<br> A的子网掩码  255.255.0.0<br>             192.168.0.0</p><p>然后再拿B的ip与A的子网掩码与<br>192.168.33.1<br>255.255.0.0<br>192.168.0.0<br>判断出2个在同一个网段内。<br>得出一个结论判断2个ip是否在同一个网段内，要跟本机的netmask 相与得出是否一样。</p><p><strong>假设有2000台主机，都放在同一个网段中，netmask 应该是多少</strong><br>  我们想想2的11次方接近2000  那么主机位数就确定了应该是11个0，相应的得出网络位数。<br>  进而计算出netmask是多少。<br>  11111111 11111111  11111000  00000000<br>  255.255.248.0<br><strong>中国移动 10.10.10.0/8 32个省市要划分32个子网</strong></p><ol><li>子网netmask 是多少<br>要划分32个子网得出网络id数位2^5 =32 网络位为原来的8+5=13<br>那么得出子网掩码  255.248.0.0</li><li>每个子网的主机数是多少<br>2^19-2=524286 </li><li><p>最小的子网ip范围<br>我们先把最小的子网算出来，我们拿ip地址跟子网掩码相与得出网络id<br>ip:      10.10.10.0   00001010 00001010  00001010  00000000<br>子网掩码: 255.0.0.0    11111111 00000000  00000000  00000000<br>相与得出：             00001010 00000000  00000000  00000000<br>转成10进制：           10.0.0.0.0  由于虽然是借了5位，但是最小的是0.<br>所以最小的ip 就是10.0.0.0.1，反之最大的就是把0改成1.然后转成十进制表示。</p><p>我们前面由于网络位向主机位借了5位<br>00001010 00000  000  前面的部分是网络部分，后边的主机部分 00000000  00000000<br>最大的ip地址就是 10.00000  111.11111111.11111111.254<br>转十进制是    10.7.255.254</p></li><li><p>最大的子网网络id是多少<br>10.11111  000.00000000.00000000.000000000<br>10.248.0.0/13 </p><p><strong>中国移动 10.24.0.0/13 划分18个子网</strong></p></li><li>子网netmask 是多少<br>2^5 更接近于18，我们得出网络位数位13+5=18   18个1<br>11111111.1111111.11000000.00000000<br>255.255.192.0</li><li>每个子网的主机数是多少<br>2^14-2=16382</li><li>最小和最大的网络id<br>最小的网络id 10.24.0.0   10.00011000.00  000000.0000000 借了18位那么最小的就是10.24.0.0/18<br>最大的网络id 10.24.0.0   10.00011 100.01  000000.0000001 最大的就是 10.28.64.0/18</li><li>最大的子网ip范围是多少<br>最小的子网ip  10.00011 100.01  000000.0000001<br>最大的子网ip  10.00011 100.01  111111.254 <h1 id="三-TCP-IP-怎么保证可靠传输"><a href="#三-TCP-IP-怎么保证可靠传输" class="headerlink" title="三. TCP/IP 怎么保证可靠传输"></a>三. TCP/IP 怎么保证可靠传输</h1>TCP提供一种面向连接的，可靠的字节流服务；<br>什么是字节流服务：<br>TCP不在字节流中插入记录标志符就被称为是字节流服务；<br>TCP对字节流的处理方式：<br>TCP对字节流的内容不做任何解释，因为TCP分不清传输的是哪种类型的数据；对字节流的解释是由TCP连接双方的应用层来解释的；<br>TCP的这种对字节流的处理方式与UNIX操作系统对文件的处理方式很相似；<br>UNIX操作系统对文件的处理方式是： UNIX的内核对一个应用的读或写的内容不做任何解释，而是交给应用程序去解释，因为UNIX内核无法区分二进制文件和文本文件<br>在一个TCP连接中，仅有两方进行通信；<br>报文段的定义：<br>由TCP传递给IP的信息单位称为报文段或段；<br>以下是TCP提供可靠性的方式：<br>（1）应用数据被分割成TCP认为的最合适发送的数据块；<br>（2）当TCP发出一个报文段后，就启动一个定时器，用来等待目的端确认收到这个报文段；若没能及时收到这个确认，TCP发送端将重新发送这个报文段（超时重传）；<br>（3）TCP收到一个发自TCP连接的另一端的数据后就将发送一个确认，不过这个确认不是立即就发送，而是要推迟几分之一秒后才发送；<br>（4）TCP将保持它的首部和数据的检验和；（这是一个端到端的检验和，为了检验数据在传输过程中发生的错误；若检测到段的检验和有差错，TCP将丢弃和不确认收到此报文段并希望发端可以进行超时重传）<br>（5）由于TCP报文段是作为IP数据报来传输的，又因为IP数据报的到达可能会失序，所以TCP报文段的到达也可能会失序；因此，有必要的话TCP会对收到的数据进行重新排序后交给应用层；<br>（6）因为TCP报文段是作为IP数据报来传输的，并且IP数据报可能会发生重复，所以TCP的接收端必须丢弃掉重复的数据；<br>（7）TCP提供流量控制；（因为TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这一限制可以防止较快主机致使较慢主机的缓冲区溢出）</li></ol><h1 id="四-tcpip-穿透"><a href="#四-tcpip-穿透" class="headerlink" title="四. tcpip 穿透"></a>四. tcpip 穿透</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>  我们假设在两个不同的局域网后面分别有2台客户机A和 B，AB所在的局域网都分别通过一个路由器接入互联网。互联网上有一台服务器S。<br>    现在AB是无法直接和对方发送信息的，AB都不知道对方在互联网上真正的IP和端口， AB所在的局域网的路由器只允许内部向外主动发送的信息通过。对于B直接发送给A的路由器的消息，路由会认为其“不被信任”而直接丢弃。<br>    要实现 AB直接的通讯，就必须进行以下3步：A首先连接互联网上的服务器S并发送一条消息（对于UDP这种无连接的协议其实直接初始会话发送消息即可），这样S就获取了A在互联网上的实际终端（发送消息的IP和端口号）。接着 B也进行同样的步骤，S就知道了AB在互联网上的终端（这就是“打洞”）。接着S分别告诉A和B对方客户端在互联网上的实际终端，也即S告诉A客户B的会话终端，S告诉B客户A的会话终端。这样，在AB都知道了对方的实际终端之后，就可以直接通过实际终端发送消息了（因为先前双方都向外发送过消息，路由上已经有允许数据进出的消息通道）。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>启动服务器，监听端口8877</li><li>第一次启动客户端（称为client1），连上服务器，服务器将返回字符串first，标识这个是client1，同时，服务器将记录下这个客户端的（经过转换之后的）IP和端口。</li><li>第二次启动客户端（称为client2），连上服务器，服务器将向其返回自身的发送端口（称为port2)，以及client1的（经过转换之后的）IP和端口。</li><li>然后服务器再发client1返回client2（经过转换之后的）IP和端口，然后断开与这两个客户端的连接（此时，服务器的工作已经全部完成了）</li><li>client2尝试连接client1，这次肯定会失败，但它会在路由器上留下记录，以帮忙client1成功穿透，连接上自己，然后设置port2端口为可重用端口，并监听端口port2。</li><li>client1尝试去连接client2，前几次可能会失败，因为穿透还没成功，如果连接10次都失败，就证明穿透失败了（可能是硬件不支持）,如果成功，则每秒向client2发送一次hello, world</li><li>如果client1不断出现send message: Hello, world，client2不断出现recv message: Hello, world，则证明实验成功了，否则就是失败了。<br><a href="https://blog.csdn.net/small_qch/article/details/8815028" target="_blank" rel="noopener">原文链接</a></li></ol><h1 id="五-tcpip-三次握手"><a href="#五-tcpip-三次握手" class="headerlink" title="五.tcpip 三次握手"></a>五.tcpip 三次握手</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p> 按层次分，TCP 位于传输层，提供可靠的字节流服务。<br>所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）<br>为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。一言以蔽之，TCP 协<br>议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。</p><p>为了准确无误地将数据送达目标处，TCP 协议采用了三次握手（three-way handshaking）策略。用 TCP 协<br>议把数据包送出去后，TCP 不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中<br>使用了 TCP 的标志（flag） —— SYN（synchronize） 和 ACK（acknowledgement）。<br>发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后，回传一个带有 SYN/ACK 标志的数据包以<br>示传达确认信息。最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。<br>若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。</p><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><p>建立起一个TCP连接需要经过“三次握手”：<br>第一次握手：客户端发送syn包(syn=1)到服务器，并进入SYN_SEND状态，等待服务器确认；<br>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=x），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=x+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。<br>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主 动关闭连接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”<br> <img src="/Linux/三次握手.png" alt="logo"><br> 通俗的说就是客户端给服务端发送了一个syn的数据包，服务端收到后响应说我收到你发的数据包了，并发送标记有syn/ack的数据包，<br> 客户端收到后响应明白，发送给服务端标有ack的数据包代表握手结束。</p><h1 id="六-ARP-原理"><a href="#六-ARP-原理" class="headerlink" title="六.ARP 原理"></a>六.ARP 原理</h1><h2 id="协议概述"><a href="#协议概述" class="headerlink" title="协议概述"></a>协议概述</h2><p> 一台主机和另一台主机通信，要知道目标的IP地址，但是在局域网中传输数据的网卡却不能直接识别IP地址，所以用ARP解析协议将IP地解<br> 析成MAC地址。ARP协议的基本功能就是通过目标设备的IP地址，来查询目标设备的mac地址。<br> 在局域网的任意一台主机中，都有一个ARP缓存表，里面保存本机已知的此局域网中各主机和路由器的IP地址和MAC地址的对照关系。ARP缓存<br>主机A想和主机B通信<br>主机A会先查询自己的ARP缓存表里有没有B的联系方式，有的话，就将mac-b地址封装到数据包外面，发送出去。没有的话，A会向全网络发送一个<br>ARP广播包，大声询问：我的IP地址是192.168.0.2，硬件地址是mac-a，我想知道IP地址是192.168.0.3的硬件地址是多少？   此时，局域网内所有<br>主机都收到了，B收到后会单独私密回应：我是192.168.0.3，我的硬件地址是mac-b，其他主机不会理A的<br>此时A知道了B的信息，同时也会动态的更新自身的缓存表</p><h2 id="ARP攻击原理"><a href="#ARP攻击原理" class="headerlink" title="ARP攻击原理"></a>ARP攻击原理</h2><p>ARP欺骗攻击建立在局域网主机间相互信任的基础上的<br>当A发广播询问：我想知道IP是192.168.0.3的硬件地址是多少？<br>此时B当然会回话：我是IP192.168.0.3我的硬件地址是mac-b，<br>可是此时IP地址是192.168.0.4的C也非法回了：我是IP192.168.0.3,我的硬件地址是mac-c。而且是大量的。<br>所以A就会误信192.168.0.3的硬件地址是mac-c，而且动态更新缓存表<br>这样主机C就劫持了主机A发送给主机B的数据，这就是ARP欺骗的过程。<br>假如C直接冒充网关，此时主机C会不停的发送ARP欺骗广播，大声说：我的ip是192.168.0.1，我的硬件地址是mac-c，<br>此时局域网内所有主机都被欺骗，更改自己的缓存表，此时Ｃ将会监听到整个局域网发送给互联网的数据报。</p><h2 id="ARP命令使用"><a href="#ARP命令使用" class="headerlink" title="ARP命令使用"></a>ARP命令使用</h2><p> arp命令用于操作主机的arp缓冲区，它可以显示arp缓冲区中的所有条目、删除指定的条目或者添加静态的ip地址与MAC地址对应关系<br><strong>语法</strong><br>arp(选项)(参数)<br><strong>选项</strong><br>-a&lt;主机&gt;：显示arp缓冲区的所有条目；<br>-H&lt;地址类型&gt;：指定arp指令使用的地址类型；<br>-d&lt;主机&gt;：从arp缓冲区中删除指定主机的arp条目；<br>-D：使用指定接口的硬件地址；<br>-e：以Linux的显示风格显示arp缓冲区中的条目；<br>-i&lt;接口&gt;：指定要操作arp缓冲区的网络接口；<br>-s&lt;主机&gt;&lt;MAC地址&gt;：设置指定的主机的IP地址与MAC地址的静态映射；<br>-n：以数字方式显示arp缓冲区中的条目；<br>-v：显示详细的arp缓冲区条目，包括缓冲区条目的统计信息；<br>-f&lt;文件&gt;：设置主机的IP地址与MAC地址的静态映射。<br><strong>参数</strong><br>主机：查询arp缓冲区中指定主机的arp条目<br><strong>实例</strong><br>增加目标机器的ip 地址跟mac 地址的绑定，这样就不用发arp广播了，同时也避免arp欺骗<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp -s ip mac</span><br></pre></td></tr></table></figure></p><p>删除一个条目<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp -d ip</span><br></pre></td></tr></table></figure></p><p>查看本机的arp缓存表<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp -a</span><br></pre></td></tr></table></figure></p><p>通过ip地址获取主机名<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup ip</span><br></pre></td></tr></table></figure></p><p>默认的ttl 存活期<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/ip_default_ttl</span><br></pre></td></tr></table></figure></p><h1 id="七-基于linux的网络配置"><a href="#七-基于linux的网络配置" class="headerlink" title="七. 基于linux的网络配置"></a>七. 基于linux的网络配置</h1><h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><p>DHCP(Dynamic Host Configuration Protocol，动态主机配置协议),是一种局域网的网络协议，使用UDP协议工作，<br><strong>主要有2个用途</strong></p><ol><li>给内网网络或网络服务供应商自动分配IP地址</li><li>给用户或者内部网络管理员作为对所有计算机中央管理的手段<br><strong>DHCP 有以下功能：</strong></li><li>保证任何IP地址在同一时刻只能由一台DHCP客户机所使用。</li><li>DHCP应当可以给用户分配永久固定的IP地址。<br><strong>DHCP 有三种机制分配IP地址：</strong></li><li>自动分配</li><li>动态分配</li><li>手工分配<br><strong>DHCP 工作原理</strong><br><img src="/Linux/dhcp.jpg" alt="logo"><br>DHCP采用UDP协议作为传输，主机发送请求到DHCP服务端，DHCP服务器给主机回应，详细交互过程如上图。</li><li>DHCP Client以广播的方式发出DHCP Discover报文。</li><li>所有的DHCP Server都能够接收到DHCP Client发送的DHCP Discover报文，所有的DHCP Server都会给出响应，向DHCP Client发送一个DHCP Offer报文。<br>DHCP Offer报文中“Your(Client) IP Address”字段就是DHCP Server能够提供给DHCP Client使用的IP地址，且DHCP Server会将自己的IP地址放在“option”字段中以便DHCP Client区分不同的DHCP Server。DHCP Server在发出此报文后会存在一个已分配IP地址的纪录。</li><li>DHCP Client只能处理其中的一个DHCP Offer报文，一般的原则是DHCP Client处理最先收到的DHCP Offer报文。<br>DHCP Client会发出一个广播的DHCP Request报文，在选项字段中会加入选中的DHCP Server的IP地址和需要的IP地址。</li><li>DHCP Server收到DHCP Request报文后，判断选项字段中的IP地址是否与自己的地址相同。如果不相同，DHCP Server不做任何处理只清除相应IP地址分配记录；如果相同，DHCP Server就会向DHCP Client响应一个DHCP ACK报文，并在选项字段中增加IP地址的使用租期信息。</li><li>DHCP Client接收到DHCP ACK报文后，检查DHCP Server分配的IP地址是否能够使用。如果可以使用，则DHCP Client成功获得IP地址并根据IP地址使用租期自动启动续延过程；如果DHCP Client发现分配的IP地址已经被使用，则DHCP Client向DHCPServer发出DHCP Decline报文，通知DHCP Server禁用这个IP地址，然后DHCP Client开始新的地址申请过程。</li><li>DHCP Client在成功获取IP地址后，随时可以通过发送DHCP Release报文释放自己的IP地址，DHCP Server收到DHCP Release报文后，会回收相应的IP地址并重新分配。</li></ol><p>通俗的说就是客户端向服务器广播发现报文，服务器上有一个地址池，收到客户端请求后，<br>然后发送一个地址给客户端，客户端收到之后，在发一个回应，<br>表示我收到哪个服务器给我的地址。 该服务器收到以后，再给客户端发一个确认消息。<br>代表交换过程结束。<br><strong>DHCP 服务配置</strong><br>后边补充todo</p><h2 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h2><p>在生产中，如果有一个台web服务器，部署的ngnix应运。我们这样 命名这台主机<br>web_ngnix01.公司名称<br>下面我们看以下centos6跟7怎么修改主机名。<br><strong>centos6</strong><br>首先/etc/hosts 文件是hosts文件，可以配置ip 跟域名的映射关系，我们在本机访问域名的时候，浏览器会优先寻找host文件里的配置，如果没有在去DNS服务器请求。<br>hostname及主机名称放在 /etc/sysconfig/network文件中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># cat /etc/sysconfig/network</span></span><br><span class="line">NETWORKING=yes</span><br><span class="line">HOSTNAME=centos6</span><br></pre></td></tr></table></figure></p><p>我们看到hostname 是centos6.<br>我们修改成cetnos66</p><ol><li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># HOSTNAME=centos66 这种方法发现不起作用</span></span><br><span class="line">[root@centos6 ~]<span class="comment"># hostname centos66  这个可以</span></span><br></pre></td></tr></table></figure></li><li><p>我们改的只是内存，如果让重启也生效呢 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># vim /etc/sysconfig/network</span></span><br><span class="line">NETWORKING=yes</span><br><span class="line">HOSTNAME=centos66</span><br></pre></td></tr></table></figure></li><li><p>然后执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> bash</span><br></pre></td></tr></table></figure></li></ol><p><strong>centos7</strong><br>hostaname 名称保存路径 /etc/hostname<br>hostnamectl status 查看host状态<br>hostnamectl set-hostname centos77<br>要想生效执行 exec bash </p><h2 id="修改网卡名称"><a href="#修改网卡名称" class="headerlink" title="修改网卡名称"></a>修改网卡名称</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@centos66 ~]<span class="comment"># cat /etc/udev/rules.d/70-persistent-net.rules</span></span><br><span class="line"><span class="comment"># This file was automatically generated by the /lib/udev/write_net_rules</span></span><br><span class="line"><span class="comment"># program, run by the persistent-net-generator.rules rules file.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># You can modify it, as long as you keep each rule on a single</span></span><br><span class="line"><span class="comment"># line, and change only the value of the NAME= key.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PCI device 0x8086:0x100f (e1000)</span></span><br><span class="line">SUBSYSTEM==<span class="string">"net"</span>, ACTION==<span class="string">"add"</span>, DRIVERS==<span class="string">"?*"</span>, ATTR&#123;address&#125;==<span class="string">"00:0c:29:86:58:6d"</span>, ATTR&#123;<span class="built_in">type</span>&#125;==<span class="string">"1"</span>, KERNEL==<span class="string">"eth*"</span>, NAME=<span class="string">"eth1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PCI device 0x8086:0x100f (e1000)</span></span><br><span class="line">SUBSYSTEM==<span class="string">"net"</span>, ACTION==<span class="string">"add"</span>, DRIVERS==<span class="string">"?*"</span>, ATTR&#123;address&#125;==<span class="string">"00:0c:29:86:58:63"</span>, ATTR&#123;<span class="built_in">type</span>&#125;==<span class="string">"1"</span>, KERNEL==<span class="string">"eth*"</span>, NAME=<span class="string">"eth0"</span></span><br><span class="line">[root@centos66 ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>我们看到有eth0 eth1,address 就是我们的网卡地址，我们根据网卡地址对于的name,修改相应的网卡名称。<br>比如我们把eth0 修改为ethtest<br>dmesg 用于找内核模块，lsmod 用户找加载到内存中的模块。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@centos66 ~]<span class="comment"># dmesg |grep eth</span></span><br><span class="line">e1000 0000:02:01.0: eth0: (PCI:66MHz:32-bit) 00:0c:29:86:58:63</span><br><span class="line">e1000 0000:02:01.0: eth0: Intel(R) PRO/1000 Network Connection</span><br><span class="line">e1000 0000:02:02.0: eth1: (PCI:66MHz:32-bit) 00:0c:29:86:58:6d</span><br><span class="line">e1000 0000:02:02.0: eth1: Intel(R) PRO/1000 Network Connection</span><br><span class="line">e1000: eth0 NIC Link is Up 1000 Mbps Full Duplex, Flow Control: None</span><br><span class="line">e1000: eth1 NIC Link is Up 1000 Mbps Full Duplex, Flow Control: None</span><br><span class="line">eth0: no IPv6 routers present</span><br><span class="line">8021q: adding VLAN 0 to HW filter on device eth0</span><br><span class="line">8021q: adding VLAN 0 to HW filter on device eth1</span><br><span class="line">eth1: no IPv6 routers present</span><br></pre></td></tr></table></figure></p><p>我们看到eth0的模块名称是 e1000.<br> ethtool -i eth0 命令也可以查看eth0的内核模块名。<br>下面我们卸载模块 然后重新加载模块。我们的修改就生效了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modprobe -r e1000  卸载</span><br><span class="line">modprobe  e1000    加载</span><br></pre></td></tr></table></figure></p><p>注意:卸载其实是从内存里移除了，并不是删除。<br>我们通过命令 locate e1000 可以查看内核模块文件。</p><h2 id="centos7网卡采用传统的命名方式"><a href="#centos7网卡采用传统的命名方式" class="headerlink" title="centos7网卡采用传统的命名方式"></a>centos7网卡采用传统的命名方式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/default/grub</span><br></pre></td></tr></table></figure><p>修改<br>GRUB_CMDLINE_LINUX=”rhgb quiet net.ifnames=0”<br>执行<br><figure class="highlight plain"><figcaption><span>-o</span><a href="/etc/grub2.cfg```">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">重启</span><br><span class="line">## 添加一个IP地址ifconfig</span><br><span class="line"> ifconfig -a  查看所有ip信息</span><br><span class="line"> ifconfig eth0 down /up  停止网卡  启动网卡aa</span><br><span class="line"> 那么如何修改网卡的ip地址</span><br></pre></td></tr></table></figure></p><p> ifconfig eth1 172.20.59.205/24<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">网卡别名 eth1:1 ip 地址是 172.20.59.205/24</span><br><span class="line">``` bash</span><br><span class="line">ifconfig eth1:0 172.20.59.205/24</span><br></pre></td></tr></table></figure></p><p>如何在重启电脑后仍然可以生效呢<br>我们编辑文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">cd</span> /etc/sysconfig/network-scripts/</span><br><span class="line"> cp  ifcfg-eth0 ifcfg-eth0:1</span><br><span class="line"> vim ifcfg-eth0:1</span><br><span class="line"> [root@centos6 network-scripts]<span class="comment"># vim ifcfg-eth0:1</span></span><br><span class="line">UUID=539cec12d-02c8-44a9-9ca4-453069e071dc</span><br><span class="line">DEVICE=eth0:1  设备名最好跟文件名称一一对应</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">ONBOOT=yes     是否激活</span><br><span class="line">NM_CONTROLLED=yes</span><br><span class="line">BOOTPROTO=none    不要动态获取</span><br><span class="line">HWADDR=00:0C:29:86:58:63  这个网卡地址不要动</span><br><span class="line">IPADDR=172.22.68.210   </span><br><span class="line">NETMASK=255.255.255.0  或者 PREFIX=24(推荐)</span><br></pre></td></tr></table></figure></p><p>这种添加方式也可以   via 后边的代表网关<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10.0.0.8/16 via 192.168.32.100</span><br></pre></td></tr></table></figure></p><p>然后从其服务<br>service network restart<br>service NetworkManager restart<br>ifconfig -a<br>通过这个命令禁用网卡<br>ifconfig eth0:1 down<br>要想启用执行<br>ifconfig eth0:1 up<br>执行ip a 我们也可以查看网卡信息比ifconfig 更详细，更友好。</p><p>还有可以使用tcpdump -i eth0 -nn icmp 抓取通过eth0网卡的数据包信息。</p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p> route -n 可以查看路由，我们在添加ip地址的时候可以配置网关，目的就是配置路由。<br> <code>没有路由就不能跟其他网段的主机通信这一点很关键，即便是本网段也不能通信</code><br> 我们添加一个ip地址，他就会在默认路由表里添加一条路由，以便跟本网段的其他主机通信。<br> 那么如何对路由的增删改呢？<br>route add<br>-net  增加一个网段<br>-host  增加某一台主机<br>我们在一台主机上新增一个ip地址<br>然后再另外一台主机上去ping 这个地址是不行的，虽然连接再同一个交换机上，但是由于没有配置路由，而且网段不同，所以他们之间不能互相通信。<br><strong>新增路由</strong><br>给网卡接口eth0 增加一个路由 目的网段是192.168.0.1 子网掩码 255.255.0.0 网关 172.16.0.1<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route add  -net  192.168.0.1/16 gw 172.16.0.1 dev eth0</span><br></pre></td></tr></table></figure></p><p><strong>添加到主机的路由</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">route add –host 192.168.1.11 dev eth0</span><br><span class="line">route add –host 192.168.1.12 gw 192.168.1.1</span><br></pre></td></tr></table></figure></p><p><strong>添加到网络的路由</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">route add –net 192.168.1.11 netmask 255.255.255.0 dev eth0</span><br><span class="line">route add –net 192.168.1.11 netmask 255.255.255.0 gw 192.168.1.1</span><br><span class="line">route add –net 192.168.1.0/24 dev eth1</span><br></pre></td></tr></table></figure></p><p><strong>添加默认网关</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route add default gw 192.168.2.1</span><br></pre></td></tr></table></figure></p><p>强制用某个IP ping<br>ping -I 1.1.1.1 2.2.2.2 强制使用1.1.1.1 去ping 2.2.2.2<br>DNS 配置文件 /etc/resolv.conf<br>在网卡配置文件中加上DOMAIN baidu.com<br>直接ping www 就可以了<br><strong>实验如下图我们要让A，B 2个主机通信</strong><br> <img src="/Linux/routeTest.png" alt="logo"><br> 假设中间有3个路由器，其中2个网段分别是VMNET6,VMNET7.把他们分隔开，表示不同的网段。<br> 要想让2个主机通信，我们先按上图把环境配好。直连的都处于同一个网段，我们在添加ip的时候自动会添加同一个网段的路由，所以他们之间是可以通信的。</p><ol><li>配置每个主机，路由器的IP地址<br><strong>配置主机A：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth1 172.20.112.25/16</span><br><span class="line">route add default 172.20.113.26 配置网关 这样就可以跟R1的任何ip通信了。</span><br></pre></td></tr></table></figure></li></ol><p><strong>配置R1 eth0</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 172.20.113.26/16</span><br></pre></td></tr></table></figure></p><p><strong>配置R1 eth1</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth1 10.1.1.10/16</span><br><span class="line">route add default gw 10.1.1.11</span><br></pre></td></tr></table></figure></p><p>同时要把R1的路由功能启用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure></p><p>cat /etc/sysctl.conf 写入这个文件永久保存</p><p><strong>配置R2</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 10.2.2.10/16 --eth0</span><br><span class="line">ifconfig eth1 10.1.1.11/16 --eth1</span><br><span class="line">route add default gw 10.2.2.11</span><br></pre></td></tr></table></figure></p><p><strong>配置R3：</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth1 10.2.2.11/16 --eth1</span><br><span class="line">ifconfig eth0 192.168.200.131/24 --eth0</span><br></pre></td></tr></table></figure></p><p><strong>配置主机B：</strong></p><ol start="2"><li>相邻的测试看看是否可以ping通 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig ens33 192.168.200.132/24</span><br><span class="line"> route add default gw 192.168.200.131 配置网关 这样就可以跟R3的任何ip通信了。</span><br></pre></td></tr></table></figure></li></ol><p>经过测试相邻路由器跟主机之间是可以通信的</p><p>接下来我们怎么才能让A能到B呢<br>我们从图上可以看出<br>对于R1来说到达任何地址的网关都是10.1.1.11<br>route add default gw 10.1.1.11<br>R2需要配2个<br>route add default gw 10.1.1.10<br>route add default gw 10.2.2.11<br>R3到达任何地址的网关都是10.2.2.10<br>route add default gw 10.2.2.10<br>这样就都关联起来了<br>折腾了半天是因为防火墙问题<br>需要执行iptables -F</p><p>终于成功！<br> <img src="/Linux/routeSuccess.png" alt="logo"><br>以上的所有的ip配置要想生效需要写到配置文件里。/etc/sysconfig/network-Scripts/ifcfg-eth0 或者 eth1中。<br><strong>路由配置文件</strong></p><ol><li><p>写到/etc/rc.local 文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route add default gw 10.2.2.10</span><br></pre></td></tr></table></figure></li><li><p>/etc/sysconfig/static-routes配置(推荐)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim  /etc/sysconfig/static-routes</span><br><span class="line">any net  192.168.15.0/24   gw 192.168.14.254</span><br><span class="line">any host 123.57.223.144    gw 192.168.14.254</span><br></pre></td></tr></table></figure></li></ol><p>注意：static-routes默认不存在<br>补充：<br>模拟给一块网卡配置2个IP，充当路由器，然后让2台不同网段的计算机分别指向对应的网关。这2台计算机也能通信。</p><h2 id="bonding"><a href="#bonding" class="headerlink" title="bonding"></a>bonding</h2><p>bonding(绑定)是一种linux系统下的网卡绑定技术，可以把服务器上n个物理网卡在系统内部抽象(绑定)成一个逻辑上的网卡，能够提升网络吞吐量、实现网络冗余、负载等功能，有很多优势。</p><p>bonding技术是linux系统内核层面实现的，它是一个内核模块(驱动)。使用它需要系统有这个模块, 我们可以modinfo命令查看下这个模块的信息, 一般来说都支持.</p><p>bonding的七种工作模式: </p><p>bonding技术提供了七种工作模式，在使用的时候需要指定一种，每种有各自的优缺点.</p><ol><li>balance-rr (mode=0)       默认, 有高可用 (容错) 和负载均衡的功能,  需要交换机的配置，每块网卡轮询发包 (流量分发比较均衡).</li><li>active-backup (mode=1)  只有高可用 (容错) 功能, 不需要交换机配置, 这种模式只有一块网卡工作, 对外只有一个mac地址。缺点是端口利用率比较低</li><li>balance-xor (mode=2)     不常用</li><li>broadcast (mode=3)        不常用</li><li>802.3ad (mode=4)          IEEE 802.3ad 动态链路聚合，需要交换机配置，没用过</li><li>balance-tlb (mode=5)      不常用</li><li><p>balance-alb (mode=6)     有高可用 ( 容错 )和负载均衡的功能，不需要交换机配置  (流量分发到每个接口不是特别均衡)<br>服务器上两张物理网卡ens33和ens37, 通过绑定成一个逻辑网卡bond0，bonding模式选择mode6<br><strong>实现bonding</strong><br>可以使用lsmod | grep bonding查看模块是否被加载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep bonding</span><br></pre></td></tr></table></figure></li><li><p>创建基于bond0接口的配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-bond0</span><br><span class="line">DEVICE=bond0</span><br><span class="line">TYPE=Bond</span><br><span class="line">IPADDR=172.20.59.100</span><br><span class="line">NETMASK=255.255.0.0</span><br><span class="line">DNS1=114.114.114.114</span><br><span class="line">USERCTL=no</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">ONBOOT=yes</span><br><span class="line">BONDING_MASTER=yes</span><br><span class="line">BONDING_OPTS=<span class="string">"mode=6 miimon=100"</span></span><br></pre></td></tr></table></figure></li></ol><p>上面的BONDING_OPTS=”mode=6 miimon=100” 表示这里配置的工作模式是mode6(adaptive load balancing), miimon表示监视网络链接的频度 (毫秒), 我们设置的是100毫秒, 根据你的需求也可以指定mode成其它的负载模式。</p><ol start="2"><li>修改ens33<br>DEVICE=ens33<br>USERCTL=no<br>ONBOOT=yes<br>MASTER=bond0<br>SLAVE=yes<br>BOOTPROTO=none</li><li>修改ens37<br>DEVICE=ens37<br>USERCTL=no<br>ONBOOT=yes<br>MASTER=bond0<br>SLAVE=yes<br>BOOTPROTO=none</li><li>我们关掉一个网卡，依然可以ping通<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping 172.20.59.100</span><br></pre></td></tr></table></figure></li></ol><h2 id="nmcli-使用"><a href="#nmcli-使用" class="headerlink" title="nmcli 使用"></a>nmcli 使用</h2><h2 id="网络客户端工具"><a href="#网络客户端工具" class="headerlink" title="网络客户端工具"></a>网络客户端工具</h2><p>ftp  lftp wget links<br>wget :<br>-q 静默模式<br>-c 断点续传<br>-P保存在指定目录<br>-O 保存为指定的文件名<br>links:<br>–dump 只显示文字<br>–source </p><h2 id="测试网络工具"><a href="#测试网络工具" class="headerlink" title="测试网络工具"></a>测试网络工具</h2><p>ping  mtr ip route  nslookup traceroute tracepath </p><h2 id="网络组"><a href="#网络组" class="headerlink" title="网络组"></a>网络组</h2>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络配置 </tag>
            
            <tag> TCPIP穿透 </tag>
            
            <tag> ARP </tag>
            
            <tag> tcp三次握手 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Raid详解</title>
      <link href="/2018/08/20/linuxRaid/"/>
      <url>/2018/08/20/linuxRaid/</url>
      
        <content type="html"><![CDATA[<blockquote><p> <div align="center"><img src="/Linux/raid.jpg" alt="logo"></div><br>在Linux系统中目前以MD (Multiple Devices)虚拟块设备的方式实现软件RAID，利用多个底层的块设备虚拟出一个新的虚拟块设备，并且利用条带化(stripping)技术将数据块均匀分布到多个磁盘上来提高虚拟设备的读写性能，利用不同的数据冗余算法来保护用户数据不会因为某个块设备的故障而完全丢失，而且还能在设备被替换后将丢失的数据恢复到新的设备上。<br>RAID：（Redundant Array of indenpensive Disk） 廉价磁盘冗余阵列: 磁盘阵列是把多个磁盘组成一个阵列,当作单一磁盘使用,它将数据以分段(striping)的方式储存在不同的磁盘中,存取数据时,阵列中的相关磁盘一起动作,大幅减低数据的存取时间,同时有更佳的空间利用率。磁盘阵列利用的不同的技术,称为RAID level,不同的level针对不同的系统及应用,以解决数据安全的问题。简单来说，RAID把多个硬盘组合成为一个逻辑扇区，因此，操作系统只会把它当作一个硬盘。</p></blockquote><a id="more"></a><h1 id="raid分类"><a href="#raid分类" class="headerlink" title="raid分类"></a><font color="#339966">raid分类</font></h1><p>  一般高性能的磁盘阵列都是以硬件的形式来达成,进一步的把磁盘存取控制及磁盘阵列结合在一个控制器(RAID controler)或控制卡上,针对不同的用户解决人们对磁盘输输入输出系统的四大要求:<br>  (1)增加存取速度,<br>  (2)容错(fault tolerance),即安全性<br>  (3)有效的利用磁盘利用率;<br>  (4)尽量的平衡CPU,内存及磁盘的性能差异,提高主机的整体工作性能。</p><p><strong>RAID分类:</strong><br>系统中一般已经将MD驱动模块直接编译到内核中或编译为可动态加载的驱动模块</p><ol><li>硬件RAID：用RAID接口卡来实现；需要内核支持其驱动，并且该类设备设备显示为SCSI设备，代号为/dev/sd*;</li><li>软件RAID：用内核中的MD(multiple devices)模块实现，该类设备在/etc/下表示为：md*；</li></ol><p><strong>几种常见的RAID类型</strong></p><p> <table margintop="0px"><tr><td> <img src="/Linux/raid0.png" alt="logo"></td><td> <img src="/Linux/raid1.png" alt="logo"><br> </td></tr><tr><td> <img src="/Linux/raid5.png" alt="logo"></td><td> <img src="/Linux/raid6.png" alt="logo"></td></tr><br> <tr><td><img src="/Linux/raid10.png" alt="logo"> </td><td><img src="/Linux/raid01.png" alt="logo"> </td></tr><tr><td><img src="/Linux/raid50.png" alt="logo"> </td></tr><br> </table></p><ol><li>RAID-0striping（条带模式），至少需要两块磁盘，做RAID分区的大小最好是相同的（可以充分发挥并优势）;而数据分散存储于不同的磁盘上，在读写的时候可以实现并发，所以相对其读写性能最好；但是没有容错功能，任何一个磁盘的损坏将损坏全部数据；</li><li>RAID-1mirroring（镜像卷），至少需要两块硬盘，raid大小等于两个raid分区中最小的容量（最好将分区大小分为一样），可增加热备盘提供一定的备份能力；数据有冗余，在存储时同时写入两块硬盘，实现了数据备份；但相对降低了写入性能，但是读取数据时可以并发，几乎类似于raid-0的读取效率；</li><li>RAID-5需要三块或以上硬盘，可以提供热备盘实现故障的恢复；采用奇偶效验，可靠性强，且只有同时损坏两块硬盘时数据才会完全损坏，只损坏一块硬盘时，系统会根据存储的奇偶校验位重建数据，临时提供服务；此时如果有热备盘，系统还会自动在热备盘上重建故障磁盘上的数据；</li><li>RAID10:至少需要4块硬盘，读写性能提升，每组镜像最多只能坏一块。</li><li>多块磁盘先实现RAID5,再组合成RAID0</li></ol><h1 id="mdadm工具介绍"><a href="#mdadm工具介绍" class="headerlink" title="mdadm工具介绍"></a><font color="#339966">mdadm工具介绍</font></h1><p> 对上面几种常用的RAID类型分析后，可知，RAID-0主要可以提高磁盘性能，RAID-1主要可以实现备份容错（RAID-5由于控制机制复杂在此暂不使用），所以可以在实际生产环境下考虑结合RAID-0和RAID-1来实现磁盘存储系统的高性能、高容错。<br> <strong>基本语法</strong><br> mdadm [mode] <raid-device> [options] <component-devices></component-devices></raid-device></p><p> mode:<br>   Assemble：装配模式：加入一个以前定义的阵列；可以使挺值得阵列或从其他主机移出的阵列<br>   Build：  创建：创建一个没有超级块的阵列<br>   Create：使用空闲的设备创建一个新的阵列，每个设备具有元数据块<br>   Follow or Monitor: 监控RAID的状态，一般只对RAID-1/4/5/6/10等有冗余功能的模式来使用<br>   Grow：(Grow or shrink) 改变RAID的容量或阵列中的设备数目；收缩一般指的是数据收缩或重建；<br>   Manage： 管理阵列(如添加spare盘和删除故障盘)<br>   Incremental Assembly：添加一个设备到一个适当的阵列。<br>   Misc：  允许单独对阵列中的某个设备进行操作(如抹去superblocks 或停止阵列)<br>   Auto-detect： 此模式不作用于特定的设备或阵列，而是要求在Linux内核启动任何自动检测到的阵列。</p><p>options:<br>    -A, –assemble： 加入并开启一个以前定义的阵列<br>    -B, –build：   创建一个没有超级块的阵列(Build a legacy array without superblocks.)<br>    -C, –create：  创建一个新的阵列<br>    -F, –follow, –monitor：选择监控(Monitor)模式<br>    -G, –grow：   改变激活阵列的大小或形态<br>    -I, –incremental： 添加一个单独的设备到合适的阵列，并可能启动阵列<br>    –auto-detect：   请求内核启动任何自动检测到的阵列</p><p>用法：在磁盘分区sdb1,sdc1,sdb1 上建立名称为md0 的raid1<br>mdadm -C /dev/md0 -a yes -l 5 -n 3 /dev/sd{b,c,d}1<br>      -C ：创建一个阵列，后跟阵列名称<br>      -l ：指定阵列的级别；<br>      -n ：指定阵列中活动devices的数目<br>      -A ：装配<br>      -F ：监控<br>      -f ：标记指定磁盘为损坏<br>      -r：  移除磁盘<br>      -a ： 添加磁盘<br>      -a {yes|no} 自动创建目标RAID设备的设备文件</p><h1 id="创建一个RAID的基本过程"><a href="#创建一个RAID的基本过程" class="headerlink" title="创建一个RAID的基本过程"></a><font color="#339966">创建一个RAID的基本过程</font></h1><p><strong>为磁盘划分分区并指定raid设备</strong><br>    linux中阵列组成单元是分区，分区可以是整个设备也可以是设备多个分区中的一个；在fdisk分区后需要将分区标志改为raid 8e类型。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># lsblk</span></span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sr0     11:0    1  3.7G  0 rom  </span><br><span class="line">sda      8:0    0  200G  0 disk </span><br><span class="line">├─sda1   8:1    0    1G  0 part /boot</span><br><span class="line">├─sda2   8:2    0 48.8G  0 part /</span><br><span class="line">├─sda3   8:3    0 29.3G  0 part /data</span><br><span class="line">├─sda4   8:4    0    1K  0 part </span><br><span class="line">└─sda5   8:5    0    2G  0 part [SWAP]</span><br><span class="line">sdc      8:32   0   20G  0 disk </span><br><span class="line">sdb      8:16   0   20G  0 disk</span><br></pre></td></tr></table></figure></p><p>我们分别从sdb,sdc里分出1G来创建raid设备.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># fdisk /dev/sdb</span></span><br><span class="line"></span><br><span class="line">WARNING: DOS-compatible mode is deprecated. It<span class="string">'s strongly recommended to</span></span><br><span class="line"><span class="string">         switch off the mode (command '</span>c<span class="string">') and change display units to</span></span><br><span class="line"><span class="string">         sectors (command '</span>u<span class="string">').</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Command (m for help): n</span></span><br><span class="line"><span class="string">Command action</span></span><br><span class="line"><span class="string">   e   extended</span></span><br><span class="line"><span class="string">   p   primary partition (1-4)</span></span><br><span class="line"><span class="string">p</span></span><br><span class="line"><span class="string">Partition number (1-4): 1</span></span><br><span class="line"><span class="string">First cylinder (1-2610, default 1): </span></span><br><span class="line"><span class="string">Using default value 1</span></span><br><span class="line"><span class="string">Last cylinder, +cylinders or +size&#123;K,M,G&#125; (1-2610, default 2610): +1G</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Command (m for help): t</span></span><br><span class="line"><span class="string">Selected partition 1</span></span><br><span class="line"><span class="string">Hex code (type L to list codes): fd  指定raid标识</span></span><br><span class="line"><span class="string">Changed system type of partition 1 to fd (Linux raid autodetect)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Command (m for help): p</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Disk /dev/sdb: 21.5 GB, 21474836480 bytes</span></span><br><span class="line"><span class="string">255 heads, 63 sectors/track, 2610 cylinders</span></span><br><span class="line"><span class="string">Units = cylinders of 16065 * 512 = 8225280 bytes</span></span><br><span class="line"><span class="string">Sector size (logical/physical): 512 bytes / 512 bytes</span></span><br><span class="line"><span class="string">I/O size (minimum/optimal): 512 bytes / 512 bytes</span></span><br><span class="line"><span class="string">Disk identifier: 0x7d9e381f</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Device Boot      Start         End      Blocks   Id  System</span></span><br><span class="line"><span class="string">/dev/sdb1               1         132     1060258+  fd  Linux raid autodetect</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Command (m for help): w</span></span><br><span class="line"><span class="string">The partition table has been altered!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Calling ioctl() to re-read partition table.</span></span><br><span class="line"><span class="string">Syncing disks.</span></span><br><span class="line"><span class="string">``` </span></span><br><span class="line"><span class="string">接下来sdc 我们直接用sdb 复制就可以了 </span></span><br><span class="line"><span class="string">``` bash</span></span><br><span class="line"><span class="string">dd if=/dev/sdb of=/dev/sdc bs=1 count=66 skip=446 seek=446  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">lsblk 发现没有sdc1 分区，应该是分区没有同步的原因</span></span><br><span class="line"><span class="string">[root@centos6 ~]# lsblk</span></span><br><span class="line"><span class="string">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span></span><br><span class="line"><span class="string">sr0     11:0    1  3.7G  0 rom  </span></span><br><span class="line"><span class="string">sda      8:0    0  200G  0 disk </span></span><br><span class="line"><span class="string">├─sda1   8:1    0    1G  0 part /boot</span></span><br><span class="line"><span class="string">├─sda2   8:2    0 48.8G  0 part /</span></span><br><span class="line"><span class="string">├─sda3   8:3    0 29.3G  0 part /data</span></span><br><span class="line"><span class="string">├─sda4   8:4    0    1K  0 part </span></span><br><span class="line"><span class="string">└─sda5   8:5    0    2G  0 part [SWAP]</span></span><br><span class="line"><span class="string">sdc      8:32   0   20G  0 disk </span></span><br><span class="line"><span class="string">sdb      8:16   0   20G  0 disk </span></span><br><span class="line"><span class="string">└─sdb1   8:17   0    1G  0 part</span></span><br></pre></td></tr></table></figure></p><p>我们执行同步分区命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">partx -a /dev/sdc</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># lsblk</span></span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sr0     11:0    1  3.7G  0 rom  </span><br><span class="line">sda      8:0    0  200G  0 disk </span><br><span class="line">├─sda1   8:1    0    1G  0 part /boot</span><br><span class="line">├─sda2   8:2    0 48.8G  0 part /</span><br><span class="line">├─sda3   8:3    0 29.3G  0 part /data</span><br><span class="line">├─sda4   8:4    0    1K  0 part </span><br><span class="line">└─sda5   8:5    0    2G  0 part [SWAP]</span><br><span class="line">sdc      8:32   0   20G  0 disk </span><br><span class="line">└─sdc1   8:33   0    1G  0 part    出来了</span><br><span class="line">sdb      8:16   0   20G  0 disk </span><br><span class="line">└─sdb1   8:17   0    1G  0 part</span><br></pre></td></tr></table></figure><p>上边我们把raid分区给做好了，接下来我们把他们逻辑的组合在一起，创建磁盘阵列。<br><strong>建立磁盘阵列</strong><br>创建由分区sdb1,sdc1组成的设备名称为md0,raid 级别为raid0。<br>如果是raid5  mdadm -C /dev/md0 -a yes -l 5 -n 4 -x 1  /dev/sdb1 /dev/sdc1 /dev/sdd1  /dev/sde1<br>用-x 指定备用设备<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">      [root@centos6 ~]<span class="comment"># mdadm -C /dev/md0 -a yes -l 0 -n 2 /dev/sdb1 /dev/sdc1</span></span><br><span class="line">        mdadm: /dev/sdb1 appears to be part of a raid array:</span><br><span class="line">            level=raid0 devices=0 ctime=Thu Jan  1 08:00:00 1970</span><br><span class="line">        mdadm: partition table exists on /dev/sdb1 but will be lost or</span><br><span class="line">            meaningless after creating array</span><br><span class="line">        Continue creating array? Y</span><br><span class="line">        mdadm: Defaulting to version 1.2 metadata</span><br><span class="line">        mdadm: array /dev/md0 started.</span><br><span class="line">``` </span><br><span class="line">下面命令可以把文件系统给删掉</span><br><span class="line">``` bash</span><br><span class="line"> dd <span class="keyword">if</span>=/dev/zero of=/dev/sdb1</span><br></pre></td></tr></table></figure></p><p><strong>使用mdadm检查RAID设备的状况</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mdadm --detail /dev/md0</span><br><span class="line">或者</span><br><span class="line">mdadm -D /dev/md0</span><br></pre></td></tr></table></figure></p><p> mdadm -Ds /dev/md0<br><strong>看内核是否以模块的形式已经加载MD驱动</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    cat /proc/mdstat  </span><br><span class="line">```   </span><br><span class="line">或者</span><br><span class="line">cat /proc/devices是否有md块设备 </span><br><span class="line">``` bash</span><br><span class="line">cat /proc/devices |grep md</span><br></pre></td></tr></table></figure></p><p>或者查看MD是否以模块形式加载到系统中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep md</span><br></pre></td></tr></table></figure></p><p><strong>mdadm.conf是该软件的默认配置文件，以确保下次启动后开启阵列</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">echo</span> <span class="string">"DEVICE /dev/sdb1 /dev/sdc1"</span> &gt;&gt; /etc/mdadm.conf  </span><br><span class="line">    或者</span><br><span class="line">    mdadm -Ds /dev/md0 &gt;&gt; /etc/mdadm.conf  </span><br><span class="line">```  </span><br><span class="line">**用文件系统对每个RAID设备进行格式化**</span><br><span class="line">``` bash</span><br><span class="line">      mkfs.ext4 /dev/md0</span><br><span class="line">      或者</span><br><span class="line">      mkfs.xfs  /dev/md0</span><br></pre></td></tr></table></figure></p><p><strong>创建完文件系统以后我们就可以查看了</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">blkid /dev/md0</span><br><span class="line">/dev/md0: UUID=<span class="string">"e8141423-f8e8-485a-9d15-3e548839f7b9"</span> TYPE=<span class="string">"ext4"</span> </span><br><span class="line">``` </span><br><span class="line">**给raid设备新增加一块硬盘后同步文件系统**</span><br><span class="line">``` bash</span><br><span class="line">xfs_growfs /mnt/raid5</span><br></pre></td></tr></table></figure></p><p>如果是ext 系列的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resize2fs /dev/sd5</span><br></pre></td></tr></table></figure></p><p><strong>挂载md0到/mnt/raid0目录下</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mnt/raid0</span><br></pre></td></tr></table></figure></p><p>如果要永久挂载，我们要写入etc/fstab文件中<br>vim /etc/fstab文件中<br>:r!blkid /dev/md0<br>UUID=e8141423-f8e8-485a-9d15-3e548839f7b9       /mnt/raid0  ext4 0 0<br>wq 保存退出。<br>然后执行  mount -a 挂载</p><p><strong>执行df -h 查看</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 raid0]<span class="comment"># df -h</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sda2        48G  4.4G   42G  10% /</span><br><span class="line">tmpfs           995M   72K  995M   1% /dev/shm</span><br><span class="line">/dev/sda1       976M   39M  887M   5% /boot</span><br><span class="line">/dev/sda3        29G   83M   28G   1% /data</span><br><span class="line">/dev/md0        2.0G  3.1M  1.9G   1% /mnt/raid0   2G</span><br></pre></td></tr></table></figure></p><p><strong>测试raid的性能</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">选项 conv=fdatasync  避免使用缓存</span><br><span class="line">[root@centos6 raid0]<span class="comment"># dd if=/dev/zero of=/mnt/raid0/f1 bs=1M count=1024  conv=fdatasync </span></span><br><span class="line">1024+0 records <span class="keyword">in</span></span><br><span class="line">1024+0 records out</span><br><span class="line">1073741824 bytes (1.1 GB) copied, 12.5683 s, 85.4 MB/s</span><br></pre></td></tr></table></figure></p><h1 id="磁盘阵列的管理"><a href="#磁盘阵列的管理" class="headerlink" title="磁盘阵列的管理"></a><font color="#339966">磁盘阵列的管理</font></h1><p><strong>查看raid</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm -D /dev/md0</span><br></pre></td></tr></table></figure></p><p><strong>增加新的成员</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mdadm /dev/md0 –a /dev/sdb1</span><br><span class="line">mdadm –G /dev/md0 –n4 -a /dev/sde1</span><br></pre></td></tr></table></figure></p><p><strong>模拟故障</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm /dev/md0 -f /dev/sdb1</span><br></pre></td></tr></table></figure></p><p><strong>移除磁盘</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm /dev/md0 –r /dev/sdb1</span><br></pre></td></tr></table></figure></p><p><strong>停止某个整列</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm -S /dev/md0</span><br></pre></td></tr></table></figure></p><p><strong>开启raid</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm -As  /dev/md0</span><br></pre></td></tr></table></figure></p><p><strong>删除阵列</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.umount /mnt/raid0   </span><br><span class="line">2.mdadm -Ss /mnt/raid0  </span><br><span class="line">3.mdadm --zero-superblock /dev/sd&#123;b,c&#125;1  清掉磁盘上的raid信息，表示是一个干净的硬盘</span><br><span class="line">4.rm /etc/mdadm.conf  </span><br><span class="line">5.同时要删除etc/fstab 文件中的raid配置</span><br></pre></td></tr></table></figure></p><h1 id="总结raid5的创建过程"><a href="#总结raid5的创建过程" class="headerlink" title="总结raid5的创建过程"></a>总结raid5的创建过程</h1><ol><li>准备5个分区(fd)或硬盘</li><li>mdadm -C /dev/md5 -a yes -l 5 -n 4 -x 1 /dev/sd{b,c,d,e}1 /dev/sdf </li><li>mkfs.ext4 /dev/md5</li><li><p>mount /dev/md5 /mnt/raid </p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1></li></ol><blockquote><p>实现raid10 的2种方法</p><ol><li>先创建2个raid0<br>mdadm -C /dev/md0 -a yes -l 1 -n 2 /dev/sd{b,c}1<br>mdadm -C /dev/md1 -a yes -l 1 -n 2 /dev/sd{e,f}1<br>然后把2个组合起来创建raid1<br>mdadm -C /dev/md2 -a yes -l 0 -n 2 /dev/md{0,1} </li><li>一步创建<br>mdadm -C /dev/md0 -a yes -l10 -n 2 /dev/sd{b,c,e,f}1 </li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Raid </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux逻辑卷</title>
      <link href="/2018/08/19/linux%E9%80%BB%E8%BE%91%E5%8D%B7/"/>
      <url>/2018/08/19/linux%E9%80%BB%E8%BE%91%E5%8D%B7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>  LVM是 Logical Volume Manager(逻辑卷管理)的简写，它由Heinz Mauelshagen在Linux 2.4内核上实现。LVM将一个或多个硬盘的分区在逻辑上集合，相当于一个大硬盘来使用，当硬盘的空间不够使用的时候，可以继续将其它的硬盘的分区加入其中，这样可以实现磁盘空间的动态管理，相对于普通的磁盘分区有很大的灵活性。</p><p>与传统的磁盘与分区相比，LVM为计算机提供了更高层次的磁盘存储。它使系统管理员可以更方便的为应用与用户分配存储空间。在LVM管理下的存储卷可以按需要随时改变大小与移除(可能需对文件系统工具进行升级)。LVM也允许按用户组对存储卷进行管理，允许管理员用更直观的名称(如”sales’、 ‘development’)代替物理磁盘名(如’sda’、’sdb’)来标识存储卷。</p></blockquote><a id="more"></a><h1 id="什么是逻辑卷"><a href="#什么是逻辑卷" class="headerlink" title="什么是逻辑卷"></a>什么是逻辑卷</h1><blockquote><p>逻辑卷基本术语</p></blockquote><p> 前面谈到，LVM是在磁盘分区和文件系统之间添加的一个逻辑层，来为文件系统屏蔽下层磁盘分区布局，提供一个抽象的盘卷，在盘卷上建立文件系统。首先我们讨论以下几个LVM术语：</p><p>物理存储介质（The physical media）：这里指系统的存储设备：硬盘，如：/dev/hda1、/dev/sda等等，是存储系统最低层的存储单元。<br>    物理卷（physical volume）：物理卷就是指硬盘分区或从逻辑上与磁盘分区具有同样功能的设备(如RAID)，是LVM的基本存储逻辑块，但和基本的物理存储介质（如分区、磁盘等）比较，却包含有与LVM相关的管理参数。<br>    卷组（Volume Group）：LVM卷组类似于非LVM系统中的物理硬盘，其由物理卷组成。可以在卷组上创建一个或多个“LVM分区”（逻辑卷），LVM卷组由一个或多个物理卷组成。<br>    逻辑卷（logical volume）：LVM的逻辑卷类似于非LVM系统中的硬盘分区，在逻辑卷之上可以建立文件系统(比如/home或者/usr等)。<br>    PE（physical extent）：每一个物理卷被划分为称为PE(Physical Extents)的基本单元，具有唯一编号的PE是可以被LVM寻址的最小单元。PE的大小是可配置的，默认为4MB。<br>    LE（logical extent）：逻辑卷也被划分为被称为LE(Logical Extents) 的可被寻址的基本单位。在同一个卷组中，LE的大小和PE是相同的，并且一一对应。<br>    简单来说就是：<br>    PV:是物理的磁盘分区<br>    VG:LVM中的物理的磁盘分区，也就是PV，必须加入VG，可以将VG理解为一个仓库或者是几个大的硬盘。<br>    LV：也就是从VG中划分的逻辑分区</p><h1 id="创建跟管理LVM"><a href="#创建跟管理LVM" class="headerlink" title="创建跟管理LVM"></a>创建跟管理LVM</h1><ol><li>创建分区<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># fdisk /dev/sdb</span></span><br><span class="line"> WARNING: DOS-compatible mode is deprecated. It<span class="string">'s strongly recommended to</span></span><br><span class="line"><span class="string">    switch off the mode (command '</span>c<span class="string">') and change display units to</span></span><br><span class="line"><span class="string">    sectors (command '</span>u<span class="string">').</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   Command (m for help): n</span></span><br><span class="line"><span class="string">   Command action</span></span><br><span class="line"><span class="string">   l   logical (5 or over)</span></span><br><span class="line"><span class="string">   p   primary partition (1-4)</span></span><br><span class="line"><span class="string">   p   选主分区</span></span><br><span class="line"><span class="string">   Selected partition 4</span></span><br><span class="line"><span class="string">   First cylinder (92-2610, default 92): </span></span><br><span class="line"><span class="string">   Using default value 92</span></span><br><span class="line"><span class="string">   Last cylinder, +cylinders or +size&#123;K,M,G&#125; (92-262, default 262): +500M   500M大小</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   Command (m for help): t</span></span><br><span class="line"><span class="string">   Partition number (1-5): 3</span></span><br><span class="line"><span class="string">   Hex code (type L to list codes): 8e</span></span><br><span class="line"><span class="string">   Changed system type of partition 3 to 8e (Linux LVM)</span></span><br></pre></td></tr></table></figure></li></ol><p>一定要指定分区的格式为8e，这是LVM的分区格式</p><ol start="2"><li>创建PV<br>pvdisplay 查看当前存在的pv<br>pvcreate /dev/sdb</li><li>创建VG<br>vgdisplay 查看当前存在的pv<br>vgcreate  volueGroupName /dev/sdb<br>创建完成VG之后，才能从VG中划分一个LV。</li><li>创建LV<br>lvcreate -L 100M -n lvData volueGroupName<br>lvdisplay 查看lv信息<br>创建了一个名字为lvData，容量大小是100M的分区，其中：-L：指定LV的大小 -n：指定LV的名。Vo1Group00：表示从这个VG中划分LV。</li><li>LV格式化及挂载<br>下一步需要对LV进行格式化（使用mksf进行格式化操作），然后LV才能存储资料<br>mkfs -t ext3 /dev/volueGroupName/lvData<br>格式化以后/dev/volueGroupName/lvData 就跟普通目录一样可以存储数据了。</li><li>挂载<br>mount /dev/volueGroupName/lvData /data/test/<br>如果要保存，防止系统重启后失效<br>我们将配置写入etc/fstab 文件中</li></ol><h1 id="扩容LVM分区"><a href="#扩容LVM分区" class="headerlink" title="扩容LVM分区"></a>扩容LVM分区</h1><ol><li>首先创建一块新的分区：</li></ol><p>fdisk  /dev/sde<br>n<br>l     #选择逻辑分区，如果没有，则首先创建扩展分区，然后再添加逻辑分区（硬盘：最多四个主分区，1个扩展分区，多个逻辑分区）<br>6      #分区号（从5开始），/dev/sde<br>t      8e   #分区类型8e表示LVM分区<br>w      #写入分区表<br>partprobe   #同步分区表<br>mkfs –t ext3 /dev/sde #格式化<br>partx /dev/sde #查看当前硬盘的分区表及使用情况</p><ol start="2"><li>创建PV，扩容VG，LV</li></ol><p>pvcreate /dev/sde<br>vgdisplay #查看当前已经存在的VG信息，以存在VG：VolGroup00为例<br>vgextend VolGroup00 /dev/sde    #扩展VolGroup00<br>lvdisplay #查看已经存在的LV信息，以存在LV：LogVol01为例<br>lvextend –L 1G /dev/VolGroup00/LogVol01 #扩展LV<br>resize2fs /dev/VolGroup00/LogVol01 #执行该重设大小，对于当前正在使用的LogVol01有效<br>df –h #查看挂载情况，已经扩容</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逻辑卷 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swap分区</title>
      <link href="/2018/08/19/linuxswap%E5%88%86%E5%8C%BA/"/>
      <url>/2018/08/19/linuxswap%E5%88%86%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Linux内核为了提高读写效率与速度，会将文件在内存中进行缓存，这部分内存就是Cache Memory(缓存内存)。即使你的程序运行结束后，Cache Memory也不会自动释放。这就会导致你在Linux系统中程序频繁读写文件后，你会发现可用物理内存变少。当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap空间中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中。这样，系统总是在物理内存不够时，才进行Swap交换。</p><p>关于Swap分区，其实我们有很多疑问,如果能弄清楚这些疑问，那么你对Swap的了解掌握就差不多了。如何查看Swap分区大小？ Swap分区大小应该如何设置？系统在什么时候会使用Swap分区? 是否可以调整？ 如何调整Swap分区的大小？Swap分区有什么优劣和要注意的地方？ Swap分区是否必要？那么我一个一个来看看这些疑问吧！</p></blockquote><a id="more"></a><h1 id="查看swap分区大小"><a href="#查看swap分区大小" class="headerlink" title="查看swap分区大小"></a>查看swap分区大小</h1><p>  free -m<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># free -mh</span></span><br><span class="line">              total       used       free     shared    buffers     cached</span><br><span class="line">  Mem:          1.9G       672M       1.3G       2.6M        73M       182M</span><br><span class="line">  -/+ buffers/cache:       416M       1.5G</span><br><span class="line">  Swap:         2.0G         0B       2.0G</span><br></pre></td></tr></table></figure></p><p>  另外我们还可以使用swapon命令查看当前swap相关信息：例如swap空间是swap partition，Swap size，使用情况等详细信息<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># swapon -s</span></span><br><span class="line">  Filename                                Type            Size    Used    Priority</span><br><span class="line">  /dev/sda5                               partition       2097148 0       -1</span><br></pre></td></tr></table></figure></p><h1 id="Swap分区大小设置"><a href="#Swap分区大小设置" class="headerlink" title="Swap分区大小设置"></a>Swap分区大小设置</h1><p>系统的Swap分区大小设置多大才是最优呢？ 关于这个问题，应该说只能有一个统一的参考标准，具体还应该根据系统实际情况和内存的负荷综合考虑，像ORACLE的官方文档就推荐如下设置，这个是根据物理内存来做参考的。</p><ul><li>4G以内的物理内存，SWAP 设置为内存的2倍。</li><li>4-8G的物理内存，SWAP 等于内存大小。</li><li>8-64G 的物理内存，SWAP 设置为8G。</li><li>64-256G物理内存，SWAP 设置为16G。</li></ul><h1 id="关闭跟开启swap"><a href="#关闭跟开启swap" class="headerlink" title="关闭跟开启swap"></a>关闭跟开启swap</h1><p>使用swapoff关闭交换分区<br>swapoff /dev/sda5<br>swapon /dev/sda5 </p><h1 id="查看swap-内存信息"><a href="#查看swap-内存信息" class="headerlink" title="查看swap 内存信息"></a>查看swap 内存信息</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/swaps</span><br></pre></td></tr></table></figure><h1 id="格式化swap分区"><a href="#格式化swap分区" class="headerlink" title="格式化swap分区"></a>格式化swap分区</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkswap /dev/sda5</span><br></pre></td></tr></table></figure><h1 id="启动swap分区-并增加到-etc-fstab自动挂载"><a href="#启动swap分区-并增加到-etc-fstab自动挂载" class="headerlink" title="启动swap分区,并增加到/etc/fstab自动挂载"></a>启动swap分区,并增加到/etc/fstab自动挂载</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">swapon -a</span><br><span class="line">swapon /dev/sda5</span><br></pre></td></tr></table></figure><h1 id="增加swap"><a href="#增加swap" class="headerlink" title="增加swap"></a>增加swap</h1><ol><li><p>可以看到当前的swap 大小是2G</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># </span></span><br><span class="line"> [root@centos6 ~]<span class="comment"># free -mh</span></span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line"> Mem:          1.9G       362M       1.6G       1.3M        33M       122M</span><br><span class="line"> -/+ buffers/cache:       206M       1.7G</span><br><span class="line"> Swap:         2.0G         0B       2.0G</span><br></pre></td></tr></table></figure></li><li><p>创建一个swap 的分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># fdisk /dev/sdb</span></span><br><span class="line"></span><br><span class="line">     WARNING: DOS-compatible mode is deprecated. It<span class="string">'s strongly recommended to</span></span><br><span class="line"><span class="string">             switch off the mode (command '</span>c<span class="string">') and change display units to</span></span><br><span class="line"><span class="string">             sectors (command '</span>u<span class="string">').</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">     Command (m for help): n</span></span><br><span class="line"><span class="string">     Command action</span></span><br><span class="line"><span class="string">       e   extended</span></span><br><span class="line"><span class="string">       p   primary partition (1-4)</span></span><br><span class="line"><span class="string">     p</span></span><br><span class="line"><span class="string">     Partition number (1-4): 3</span></span><br><span class="line"><span class="string">     First cylinder (395-2610, default 395): </span></span><br><span class="line"><span class="string">     Using default value 395</span></span><br><span class="line"><span class="string">     Last cylinder, +cylinders or +size&#123;K,M,G&#125; (395-2610, default 2610): +1G</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">     Command (m for help): t</span></span><br><span class="line"><span class="string">     Partition number (1-4): 3</span></span><br><span class="line"><span class="string">     Hex code (type L to list codes): 82</span></span><br><span class="line"><span class="string">     Changed system type of partition 3 to 82 (Linux swap / Solaris)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">     Command (m for help): w</span></span><br><span class="line"><span class="string">     The partition table has been altered!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">     Calling ioctl() to re-read partition table.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">     WARNING: Re-reading the partition table failed with error 16: Device or resource busy.</span></span><br><span class="line"><span class="string">     The kernel still uses the old table. The new table will be used at</span></span><br><span class="line"><span class="string">     the next reboot or after you run partprobe(8) or kpartx(8)</span></span><br><span class="line"><span class="string">     Syncing disks.</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>格式化分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkswap /dev/sdb3</span><br></pre></td></tr></table></figure></li><li><p>查看分区前10240个字节</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> hexdump -C dev/sdb3 -n 10240|less</span><br><span class="line"> ``` </span><br><span class="line"> 4. 写入fstab 文件里让永久生效</span><br><span class="line">UUID=2d5bdbc6-4c77-48a8-b0ac-ed54ec46698c       swap      swap   defaults 0 0 </span><br><span class="line">5. 挂载生效</span><br><span class="line">``` bash</span><br><span class="line">swapon -a</span><br></pre></td></tr></table></figure></li></ol></li></ol><ol start="6"><li><p>查看swap大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># cat /proc/swaps</span></span><br><span class="line">Filename                                Type            Size    Used    Priority</span><br><span class="line">/dev/sda5                               partition       2097148 58796   -1</span><br><span class="line">/dev/sdb3                               partition       1060284 0       -2</span><br><span class="line"></span><br><span class="line">[root@centos6 ~]<span class="comment"># free -h</span></span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:          1.9G       207M       1.7G       1.3M       6.4M        33M</span><br><span class="line">-/+ buffers/cache:       167M       1.8G</span><br><span class="line">Swap:         3.0G        57M       3.0G   可以看到swap 分区增加了1G</span><br></pre></td></tr></table></figure></li><li><p>swap 优先级设置<br>数字越大优先级越大</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID=2d5bdbc6-4c77-48a8-b0ac-ed54ec46698c       swap      swap   pri=10 0 0</span><br></pre></td></tr></table></figure></li><li><p>让7配置的优先级生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">swapoff /dev/sdb3 </span><br><span class="line">swapon on</span><br></pre></td></tr></table></figure></li></ol><h1 id="删除swap"><a href="#删除swap" class="headerlink" title="删除swap"></a>删除swap</h1><ol><li>先禁用swap<br>swapoff /dev/sdb3 </li><li>vim /etc/fstab<br>把有关dev/sdb3的信息删掉</li><li>把dev/sdb3分区删掉<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># fdisk /dev/sdb</span></span><br><span class="line"></span><br><span class="line">WARNING: DOS-compatible mode is deprecated. It<span class="string">'s strongly recommended to</span></span><br><span class="line"><span class="string">        switch off the mode (command '</span>c<span class="string">') and change display units to</span></span><br><span class="line"><span class="string">        sectors (command '</span>u<span class="string">').</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Command (m for help): d</span></span><br><span class="line"><span class="string">Partition number (1-4): 3</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Command (m for help): w</span></span><br><span class="line"><span class="string">The partition table has been altered!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Calling ioctl() to re-read partition table.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">WARNING: Re-reading the partition table failed with error 16: Device or resource busy.</span></span><br><span class="line"><span class="string">The kernel still uses the old table. The new table will be used at</span></span><br><span class="line"><span class="string">the next reboot or after you run partprobe(8) or kpartx(8)</span></span><br><span class="line"><span class="string">Syncing disks.</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="将home目录迁移到一个独立分区种"><a href="#将home目录迁移到一个独立分区种" class="headerlink" title="将home目录迁移到一个独立分区种"></a>将home目录迁移到一个独立分区种</h1><ol><li><p>首先创建分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># fdisk /dev/sdb</span></span><br><span class="line"></span><br><span class="line"> WARNING: DOS-compatible mode is deprecated. It<span class="string">'s strongly recommended to</span></span><br><span class="line"><span class="string">         switch off the mode (command '</span>c<span class="string">') and change display units to</span></span><br><span class="line"><span class="string">         sectors (command '</span>u<span class="string">').</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> Command (m for help): n</span></span><br><span class="line"><span class="string"> Command action</span></span><br><span class="line"><span class="string">   e   extended</span></span><br><span class="line"><span class="string">   p   primary partition (1-4)</span></span><br><span class="line"><span class="string"> p</span></span><br><span class="line"><span class="string"> Partition number (1-4): 2</span></span><br><span class="line"><span class="string"> First cylinder (133-2610, default 133): </span></span><br><span class="line"><span class="string"> Using default value 133</span></span><br><span class="line"><span class="string"> Last cylinder, +cylinders or +size&#123;K,M,G&#125; (133-2610, default 2610): +2G</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> Command (m for help): w</span></span><br><span class="line"><span class="string"> The partition table has been altered!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> Calling ioctl() to re-read partition table.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> WARNING: Re-reading the partition table failed with error 16: Device or resource busy.</span></span><br><span class="line"><span class="string"> The kernel still uses the old table. The new table will be used at</span></span><br><span class="line"><span class="string"> the next reboot or after you run partprobe(8) or kpartx(8)</span></span><br><span class="line"><span class="string"> Syncing disks.</span></span><br></pre></td></tr></table></figure></li><li><p>格式化分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  mkfs.ext4 /dev/sdb2</span><br><span class="line">```  </span><br><span class="line">3. 挂载分区</span><br><span class="line">``` bash</span><br><span class="line"> mkdir /mnt/home </span><br><span class="line"> mount /dev/sdb2 /mnt/home</span><br></pre></td></tr></table></figure></li><li><p>将home 目录拷贝到新增加的分区里</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -av /home/* /mnt/home/</span><br></pre></td></tr></table></figure></li><li><p>把挂载分区写入fstab文件里<br>写入fstab文件 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -a</span><br></pre></td></tr></table></figure></li><li><p>检查拷贝文件是否全</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unmount /home  先取消挂载</span><br></pre></td></tr></table></figure></li><li><p>删除原来的home 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /home/*</span><br></pre></td></tr></table></figure></li><li><p>重新挂载   这是我们访问的home 就是/mnt/home 下的了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -a</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swap分区 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>磁盘管理</title>
      <link href="/2018/08/16/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
      <url>/2018/08/16/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要介绍下磁盘结构以及对磁盘的管理，包括磁盘的分区，创建文件系统（不创建文件系统我们的磁盘是无法使用的），以及挂载。</p></blockquote><a id="more"></a><h1 id="磁盘分类结构"><a href="#磁盘分类结构" class="headerlink" title="磁盘分类结构"></a>磁盘分类结构</h1><ol><li>固态硬盘（Solid state drive）<br>用固态电子存储芯片阵列而制成的硬盘，由控制单元和存储单元（FLASH芯片、DRAM芯片）组成。固态硬盘在接口的规范和定义、功能及使用方法上与普通硬盘的完全相同，在产品外形和尺寸上也与普通硬盘一致.相对于HDD，SSD防震抗摔，传输速度上明显有优势.但是费用昂贵。</li><li><p>机械硬盘（hard disk drive）<br>即是传统普通硬盘，主要由：盘片，磁头，盘片转轴及控制电机，磁头控制器，数据转换器，接口，缓存等几个部分组成。机械硬盘中所有的盘片都装在一个旋转轴上，每张盘片之间是平行的，在每个盘片的存储面上有一个磁头，磁头与盘片之间的距离比头发丝的直径还小，所有的磁头联在一个磁头控制器上，由磁头控制器负责各个磁头的运动。磁头可沿盘片的半径方向运动，加上盘片每分钟几千转的高速旋转，磁头就可以定位在盘片的指定位置上进行数据的读写操作。数据通过磁头由电磁流来改变极性方式被电磁流写到磁盘上，也可以通过相反方式读取。硬盘为精密设备，进入硬盘的空气必须过滤.<br>虽然ssd在很多方面有优势，但是致命的是寿命不长，硬盘有价，数据无价,目前SSD还不能完全取代HDD.<br>2种磁盘的结构是不一样的，工作原理当然也是不一样的，我觉得对磁盘结构以及工作原理的理解有助于我们后边的开发。可以提高磁盘的存取速度。</p><blockquote><p> 1.固态硬盘<br> <img src="/Linux/固态硬盘.png" alt="logo"><br>   固态硬盘是用固态电子存储芯片阵列而制成的硬盘，整个固态硬盘结构无机械装置，全部是由电子芯片及电路板组成。<br>   其实就是由三大块主控芯片、闪存颗粒、缓存单元构成。</p></blockquote><blockquote><p> 2.机械硬盘<br><img src="/Linux/机械硬盘.png" alt="logo"><br>由上图可以看到将盘片分成了磁道（Track），扇区（Sector）和柱面（Cylinder）</p></blockquote><ul><li><p>盘片</p><p>硬盘的存储介质，所有的信息都存储在这里，盘片分为单面盘片和双面盘片，单面盘片只能在一面进行存储，双面盘片能在两面进行存储。硬盘的盘片一般采用合金材料，多数为铝合金(IBM曾经开发过玻璃材质的盘片，好像现在有些厂家也生产玻璃材质的盘片，但不多见)，盘面上涂着磁性材料，厚度一般在0.5mm左右。有些硬盘只装一张盘片，有些则有多张。硬盘盘片安装在主轴电机的转轴上，在主轴电机的带动下作高速旋转。每张盘片的容量称为单碟容量，而一块硬盘的总容量就是所有盘片容量的总和。早期硬盘由于单碟容量低，所以盘片较多。现代的硬盘盘片一般只有少数几片。 盘片上的记录密度很大，而且盘片工作时会高速旋转，为保证其工作的稳定，数据保存的长久，所以硬片都是密封在硬盘内部。不可自行拆卸硬盘，在普通环境下空气中的灰尘、指纹、头发丝等细小杂质都会对硬盘造成永久损害。 硬盘一般会有一个或多个盘片，每个盘片可以有两个面(Side)，即第1个盘片的正面称为0面，反面称为1面；第2个盘片的正面称为2面，反面称为3面…依次类推。每个盘面对应一个磁头(head)用于读写数据。第一个盘面的正面的磁头称为0磁头，背面称为1磁头；第二个盘片正面的磁头称为2磁头，背面称为3磁头，以此类推。盘面数和磁头数是相等的。</p></li><li><p>磁道</p><p>每个盘片的每个盘面被划分成多个狭窄的同心圆环，数据就是存储在这样的同心圆环上，我们将这样的圆环称为磁道(Track)，每个盘面可以划分多个磁道。在每个盘面的最外圈，离盘心最远的地方是“0”磁道，向盘心方向依次增长为1磁道，2磁道，等等。硬盘数据的存放就是从最外圈开始。</p></li><li><p>扇区  </p></li></ul><p>根据硬盘规格的不同，磁道数可以从几百到成千上万不等。每个磁道上可以存储数KB的数据，但计算机并不需要一次读写这么多数据。在这一这基础上，又把每个磁道划分成若干弧段，每段称为一个扇区(Sector)。扇区是硬盘上存储的物理单位，每个扇区可存储128×2N次方（N＝0,1,2,3）字节的数据。从DOS时代起，每扇区是128×22＝512字节，现在已经成了业界不成文的规定，也没有哪个硬盘厂商试图去改变这种约定。也就是说即使计算机只需要硬盘上存储的某个字节，也须一次把这个字节所在的扇区中的全部512字节读入内存，再选择所需的那个字节。扇区的编号是从1开始，而不是0，这一点需要注意。另外，硬盘在划分扇区时，和软盘是有一定区别的。软盘的一个磁道中，扇区号一般依次编排，如1号，2号，3号…以此类推。但在硬盘磁道中，扇区号是按照某个间隔跳跃着编排。比如，2号扇区并不是1号扇区后的按顺序的第一个而是第八个，3号扇区又是2号扇区后的按顺序的第八个，依此类推，这个“八”称为交叉因子。</p><p>这个交叉因子的来历有必要详述一下，我们知道，数据读取经常需要按顺序读取一系列相邻的扇区(逻辑数据相邻)。如对磁道扇区按物理顺序进行编号，很有可能出现当磁头读取完第一个扇区后，由于盘片转速过快来不及读取下一个扇区，(要知道物理相邻扇区位置距离是极小的)，必须等待转完一圈，这极大浪费了时间。所以就用交叉来解决这个问题。</p><ul><li>柱面</li></ul><p>根据硬盘规格的不同，磁道数可以从几百到成千上万不等。每个磁道上可以存储数KB的数据，但计算机并不需要一次读写这么多数据。在这一这基础上，又把每个磁道划分成若干弧段，每段称为一个扇区(Sector)。扇区是硬盘上存储的物理单位，每个扇区可存储128×2N次方（N＝0,1,2,3）字节的数据。从DOS时代起，每扇区是128×22＝512字节，现在已经成了业界不成文的规定，也没有哪个硬盘厂商试图去改变这种约定。也就是说即使计算机只需要硬盘上存储的某个字节，也须一次把这个字节所在的扇区中的全部512字节读入内存，再选择所需的那个字节。扇区的编号是从1开始，而不是0，这一点需要注意。另外，硬盘在划分扇区时，和软盘是有一定区别的。软盘的一个磁道中，扇区号一般依次编排，如1号，2号，3号…以此类推。但在硬盘磁道中，扇区号是按照某个间隔跳跃着编排。比如，2号扇区并不是1号扇区后的按顺序的第一个而是第八个，3号扇区又是2号扇区后的按顺序的第八个，依此类推，这个“八”称为交叉因子。</p><p>这个交叉因子的来历有必要详述一下，我们知道，数据读取经常需要按顺序读取一系列相邻的扇区(逻辑数据相邻)。如对磁道扇区按物理顺序进行编号，很有可能出现当磁头读取完第一个扇区后，由于盘片转速过快来不及读取下一个扇区，(要知道物理相邻扇区位置距离是极小的)，必须等待转完一圈，这极大浪费了时间。所以就用交叉来解决这个问题。</p><ul><li>磁盘工作原理</li></ul><p>现代硬盘寻道都是采用CHS(Cylinder Head Sector)的方式，硬盘读取数据时，读写磁头沿径向移动，移到要读取的扇区所在磁道的上方，这段时间称为寻道时间(seek time)。因读写磁头的起始位置与目标位置之间的距离不同，寻道时间也不同。目前硬盘一般为2到30毫秒，平均约为9毫秒。磁头到达指定磁道后，然后通过盘片的旋转，使得要读取的扇区转到读写磁头的下方，这段时间称为旋转延迟时间(rotational latencytime)。</p><blockquote><p>另外硬盘接口类型有串行跟并行：</p><ul><li>并行：IDE(133MB/S) SCSI (640M/S)</li><li>串行：SATA:6Gbps SAS:6Gbps USB：480MB/s</li></ul></blockquote><blockquote><p>磁盘设备的文件名/dev/DEV_FILE</p><ul><li>虚拟磁盘：/dev/vd</li><li>不同磁盘标识：a-z,aa,ab… /dev/sda, /dev/sdb, …</li><li>同一设备上的不同分区：1,2, …/dev/sda1, /dev/sda5</li><li>硬盘术语 head：磁头，head：磁头，cylinder: 柱面，sector: 扇区，512bytes</li></ul></blockquote><h1 id="为什么要给磁盘分区"><a href="#为什么要给磁盘分区" class="headerlink" title="为什么要给磁盘分区"></a>为什么要给磁盘分区</h1><p>分区是将一个硬盘驱动器分成若干个逻辑驱动器，分区是把硬盘连续的区块当做一个独立的磁硬使用。分区表是一个硬盘分区的索引,分区的信息都会写进分区表。</p><blockquote><p>为什么要给磁盘分区</p></blockquote><ul><li>优化I/O性能</li><li>实现磁盘空间配额限制,易于管理</li><li>提高修复速度</li><li>隔离系统和程序</li><li>安装多个OS</li><li>采用不同文件系统</li><li>有利于数据安全<br>两种分区方式：MBR，GPT</li></ul><blockquote><p>MBR</p></blockquote><p>主引导记录（Master Boot Record ， MBR）是指一个存储设备的开头 512 字节。它包含操作系统的引导器和存储设备的分区表。<br>　全局唯一标识分区表（GUID Partition Table，缩写：GPT）是一个实体硬盘的分区表的结构布局的标准。它是统一可扩展固件接口标准的一部分，它使用全局唯一标识来标识设备。它是新一代分区表格式，用以替代 MBR 分区表。它用来解决 MBR 分区表的缺点，同时带来了一些优点。<br>　MBR 导致的问题<br>　只能有四个主分区或者三个主分区加一个扩展分区 (以及在扩展分区中的任意数量的逻辑分区). 如果你有三个主分区加一个扩展分区以及除此之外的空闲空间，在空闲空间之上你无法创立分区。<br>　　在扩展分区里，逻辑分区的元数据被存储在一个链表结构中。如果一个环节丢失，该元数据之后的逻辑分区全部丢失。<br>　　MBR 只支持1个字节的分区类型编码，导致许多冲突。<br>　　MBR 使用32位的 LBA 值来存储分区扇区信息。LBA 的大小以及512B的扇区大小共同限制了硬盘可寻址大小最大为2TB. 如果使用 MBR, 2TB以外的空间无法使用。 </p><blockquote><p>GPT</p></blockquote><p>使用 GUID (UUID) 来表明分区类型 - 无冲突。<br>　　为每个分区提供了一个唯一硬盘 GUID 和一个唯一分区 GUID - 一个好的不依赖文件系统的引用分区和硬盘的方式。<br>　　任意分区数 - 取决于给分区表分配的空间 - 不需要扩展和逻辑分区。GPT ，默认包含了定义128个分区的空间。当用户想要更多分区 时，他可以给分区表分配更多空间 (目前只有 gdisk 支持这一特性)。<br>　　使用64位 LBA 存储扇区数 - 最大硬盘可寻址大小为 2 ZB.<br>　　 存储了备份头和分区表可于主要部分损坏时进行急救。<br>　　CRC32 校验值用于检测头和分区表的错误与损坏。<br>　　GUID Partition Table （GPT）是一种更灵活的分区方式。它正在逐步取代Master Boot Record （MBR）系统。GPT相对于诞生于 MS-DOS时代的MBR而言，有许多优点。新版的fdisk（MBR）和gdisk（GPT）使得使用GPT或者MBR在可靠性和性能最大化上都非常容易。<br>　　在做出选择前，需要考虑如下内容：<br>　　 如果使用GRUB legacy作为bootloader，必须使用MBR。<br>　　如果使用传统的BIOS，并且双启动中包含 Windows （无论是32位版还是64位版），必须使用MBR。<br>　　如果使用 UEFI 而不是BIOS，并且双启动中包含 Windows 64位版，必须使用GPT。<br>　　非常老的机器需要使用 MBR，因为 BIOS 可能不支持 GPT.<br>　　 如果不属于上述任何一种情况，可以随意选择使用 GPT 还是 MBR。由于 GPT 更先进，建议选择 GPT。<br>　　建议在使用 UEFI 的情况下选择 GPT，因为有些 UEFI firmware 不支持从 MBR 启动</p><h1 id="给磁盘分区"><a href="#给磁盘分区" class="headerlink" title="给磁盘分区"></a>给磁盘分区</h1><p>•fdisk 创建MBR分区<br>•gdisk 创建GPT分区</p><p>fdisk命令参数介绍<br>p、打印分区表。<br>n、新建一个新分区。<br>d、删除一个分区。<br>q、退出不保存。<br>w、把分区写进分区表，保存并退出。<br>为了实验我们新添加一块硬盘：<br><img src="/Linux/添加硬盘.png" alt="logo"><br>发现没有我们增加的硬盘，怎么办呢</p><blockquote><p>运行下面命令查看主机总线号</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls /sys/class/scsi_host/</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root 0 Aug 19  2018 host0 -&gt; ../../devices/pci0000:00/0000:00:07.1/host0/scsi_host/host0</span><br><span class="line">lrwxrwxrwx 1 root root 0 Aug 19  2018 host1 -&gt; ../../devices/pci0000:00/0000:00:07.1/host1/scsi_host/host1</span><br><span class="line">lrwxrwxrwx 1 root root 0 Aug 19  2018 host2 -&gt; ../../devices/pci0000:00/0000:00:10.0/host2/scsi_host/host2</span><br></pre></td></tr></table></figure><blockquote><p>再次运行lsblk 发现sdb 出来了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># lsblk</span></span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sr0     11:0    1  3.7G  0 rom  /media/CentOS_6.10_Final</span><br><span class="line">sda      8:0    0  200G  0 disk </span><br><span class="line">├─sda1   8:1    0    1G  0 part /boot</span><br><span class="line">├─sda2   8:2    0 48.8G  0 part /</span><br><span class="line">├─sda3   8:3    0 29.3G  0 part /data</span><br><span class="line">├─sda4   8:4    0    1K  0 part </span><br><span class="line">└─sda5   8:5    0    2G  0 part [SWAP]</span><br><span class="line">sdb      8:16   0   20G  0 disk</span><br></pre></td></tr></table></figure></blockquote></li></ol><p>接下来我们就可以在这块硬盘上创建分区了<br>运行命令 fdsik /dev/sdb<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]<span class="comment"># fdisk /dev/sdb</span></span><br><span class="line">Device contains neither a valid DOS partition table, nor Sun, SGI or OSF disklabel</span><br><span class="line">Building a new DOS disklabel with disk identifier 0xd973c790.</span><br><span class="line">Changes will remain <span class="keyword">in</span> memory only, until you decide to write them.</span><br><span class="line">After that, of course, the previous content won<span class="string">'t be recoverable.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Warning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">WARNING: DOS-compatible mode is deprecated. It'</span>s strongly recommended to</span><br><span class="line">        switch off the mode (<span class="built_in">command</span> <span class="string">'c'</span>) and change display units to</span><br><span class="line">        sectors (<span class="built_in">command</span> <span class="string">'u'</span>).</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): m</span><br><span class="line">Command action</span><br><span class="line">  a   toggle a bootable flag  设定硬盘启动区</span><br><span class="line">  b   edit bsd disklabel    </span><br><span class="line">  c   toggle the dos compatibility flag</span><br><span class="line">  d   delete a partition   删除硬盘分区</span><br><span class="line">  l   list known partition types</span><br><span class="line">  m   <span class="built_in">print</span> this menu    显示所有命令列示</span><br><span class="line">  n   add a new partition  创建新的硬盘分区</span><br><span class="line">  o   create a new empty DOS partition table</span><br><span class="line">  p   <span class="built_in">print</span> the partition table  显示硬盘分区情况</span><br><span class="line">  q   quit without saving changes</span><br><span class="line">  s   create a new empty Sun disklabel</span><br><span class="line">  t   change a partition<span class="string">'s system id  改变硬盘分割区属性</span></span><br><span class="line"><span class="string">  u   change display/entry units</span></span><br><span class="line"><span class="string">  v   verify the partition table</span></span><br><span class="line"><span class="string">  w   write table to disk and exit</span></span><br><span class="line"><span class="string">  x   extra functionality (experts only)</span></span><br></pre></td></tr></table></figure></p><p>根据提示我们输入n 是创建新分区<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Command action</span><br><span class="line">   e   extended   扩展分区 只能有一个</span><br><span class="line">   p   primary partition (1-4)  主分区最多4个 因为我们建的是GPT类型的</span><br><span class="line">``` </span><br><span class="line">我们选p </span><br><span class="line">``` bash</span><br><span class="line"> Command (m <span class="keyword">for</span> <span class="built_in">help</span>): p</span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 21.5 GB, 21474836480 bytes</span><br><span class="line">255 heads, 63 sectors/track, 2610 cylinders</span><br><span class="line">Units = cylinders of 16065 * 512 = 8225280 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk identifier: 0x7d9e381f</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdb2             263        2610    18860310   83  Linux</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Command action</span><br><span class="line">   e   extended   扩展分区</span><br><span class="line">   p   primary partition (1-4) 主分区</span><br><span class="line">e</span><br><span class="line">Partition number (1-4): 1</span><br><span class="line">First cylinder (1-2610, default 1): </span><br><span class="line">Using default value 1</span><br><span class="line">Last cylinder, +cylinders or +size&#123;K,M,G&#125; (1-262, default 262): +500M  选择大小</span><br></pre></td></tr></table></figure></p><p>输入w 存盘退出，退出后我们可以通过以下的命令来查看分区信息</p><ul><li>查看内存的分区信息<br>cat /proc/partitions<br>lsblk<br>ls /dev/sdb*</li><li>查看实际的硬盘分区信息<br>fdisk -l /dev/sdb </li></ul><p>另外还有uuidgen 生成随机数。<br>到此给硬盘的分区就创建完了。<br>还有一个问题就是新增完分区会有警告不能识别，我们通过执行下面命令来同步</p><blockquote><p>centos6 增加分区的时候同步分区表<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">partx -a /dev/sdb</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>删除分区表的时候同步分区表  num 代表第几块分区表</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">partx -d -nr num /dev/sdb</span><br></pre></td></tr></table></figure><blockquote><p>cetnos7 比较简单一条命令搞定<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">partprobe</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>如何给磁盘贴标签<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sdb </span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): t</span><br><span class="line">Partition number (1-5): 1</span><br><span class="line">Hex code (<span class="built_in">type</span> L to list codes): L</span><br><span class="line"></span><br><span class="line"> 0  Empty           24  NEC DOS         81  Minix / old Lin bf  Solaris        </span><br><span class="line"> 1  FAT12           39  Plan 9          82  Linux swap / So c1  DRDOS/sec (FAT-</span><br><span class="line"> 2  XENIX root      3c  PartitionMagic  83  Linux           c4  DRDOS/sec (FAT-</span><br><span class="line"> 3  XENIX usr       40  Venix 80286     84  OS/2 hidden C:  c6  DRDOS/sec (FAT-</span><br><span class="line"> 4  FAT16 &lt;32M      41  PPC PReP Boot   85  Linux extended  c7  Syrinx         </span><br><span class="line"> 5  Extended        42  SFS             86  NTFS volume <span class="built_in">set</span> da  Non-FS data    </span><br><span class="line"> 6  FAT16           4d  QNX4.x          87  NTFS volume <span class="built_in">set</span> db  CP/M / CTOS / .</span><br><span class="line"> 7  HPFS/NTFS       4e  QNX4.x 2nd part 88  Linux plaintext de  Dell Utility   </span><br><span class="line"> 8  AIX             4f  QNX4.x 3rd part 8e  Linux LVM       df  BootIt         </span><br><span class="line"> 9  AIX bootable    50  OnTrack DM      93  Amoeba          e1  DOS access     </span><br><span class="line"> a  OS/2 Boot Manag 51  OnTrack DM6 Aux 94  Amoeba BBT      e3  DOS R/O        </span><br><span class="line"> b  W95 FAT32       52  CP/M            9f  BSD/OS          e4  SpeedStor      </span><br><span class="line"> c  W95 FAT32 (LBA) 53  OnTrack DM6 Aux a0  IBM Thinkpad hi eb  BeOS fs        </span><br><span class="line"> e  W95 FAT16 (LBA) 54  OnTrackDM6      a5  FreeBSD         ee  GPT            </span><br><span class="line"> f  W95 Ext<span class="string">'d (LBA) 55  EZ-Drive        a6  OpenBSD         ef  EFI (FAT-12/16/</span></span><br><span class="line"><span class="string">10  OPUS            56  Golden Bow      a7  NeXTSTEP        f0  Linux/PA-RISC b</span></span><br><span class="line"><span class="string">11  Hidden FAT12    5c  Priam Edisk     a8  Darwin UFS      f1  SpeedStor      </span></span><br><span class="line"><span class="string">12  Compaq diagnost 61  SpeedStor       a9  NetBSD          f4  SpeedStor      </span></span><br><span class="line"><span class="string">14  Hidden FAT16 &lt;3 63  GNU HURD or Sys ab  Darwin boot     f2  DOS secondary  </span></span><br><span class="line"><span class="string">16  Hidden FAT16    64  Novell Netware  af  HFS / HFS+      fb  VMware VMFS    </span></span><br><span class="line"><span class="string">17  Hidden HPFS/NTF 65  Novell Netware  b7  BSDI fs         fc  VMware VMKCORE </span></span><br><span class="line"><span class="string">18  AST SmartSleep  70  DiskSecure Mult b8  BSDI swap       fd  Linux raid auto</span></span><br><span class="line"><span class="string">1b  Hidden W95 FAT3 75  PC/IX           bb  Boot Wizard hid fe  LANstep        </span></span><br><span class="line"><span class="string">1c  Hidden W95 FAT3 80  Old Minix       be  Solaris boot    ff  BBT            </span></span><br><span class="line"><span class="string">1e  Hidden W95 FAT1</span></span><br><span class="line"><span class="string">Hex code (type L to list codes): 8e</span></span><br></pre></td></tr></table></figure></p></blockquote><p>这会给你分区贴了标签代表这块分区类型，常见的有8e 逻辑卷，fd raid，83 Linux，82 交换分区。</p><h1 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h1><p>  “文件系统”的主语是“文件”，那么文件系统的意思就是“用于管理文件的(管理)系统”，而这套管理系统所管理的对象当然就是文件了。在大多数操作系统里，“文件是数据的集合”这个基本点是一致的，而这些数据最终都是存储在存储介质里，如硬盘、光盘、U盘等。<br>  另一方面，用户在管理数据时也是文件为基本单位，他们所关心的问题是：</p><p>  1、我的文件在什么地方放着？<br>  2、我如何将数据存入某个文件？<br>  3、如何从文件里将数据读出来？<br>  4、不再需要的文件怎么将其删除？</p><p>  简而言之，文件系统就是一套用于定义文件的命名和组织数据的规范，其根本目的是便对文件进行查询和存取。</p><p>  Unix/Linux系统中的文件系统有个很重要的特性就挂载，即文件系统在使用前必须被挂载在一个实际的目录下才能使用，这是因为类Unix系统中的文件系统都遵循了FHS(Filesystem Hierarchy Standard)。在FHS中详细定义了类Unix操作系统中各种应用软件、管理工具、开发工具、脚本和帮助文件所处的位置。这样，通过该标准，软件发布商和用户在不同的发行版的linux系统里都能预测软件安装后，文件和目录所处的位置。</p><p> 文件系统为了实现对文件更好的管理、组织方式，引入了目录的概念。目录里不但可以保存文件还可以保存目录，以目录为依托，最终会形成一个目录树的结构.<br>如果我们将一块硬盘格式化成ext3或ext4格式后，通过mount命令将其挂载到根目录下，就形成了我们通常所说的“根文件系统”。根文件系统不是一个新实体，而是指挂载在根目录下的存储设备(或某个分区)实际所使用的文件系统类型。当“根文件系统”被挂载后，内存中就有了如上所示的目录结构树。这里提醒一点，千万不要以为你在命令行输入“cd /usr/src/”等命令时是在“操作”硬盘，其实你是在内存的VFS的目录树里。这里就不展开了，后面剖析VFS时再详细介绍。作为用户在使用文件系统时，对于某个具体的存储设备，例如U盘或硬盘，无非是首先执行诸如mk2fs或mkfs.xxx这样的命令对存储设备进行格式化，将其格式化成某种类型的文件系统，然后用mount命令将该存设备挂载到某个具体的目录下，然后对该目录下的文件进行“增、删、改、查”就可以实现对该存储设备上数据的操作。</p><p>所谓文件系统就是操作系统用来明确磁盘或分区上的文件以及数据结构的一种方法，也就是磁盘上文件的组织方法。普通用户所看到的文件系统，是以目录结构而存在的一个多级分层的树状结构，但作为开发人员我们得知道其实每个目录下都可以挂载不同类型的文件系统。最后一点是，每个文件系统可以占用磁盘的一个分区，而不是整个硬盘，这一点请注意。VFS并不是一个实际的文件系统，它是类Unix操作系统给我们提供的一种用于统一管理具体文件系统的机制。当我们要开发一种新的文件系统时，需要遵照VFS的规范，才能享受VFS带来的好处。</p><blockquote><p>Linux文件系统分类：</p></blockquote><ol><li>ext2(Extended file system) :适用于那些分区容量不是太大，更新也不频繁的情况，<br>例如 /boot 分区。</li><li>ext3:是 ext2 的改进版本，其支持日志功能，能够帮助系统从非正常关机导致的异常中<br>恢复。它通常被用作通用的文件系统</li><li>ext4:是 ext 文件系统的最新版。提供了很多新的特性，包括纳秒级时间戳、创建和使<br>用巨型文件(16TB)、最大1EB的文件系统，以及速度的提升</li><li>xfs：SGI，支持最大8EB的文件系统</li><li>btrfs（Oracle）, reiserfs, jfs（AIX）, swap</li><li>光盘：iso9660</li><li>Windows：FAT32, exFAT,NTFS</li><li>Unix: FFS（fast）, UFS（unix）, JFS2</li><li>网络文件系统：NFS, CIFS</li><li>集群文件系统：GFS2, OCFS2（oracle）</li><li>分布式文件系统： fastdfs,ceph, moosefs, mogilefs, glusterfs, Lustre</li><li><p>RAW：未经处理或者未经格式化产生的文件系统</p><blockquote><p>创建文件系统</p></blockquote><p>　格式化与挂载: (挂载目录可以自行创建也可指定存在的空目录)<br>　　mksf.ext3 /dev/sdb1 把第二块硬盘的第一个主分区格式化为ext3<br>或者<br>mkfs -t ext3 /dev/sdb1<br>-L ‘LABEL’: 设定卷标</p><ul><li>mke2fs<br>mke2fs：ext系列文件系统专用管理工具<br>-t {ext2|ext3|ext4}<br>-b {1024|2048|4096}<br>-L ‘LABEL’<br>-j: 相当于 -t ext3<br>mkfs.ext3 = mkfs -t ext3 = mke2fs -j = mke2fs -t ext3<br>-i #: 为数据空间中每多少个字节创建一个inode；此大小不应该小于<br>block的大小<br>-N #：指定分区中创建多少个inode<br>-I 一个inode记录占用的磁盘空间大小，128—4096<br>-m #: 默认5%,为管理人员预留空间占总空间的百分比<br>-O FEATURE[,…]：启用指定特性<br>-O ^FEATURE：关闭指定特性<br>　　mkswap /dev/sdb2 初始化swap区，此区不可格式化。<blockquote><p>文件系统标签</p></blockquote></li></ul><p>指向设备的另一种方法</p></li></ol><ul><li>与设备无关</li><li>blkid：块设备属性信息查看<br>blkid [OPTION]… [DEVICE]<br>-U UUID: 根据指定的UUID来查找对应的设备<br>-L LABEL：根据指定的LABEL来查找对应的设备</li><li>e2label：管理ext系列文件系统的LABEL<br>e2label DEVICE [LABEL]</li><li>findfs ：查找分区<br>findfs [options] LABEL=<label><br>findfs [options] UUID=<uuid><br>tune2fs</uuid></label></li><li>tune2fs：重新设定ext系列文件系统可调整参数的值<br>-l：查看指定文件系统超级块信息；super block<br>-L ‘LABEL’：修改卷标<br>-m #：修预留给管理员的空间百分比<br>-j: 将ext2升级为ext3<br>-O: 文件系统属性启用或禁用, –O ^has_journal<br>-o: 调整文件系统的默认挂载选项，–o ^acl<br>-U UUID: 修改UUID号</li><li><p>dumpe2fs：<br>块分组管理，32768块<br>-h：查看超级块信息，不显示分组信息</p><blockquote><p>文件系统检测和修复</p></blockquote><p>常发生于死机或者非正常关机之后</p></li><li>挂载为文件系统标记为“no clean”</li><li>注意：一定不要在挂载状态下修复</li><li>fsck: File System Check<br>fsck.FS_TYPE<br>fsck -t FS_TYPE<br>-p: 自动修复错误<br>-r: 交互式修复错误<br>FS_TYPE一定要与分区上已经文件类型相同</li><li>e2fsck：ext系列文件专用的检测修复工具<br>-y：自动回答为yes<br>-f：强制修复<h1 id="挂载设备"><a href="#挂载设备" class="headerlink" title="挂载设备"></a>挂载设备</h1>　　mount /dev/sdb1 /mnt/d #将第一个分区挂载到d这个目录<br>　　重启后自动挂载：vi /etc/fstab<br>　　添加：/dev/sdb1（这里最好写设备的UUID） /mnt/d ext3 default 0 0</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 磁盘管理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vim 命令</title>
      <link href="/2018/08/14/linuxvim/"/>
      <url>/2018/08/14/linuxvim/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文将介绍vim 常用的命令。</p></blockquote><a id="more"></a><h1 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h1><p> h  - 向左移动光标<br> j  - 向下移动光标<br> k  - 向上移动光标<br> l  - 向右移动光标<br> H  - 移动到屏幕顶部<br> M  - 移动到屏幕中间<br> L  - 移动到屏幕底部<br> w  - 向前跳到一个单词的开头<br> W  - 向前跳到单词的开头（单词可以包含标点符号）<br> e  - 向前跳到一个单词的结尾<br> E  - 向前跳到单词的结尾（单词可以包含标点符号）<br> b  - 向后跳到单词的开头<br> B  - 向后跳到单词的开头（单词可以包含标点符号）<br> 0  - 跳到行的开头<br> ^  - 跳转到该行的第一个非空白字符<br> $  - 跳到最后一行<br> g_  - 跳转到该行的最后一个非空白字符<br> gg  - 转到文档的第一行<br> G  - 转到文档的最后一行<br> 5G  - 转到第5行<br> fx  - 跳转到下一个字符x<br> tx  - 在下一次出现字符x之前跳转到<br> }  - 跳转到下一段（或编辑代码时的函数/块）<br> { - 跳转到上一段（或编辑代码时的函数/块）<br> zz  - 屏幕上的中心光标<br> Ctrl + b  - 向后移动一个全屏<br> Ctrl + f  - 向前移动一个全屏<br> Ctrl + d  - 向前移动1/2个屏幕<br> Ctrl + u  - 向后移动1/2个屏幕</p><p>提示：使用数字前缀光标移动命令以重复它。 例如，4j向下移动4行。<br>插入模式<br>  i  - 在光标前插入<br>我 - 插入行的开头<br> a  - 在光标后插入（追加）<br> A  - 在行尾插入（追加）<br> o  - 在当前行下面追加（打开）一个新行<br> O  - 在当前行上方追加（打开）一个新行<br> ea  - 在单词的末尾插入（追加）<br> Esc  - 退出插入模式</p><h1 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h1><p>  r  - 替换单个字符<br> J  - 将下面的行连接到当前行<br> cc  - 更改（替换）整行<br> cw  - 更改（替换）到单词的结尾<br> c $  - 更改（替换）到行尾<br> s  - 删除字符和替换文本<br> S  - 删除行和替换文本（与cc相同）<br> xp  - 转置两个字母（删除和粘贴）</p><h1 id="撤消"><a href="#撤消" class="headerlink" title="撤消"></a>撤消</h1><p> Ctrl + r  - 重做<br> 。  - 重复上一个命令</p><h1 id="标记文本（可视模式）"><a href="#标记文本（可视模式）" class="headerlink" title="标记文本（可视模式）"></a>标记文本（可视模式）</h1><p> v  - 启动可视模式，标记行，然后执行操作（如d-delete）<br> V  - 启动线性视觉模式<br> Ctrl + v  - 以块方式可视模式启动<br> o  - 移动到标记区域的另一端<br> O  - 移动到街区的其他角落<br> 标记一个单词<br> ab  - 带（）的块<br> aB  - 带{}的块<br> ib  - 带（）的内部块<br> iB  - 带{}的内部块<br> Esc  - 退出视觉模式</p><h1 id="视觉命令"><a href="#视觉命令" class="headerlink" title="视觉命令"></a>视觉命令</h1><blockquote><ul><li>右移文本&lt; - 移位文本左y  - 猛拉（复制）标记文本d  - 删除标记文本〜 - 切换案例 </li></ul></blockquote><h1 id="剪切和粘贴"><a href="#剪切和粘贴" class="headerlink" title="剪切和粘贴"></a>剪切和粘贴</h1><p>  yy  - 猛拉（复制）一条线<br> 2yy  - 猛拉（复制）2行<br> yw  - 从光标位置向下一个单词的开头猛拉（复制）单词的字符<br> y $  - 猛拉（复制）到行尾<br> p  - 光标后放置（粘贴）剪贴板<br> P  - 在光标前放（粘贴）<br> dd  - 删除（剪切）一行<br> 2dd  - 删除（剪切）2行<br> dw  - 从光标位置到下一个单词的开头删除（剪切）单词的字符<br> D  - 删除（剪切）到行尾<br> d $  - 删除（剪切）到行尾<br> x  - 删除（剪切）字符</p><h1 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h1><p>  ：w  - 写（保存）文件，但不要退出<br> ：w！sudo tee％ - 使用sudo写出当前文件<br> ：wq或：x或ZZ  - 写（保存）并退出<br> ：q  - 退出（如果有未保存的更改，则失败）<br> ：Q！ 或ZQ  - 退出并丢弃未保存的更改</p><h1 id="搜索和替换"><a href="#搜索和替换" class="headerlink" title="搜索和替换"></a>搜索和替换</h1><p>  / pattern  - 搜索模式<br> ？模式 - 向后搜索模式<br> \ vpattern  - ‘非常神奇’模式：非字母数字字符被解释为特殊的正则表达式符号（不需要转义）<br> n  - 在同一方向重复搜索<br> N  - 以相反方向重复搜索<br> ：％s / old / new / g  - 用新的整个文件替换所有旧的<br> ：％s / old / new / gc  - 使用确认替换所有旧的整个文件<br> ：noh  - 删除搜索匹配的突出显示</p><h1 id="在多个文件中搜索"><a href="#在多个文件中搜索" class="headerlink" title="在多个文件中搜索"></a>在多个文件中搜索</h1><p>  ：vimgrep / pattern / {file}  - 在多个文件中搜索模式<br>例如<br> ：vimgrep / foo / *<em> / </em><br> ：cn  - 跳到下一场比赛<br> ：cp  - 跳转到上一场比赛<br> ：copen  - 打开一个包含匹配列表的窗口</p><h1 id="使用多个文件"><a href="#使用多个文件" class="headerlink" title="使用多个文件"></a>使用多个文件</h1><p>  ：e file  - 在新缓冲区中编辑文件<br> ：bnext或：bn  - 转到下一个缓冲区<br> ：bprev或：bp  - 转到上一个缓冲区<br> ：bd  - 删除缓冲区（关闭文件）<br> ：ls  - 列出所有打开的缓冲区<br> ：sp file  - 在新缓冲区和拆分窗口中打开文件<br> ：vsp文件 - 在新缓冲区中打开文件并垂直拆分窗口<br> Ctrl + ws  - 拆分窗口<br> Ctrl + ww  - 切换窗口<br> Ctrl + wq  - 退出一个窗口<br> Ctrl + wv  - 垂直拆分窗口<br> Ctrl + wh  - 将光标移动到左侧窗口（垂直分割）<br> Ctrl + wl  - 将光标移动到右侧窗口（垂直分割）<br> Ctrl + wj  - 将光标移动到下面的窗口（水平分割）<br> Ctrl + wk  - 将光标移动到上面的窗口（水平分割）</p><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>  ：tabnew或：tabnew文件 - 在新选项卡中打开文件<br> Ctrl + wT  - 将当前分割窗口移动到其自己的选项卡中<br> gt或：tabnext或：tabn  - 移动到下一个选项卡<br> gT或：tabprev或：tabp  - 移至上一个选项卡</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>源码编译安装</title>
      <link href="/2018/08/12/linux%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/"/>
      <url>/2018/08/12/linux%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[ <blockquote><p>顾名思义，源码包就是源代码的可见的软件包，基于Linux和BSD系统的软件最常见；<br>但软件的源代码可见并不等于软件是开源的，我们还要以软件的许可为准；比如有些软件是源码可见的，但他约定用户只能按他约定的内容来修改；所以一个软件是否是开源软件，得具备两个条件；一是源代码可见；二是要有宽松的许可证书，比如GPL证书等；</p></blockquote><a id="more"></a><h1 id="源代码有什么用"><a href="#源代码有什么用" class="headerlink" title="源代码有什么用"></a>源代码有什么用</h1><p>1、自定义软件功能<br>2、优化编译参数，提高性能<br>3、解决不必要的软件间依赖</p><h1 id="源代码常见的打包格式"><a href="#源代码常见的打包格式" class="headerlink" title="源代码常见的打包格式"></a>源代码常见的打包格式</h1><p>一种是以 bzip2 格式的打包并压缩<br>tar jxvf file.tar.bz2<br>另外一种是以gzip 格式的打包并压缩<br>tar zxvf file.tar.gz</p><h1 id="如何编译源码"><a href="#如何编译源码" class="headerlink" title="如何编译源码"></a>如何编译源码</h1><p>我们以httpd-2.4.25.tar.gz 包为例，到官网下载回来。</p><h2 id="（一）解压我们刚刚下载回来的压缩包"><a href="#（一）解压我们刚刚下载回来的压缩包" class="headerlink" title="（一）解压我们刚刚下载回来的压缩包"></a>（一）解压我们刚刚下载回来的压缩包</h2><pre><code>tar -xvf httpd-2.4.25.tar.gzcd httpd-2.4.25 进入目录查看configure 的配置参数我们输入./configre 可以看到有关的一些配置比如：</code></pre><p>   –prefix 安装路径<br>   也可以用下面的参数指定相关的路径，如果不指定那么统一使用–prefix 配置的路径来安装<br>   –bindir   二进制程序存放路径<br>   –sbindir  管理类的二进制<br>   –libexecdir  库文件<br>   –sysconfdir  配置文件<br>   –mandir  man 帮助文档</p><p>   –还有一些特性配置<br>   –enable-ssl<br>   –enable-proxy </p><p>另外我们可以看下源码包里的  README  INSTALL文件查看源码包的编译安装跟使用</p><h2 id="（二）下面我们开始进入编译步骤"><a href="#（二）下面我们开始进入编译步骤" class="headerlink" title="（二）下面我们开始进入编译步骤"></a>（二）下面我们开始进入编译步骤</h2><p>（1）比如我们要把主程序安装在/app/httpd 目录下，配置文件安装在/etc/http2/ 并且开启ssl 安装传输<br> ./configure –prefix=/app/httpd –sysconfdir=/etc/http2/<br>–enable-ssl<br> 发下报错了，<br> 一般我们建议编译前把我们的开发包组安装一下<br> yum groupinstall “Development Tools”<br> yum install apr-devel<br> yum install apr-util-devel<br> yum install gcc<br> yum install pcre-devel<br> yum install openssl-devel </p><p>（2）make -j cpu数量<br>（3）make install<br>（4）进入app下查看<br>（5）配置环境变量<br>echo ‘PATH=/app/httpd/bin:$PATH’ &gt; /etc/profile.d/httpd.sh<br>（6）生效<br>. /etc/profile.d/httpd.sh<br>（7）启动服务<br> apachectl  start</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>修改这个文件，可以更改httpd的工作方式<br>/etc/sysconfig/httpd</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码编译安装 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>文件权限与属性详解 之 SUID、SGID、chattr &amp; SBIT</title>
      <link href="/2018/08/10/linuxSuidSgidSbit/"/>
      <url>/2018/08/10/linuxSuidSgidSbit/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由于在特殊场景下一般权限难以控制，所以引入了特殊权限。</p></blockquote><p>用户管理：<a href="https://fengxinhua.cn/2018/08/02/linuxUser/" target="_blank" rel="noopener">用户管理</a><br>一般权限:<a href="https://fengxinhua.cn/2018/08/03/linux一般权限/" target="_blank" rel="noopener">一般权限</a><br>ACL访问控制列表:<a href="https://fengxinhua.cn/2018/08/06/linuxAcl/" target="_blank" rel="noopener">ACL访问控制列表</a><br>suid,sgid:<a href="https://fengxinhua.cn/2018/08/10/linuxSuidSgidSbit/" target="_blank" rel="noopener">suid,sgid</a><br><a id="more"></a></p><h1 id="UID"><a href="#UID" class="headerlink" title="UID"></a>UID</h1><p>SetUID(或者 s 权限）：当一个具有执行权限的文件设置SetUID权限后，用户执行这个文件时将以文件所有者的身份执行。<br>进程运行时能够访问哪些资源或文件，不取决于进程文件的属主属组，而是取决于运行该命令的用户身份的uid/gid，以该身份获取各种系统资源.<br>SUID只对二进制可执行程序有效<br>SUID设置在目录上无意义<br>SUID设置在目录上无意义</p><p>通过chmod u+s file 设置文件的uid</p><h1 id="GID"><a href="#GID" class="headerlink" title="GID"></a>GID</h1><p>对目录设置了gid后，用户创建文件时，其属组为此用户所属的主组.<br>一旦某目录被设定了SGID，则对此目录有写权限的用户在此目录中创建的文件<br>所属的组为此目录的属组</p><p>通过chmod g+s file 设置文件的gid</p><h1 id="STICK-BIT"><a href="#STICK-BIT" class="headerlink" title="STICK_BIT"></a>STICK_BIT</h1><p>具有写权限的目录通常用户可以删除该目录中的任何文件，无论该文件的权限或拥有权,<br>在目录设置Sticky 位，只有文件的所有者或root可以删除该文件<br>sticky 设置在文件上无意义</p><p>通过chmod o+t 目录名 设置目录的SBIT</p><h1 id="chattr"><a href="#chattr" class="headerlink" title="chattr"></a>chattr</h1><p>chattr +i 不能删除，改名，更改<br>chattr +a 只能追加内容<br>lsattr 显示特定属性</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SUID、SGID、chattr &amp; SBIT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>httpd 安装问题</title>
      <link href="/2018/08/09/LinuxhttpdProblem/"/>
      <url>/2018/08/09/LinuxhttpdProblem/</url>
      
        <content type="html"><![CDATA[<blockquote><p>httpd 安装问题 </p></blockquote><a id="more"></a><p>service httpd start<br>报错<br>Could not reliably determine the server’s fully qualified domain name, using 127.0.0.1 for ServerName<br>解决办法：<br>find / -name “httpd.conf”<br>编辑  /etc/httpd/conf/httpd.conf<br>添加ServerName localhost:80<br>重启服务 apachectl restart </p><p>发现只能在虚拟机里访问，外边主机无法访问，应该是iptables中限制远程访问80端口<br>开放端口<br>iptables -I INPUT -p tcp –dport 80 -j ACCEPT<br>保存配置<br>service iptables save<br>重启防火墙<br>service iptables restart<br>查看配置<br>iptables status<br>然后在输入ip 地址可以正常访问了<br><img src="/Linux/httpd服务.png" alt="logo"></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> httpd </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>软件包管理</title>
      <link href="/2018/08/09/npmyun/"/>
      <url>/2018/08/09/npmyun/</url>
      
        <content type="html"><![CDATA[<blockquote><p>大多数linux操作系统提供了一个集中的软件包管理机制，以帮助用户搜索，安装，管理软件。而软件通常以包的形成存储在仓库中，对软件包的使用和管理成为包管理。</p></blockquote><a id="more"></a><h1 id="软件运行环境"><a href="#软件运行环境" class="headerlink" title="软件运行环境"></a>软件运行环境</h1><p>POSIX标准定义了操作系统应该为应用程序提供的接口标准，软件运行和编译首先我们要提到2个概念，ABI跟API.<br>ABI是Application Binary Interface 的简称，linux 是ELF,而windows 是PE.<br>API是 Application Programming Interface的简称<br>程序编译的步骤：预处理——编译——汇编——链接。linux 下静态文件后缀是.a,动态文件是.so.<br>那么什么是静态和动态链接呢？<br>链接的主要作用是把各个模块之间相互引用的部分处理好，使得各个模块之间能够正则的衔接。</p><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>1把程序对应的依赖库复制一份到包<br>2libxxx.a<br>3嵌入程序包<br>4升级难，需重新编译<br>5占用较多空间，迁移容易</p><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>1只把依赖加做一个动态链接<br>2libxxx.so<br>3连接指向<br>4占用较少空间，升级方便</p><h1 id="软件包基础"><a href="#软件包基础" class="headerlink" title="软件包基础"></a>软件包基础</h1><p>软件包是二进制的应运程序，由二进制文件，库文件，配置文件，帮助文件组成。<br>debian:ded 文件，dpkg 包管理器<br>redhat:rpm 文件，rpm 包管理器</p><h2 id="包的命名：name-VERSION-tar-gz-bz2-xz，常见的CPU架构有X86-64-i386"><a href="#包的命名：name-VERSION-tar-gz-bz2-xz，常见的CPU架构有X86-64-i386" class="headerlink" title="包的命名：name-VERSION.tar.gz|bz2|xz，常见的CPU架构有X86_64,i386,"></a>包的命名：name-VERSION.tar.gz|bz2|xz，常见的CPU架构有X86_64,i386,</h2><p>还有一种跟平台无关noarch .</p><h2 id="包的分类："><a href="#包的分类：" class="headerlink" title="包的分类："></a>包的分类：</h2><p>Application-VERSION-ARCH.rpm: 主包<br>Application-devel-VERSION-ARCH.rpm 开发子包<br>Application-utils-VERSION-ARHC.rpm 其它子包<br>Application-libs-VERSION-ARHC.rpm 其它子包</p><h2 id="库文件"><a href="#库文件" class="headerlink" title="库文件"></a>库文件</h2><p><strong>查看二进制程序所依赖的库文件</strong><br>which pwd<br>ldd /bin/pwd<br>ldconfig<br><strong>通常在系统启动时运行，而当用户安装了一个新的动态链接库时，就需要手工运行这个命令。</strong><br>ldconfig -p:<br><strong>显示本机已经缓存的所有可用库文件名及文件路径</strong><br>映射关系<br>配置文件：/etc/ld.so.conf, /etc/ld.so.conf.d/*.conf<br>缓存文件：/etc/ld.so.cache</p><p><strong>ldconfig几个需要注意的地方：</strong><br> 1.往/lib和/usr/lib里面加东西，是不用修改/etc/ld.so.conf的，但是完了之后要调一下ldconfig，不然这个library会找不到。<br> 2.想往上面两个目录以外加东西的时候，一定要修改/etc/ld.so.conf，然后再调用ldconfig，不然也会找不到。<br> 3.比如安装了一个mysql到/usr/local/mysql，mysql有一大堆library在/usr/local/mysql/lib下面，这时就需要在/etc/ld.so.conf下面加一行/usr/local/mysql/lib，保存过后ldconfig一下，新的library才能在程序运行时被找到。<br> 4.如果想在这两个目录以外放lib，但是又不想在/etc/ld.so.conf中加东西（或者是没有权限加东西）。那也可以，就是export一个全局变量LD_LIBRARY_PATH，然后运行程序的时候就会去这个目录中找library。一般来讲这只是一种临时的解决方案，在没有权限或临时需要的时候使用。<br> 5.ldconfig做的这些东西都与运行程序时有关，跟编译时一点关系都没有。编译的时候还是该加-L就得加，不要混淆了。<br> 6.总之，就是不管做了什么关于library的变动后，最好都ldconfig一下，不然会出现一些意想不到的结果。不会花太多的时间，但是会省很多的事。</p><p><strong>另外包数据库(公共)：/var/lib/rpm在这个目录下，包括</strong></p><ul><li>程序包名称及版本</li><li>依赖关系</li><li>功能说明</li><li>包安装后生成的各文件路径及校验码信息。</li></ul><p><strong>包的管理方式有rpm yum </strong><br>包的来源：<br><a href="https://www.centos.org/download/" target="_blank" rel="noopener">https://www.centos.org/download/</a><br><a href="http://mirrors.aliyun.com" target="_blank" rel="noopener">http://mirrors.aliyun.com</a><br><a href="http://mirrors.sohu.com" target="_blank" rel="noopener">http://mirrors.sohu.com</a><br><a href="http://mirrors.163.com" target="_blank" rel="noopener">http://mirrors.163.com</a></p><h1 id="rpm包管理"><a href="#rpm包管理" class="headerlink" title="rpm包管理"></a>rpm包管理</h1><p>安装、卸载、升级、查询、校验、数据库维护</p><h2 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h2><p>i 是install的缩写，-h 显示包安装的进度<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh packagefile</span><br></pre></td></tr></table></figure></p><h2 id="测试安装"><a href="#测试安装" class="headerlink" title="测试安装"></a>测试安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh packagefile --<span class="built_in">test</span></span><br></pre></td></tr></table></figure><h2 id="不检查合法性"><a href="#不检查合法性" class="headerlink" title="不检查合法性"></a>不检查合法性</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh packagefile --nosignature</span><br></pre></td></tr></table></figure><h2 id="升级："><a href="#升级：" class="headerlink" title="升级："></a>升级：</h2><p>rpm {-U|–upgrade} [install-options] PACKAGE_FILE…<br>-U 如果有旧版本程序包则升级，不存在安装。<br>rpm -Uvh PACKAGE_FILE …<br>–oldpackage：降级<br>rpm -Uvh PACKAGE_FILE –oldpackage<br>–force: 强制安装<br>rpm -Uvh PACKAGE_FILE –force</p><h2 id="查询："><a href="#查询：" class="headerlink" title="查询："></a>查询：</h2><p>rpm {-q|–query} [select-options] [query-options]</p><h2 id="查看系统是否安装命令。"><a href="#查看系统是否安装命令。" class="headerlink" title="查看系统是否安装命令。"></a>查看系统是否安装命令。</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa tree 查询tree命令的包名</span><br><span class="line">rpm -qa |grep <span class="string">"tree"</span> 也就是查看系统是否安装这个命令</span><br></pre></td></tr></table></figure><h2 id="查询程序的文档"><a href="#查询程序的文档" class="headerlink" title="查询程序的文档"></a>查询程序的文档</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qd tree-1.5.3-3.el6.x86_64</span><br></pre></td></tr></table></figure><h2 id="查询程序的配置文件"><a href="#查询程序的配置文件" class="headerlink" title="查询程序的配置文件"></a>查询程序的配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qc tree-1.5.3-3.el6.x86_64</span><br></pre></td></tr></table></figure><h2 id="查看httpd-包有什么能力"><a href="#查看httpd-包有什么能力" class="headerlink" title="查看httpd 包有什么能力"></a>查看httpd 包有什么能力</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -q --provides httpd</span><br></pre></td></tr></table></figure><h2 id="查看命令来源于哪个包"><a href="#查看命令来源于哪个包" class="headerlink" title="查看命令来源于哪个包"></a>查看命令来源于哪个包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> tree</span><br><span class="line">rpm -qf /usr/bin/tree</span><br></pre></td></tr></table></figure><h2 id="查看包里包含哪些文件"><a href="#查看包里包含哪些文件" class="headerlink" title="查看包里包含哪些文件"></a>查看包里包含哪些文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ql tree-1.5.3-3.el6.x86_64</span><br></pre></td></tr></table></figure><h3 id="查看命令的信息"><a href="#查看命令的信息" class="headerlink" title="查看命令的信息"></a>查看命令的信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qi tree</span><br></pre></td></tr></table></figure><h2 id="查看是否有依赖包"><a href="#查看是否有依赖包" class="headerlink" title="查看是否有依赖包"></a>查看是否有依赖包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -q --whatrequires tree</span><br></pre></td></tr></table></figure><h2 id="卸载："><a href="#卸载：" class="headerlink" title="卸载："></a>卸载：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e tree</span><br></pre></td></tr></table></figure><h2 id="校验："><a href="#校验：" class="headerlink" title="校验："></a>校验：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -V  tree</span><br></pre></td></tr></table></figure><h2 id="数据库维护："><a href="#数据库维护：" class="headerlink" title="数据库维护："></a>数据库维护：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -V  centos-release  </span><br><span class="line">rpm  --initdb</span><br></pre></td></tr></table></figure><h1 id="yum管理"><a href="#yum管理" class="headerlink" title="yum管理"></a>yum管理</h1><p>Yellowdog Update Modifier，rpm的前端程序，可解决软件包相关依<br>赖性，可在多个库之间定位软件包，up2date的替代工具<br>yum repository: yum repo，存储了众多rpm包，以及包的相关的元数据<br>文件（放置于特定目录repodata下）</p><h2 id="yum-的配置文件"><a href="#yum-的配置文件" class="headerlink" title="yum 的配置文件"></a>yum 的配置文件</h2><p>/etc/yum.conf：为所有仓库提供公共配置<br>/etc/yum.repos.d/*.repo：为仓库的指向提供配置</p><h2 id="yum-配置文件"><a href="#yum-配置文件" class="headerlink" title="yum 配置文件"></a>yum 配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[repositoryID]</span><br><span class="line">name=Some name <span class="keyword">for</span> this repository</span><br><span class="line">baseurl=url://path/to/repository/</span><br><span class="line">enabled=&#123;1|0&#125;</span><br><span class="line">gpgcheck=&#123;1|0&#125;</span><br><span class="line">gpgkey=URL</span><br><span class="line">enablegroups=&#123;1|0&#125;</span><br><span class="line">failovermethod=&#123;roundrobin|priority&#125;</span><br><span class="line">roundrobin：意为随机挑选，默认值</span><br><span class="line">priority:按顺序访问</span><br><span class="line">cost= 默认为1000</span><br></pre></td></tr></table></figure><h2 id="yum的repo配置文件中可用的变量："><a href="#yum的repo配置文件中可用的变量：" class="headerlink" title="yum的repo配置文件中可用的变量："></a>yum的repo配置文件中可用的变量：</h2><p>$releasever: 当前OS的发行版的主版本号<br>$arch: 平台，i386,i486,i586,x86_64等<br>$basearch：基础平台；i386, x86_64<br>$YUM0-$YUM9:自定义变量<br><a href="http://server/centos/$releasever/$basearch/" target="_blank" rel="noopener">http://server/centos/$releasever/$basearch/</a><br><a href="http://server/centos/7/x86_64" target="_blank" rel="noopener">http://server/centos/7/x86_64</a><br><a href="http://server/centos/6/i384" target="_blank" rel="noopener">http://server/centos/6/i384</a></p><h2 id="yum-源"><a href="#yum-源" class="headerlink" title="yum 源"></a>yum 源</h2><p>yum源<br>阿里云repo文件：<br><a href="http://mirrors.aliyun.com/repo/" target="_blank" rel="noopener">http://mirrors.aliyun.com/repo/</a><br>CentOS系统的yum源<br>阿里云：<a href="https://mirrors.aliyun.com/centos/$releasever/os/x86_64/" target="_blank" rel="noopener">https://mirrors.aliyun.com/centos/$releasever/os/x86_64/</a><br>清华大学：<a href="https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/os/x86_64/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/os/x86_64/</a><br>EPEL的yum源:<br>阿里云：<a href="https://mirrors.aliyun.com/epel/$releasever/x86_64" target="_blank" rel="noopener">https://mirrors.aliyun.com/epel/$releasever/x86_64</a></p><h3 id="客户端生成yum配置文件"><a href="#客户端生成yum配置文件" class="headerlink" title="客户端生成yum配置文件"></a>客户端生成yum配置文件</h3><p>yum-config-manager –add-repo= <a href="http://172.16.0.1/cobbler/ks_mirror/7/" target="_blank" rel="noopener">http://172.16.0.1/cobbler/ks_mirror/7/</a><br>yum-config-manager –disable “仓库名” 禁用仓库<br>yum-config-manager –enable “仓库名” 启用仓库</p><h1 id="yum命令"><a href="#yum命令" class="headerlink" title="yum命令"></a>yum命令</h1><h2 id="yum命令的用法："><a href="#yum命令的用法：" class="headerlink" title="yum命令的用法："></a>yum命令的用法：</h2><p>yum [options] [command] [package …]</p><h2 id="搜索包"><a href="#搜索包" class="headerlink" title="搜索包"></a>搜索包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list <span class="string">"*gcc*"</span></span><br></pre></td></tr></table></figure><h2 id="显示仓库列表"><a href="#显示仓库列表" class="headerlink" title="显示仓库列表"></a>显示仓库列表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum repolist</span><br></pre></td></tr></table></figure><h2 id="安装程序包"><a href="#安装程序包" class="headerlink" title="安装程序包"></a>安装程序包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install 程序包(tree)  -y(不提是否安装)</span><br></pre></td></tr></table></figure><h2 id="重新安装程序包"><a href="#重新安装程序包" class="headerlink" title="重新安装程序包"></a>重新安装程序包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum reinstall 程序包(tree)</span><br></pre></td></tr></table></figure><h2 id="升级程序包"><a href="#升级程序包" class="headerlink" title="升级程序包"></a>升级程序包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum update 程序包(tree) </span><br><span class="line">yum check-update tree  检查更新是否可用</span><br></pre></td></tr></table></figure><h2 id="卸载程序包"><a href="#卸载程序包" class="headerlink" title="卸载程序包"></a>卸载程序包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove tree -y</span><br></pre></td></tr></table></figure><h2 id="查看程序包信息"><a href="#查看程序包信息" class="headerlink" title="查看程序包信息"></a>查看程序包信息</h2><p>查看程序包信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum info tree</span><br></pre></td></tr></table></figure></p><h2 id="查看指定的特性"><a href="#查看指定的特性" class="headerlink" title="查看指定的特性"></a>查看指定的特性</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum provides tree</span><br></pre></td></tr></table></figure><h2 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br></pre></td></tr></table></figure><h2 id="构建缓存"><a href="#构建缓存" class="headerlink" title="构建缓存"></a>构建缓存</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache</span><br></pre></td></tr></table></figure><h2 id="查看可以安装的包组件名"><a href="#查看可以安装的包组件名" class="headerlink" title="查看可以安装的包组件名"></a>查看可以安装的包组件名</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum grouplist </span><br><span class="line">yum groupinfo <span class="string">"Development Tools"</span> 安装开发工具</span><br></pre></td></tr></table></figure><h2 id="查看依赖包"><a href="#查看依赖包" class="headerlink" title="查看依赖包"></a>查看依赖包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">yum deplist package(tree)</span><br><span class="line"><span class="comment">## 查看历史</span></span><br><span class="line">``` bash</span><br><span class="line">yum <span class="built_in">history</span></span><br></pre></td></tr></table></figure><h2 id="下面适合卸载程序使用"><a href="#下面适合卸载程序使用" class="headerlink" title="下面适合卸载程序使用"></a>下面适合卸载程序使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="built_in">history</span> info 6</span><br><span class="line">yum <span class="built_in">history</span> undo 6 </span><br><span class="line">yum <span class="built_in">history</span> redo 6</span><br></pre></td></tr></table></figure><h1 id="实例定制yum仓库"><a href="#实例定制yum仓库" class="headerlink" title="实例定制yum仓库"></a>实例定制yum仓库</h1><h2 id="（1）服务的首先要安装httpd"><a href="#（1）服务的首先要安装httpd" class="headerlink" title="（1）服务的首先要安装httpd"></a>（1）服务的首先要安装httpd</h2><p>   （2）service httpd status（查看httpd状态）<br>   （3）service httpd start （启动服务）<br>   （4）cd var/www/html<br>   （5）mkdir centos/7/os/x86_64/ -pv<br>   （6）mount -o remount,rw /dev/sr0 /var/www/html/centos/7/os/x86_64/ 挂载光盘到港创建的目录<br>   （7）输入 <a href="http://192.168.110.130/centos/7/os/x86_64/就可以访问了" target="_blank" rel="noopener">http://192.168.110.130/centos/7/os/x86_64/就可以访问了</a><br> 上边我们的仓库源就已经创建好了<br> <img src="/Linux/yum本地仓库.png" alt="logo"></p><p><strong>下面开始客户端的配置</strong><br>前面说过了<br>/etc/yum.conf：为所有仓库提供公共配置<br>/etc/yum.repos.d/*.repo：为仓库的指向提供配置<br>我们在/etc/yum.repos.d/ 目录下新建以repo结尾的文件<br>[centos]<br>name=httpserver<br>baseurl=<a href="http://192.168.110.130/centos/7/os/x86_64/" target="_blank" rel="noopener">http://192.168.110.130/centos/7/os/x86_64/</a><br>gpgkey=<a href="http://192.168.110.130/centos/7/os/x86_64/RPM-GPG-KEY-CentOS-6" target="_blank" rel="noopener">http://192.168.110.130/centos/7/os/x86_64/RPM-GPG-KEY-CentOS-6</a><br>gpgcheck=1</p><p><strong>我们可以配置多个源  比如添加来自光盘</strong><br>编辑文件 本地<br>base.repo<br>[cdrom]<br>name=cdrom_repodb<br>baseurl=file:///misc/cd<br>gpgcheck=0</p><p><strong>还可以增加一个epel 源</strong><br>[epel]<br>name=epel<br>baseurl=<a href="http://mirrors.aliyun.com/repo/epel-7.repo" target="_blank" rel="noopener">http://mirrors.aliyun.com/repo/epel-7.repo</a><br>gpgcheck=0</p><p><strong>通过下面命令可以查看当前已经配置的仓库</strong><br>yum repolist </p><p><strong>另外一些小技巧</strong><br>chroot /mnt/sysimage/<br>新建一块光盘或者硬盘如果不出来 可以执行下边的命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'_ _ _'</span> &gt; /sys/class/scsi_host/host2/scan</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'_ _ _'</span> &gt; /sys/class/scsi_host/host1/scan</span><br></pre></td></tr></table></figure></p><h1 id="配置阿里云yum源根EPEL"><a href="#配置阿里云yum源根EPEL" class="headerlink" title="配置阿里云yum源根EPEL"></a>配置阿里云yum源根EPEL</h1><h2 id="配置yum源"><a href="#配置yum源" class="headerlink" title="配置yum源"></a>配置yum源</h2><ol><li><p>备份</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/yum.repos.d/backup; mv /etc/yum.repos.d/*.repo /etc/yum.repos.d/backup</span><br></pre></td></tr></table></figure></li><li><p>下载新的CentOS-Base.repo 到/etc/yum.repos.d/</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> CentOS 5</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-5.repo</span><br><span class="line">CentOS 6</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo</span><br><span class="line">CentOS 7</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure></li><li><p>之后运行yum makecache生成缓存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache</span><br></pre></td></tr></table></figure></li><li><p>yum clean all</p></li><li>yum list<h2 id="配置EPEL源"><a href="#配置EPEL源" class="headerlink" title="配置EPEL源"></a>配置EPEL源</h2><ol><li>同上备份</li><li>下载<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">epel(RHEL 5)</span><br><span class="line">wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-5.repo</span><br><span class="line"></span><br><span class="line">epel(RHEL 6)</span><br><span class="line">wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-6.repo</span><br><span class="line"></span><br><span class="line">epel(RHEL 7)</span><br><span class="line">wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</span><br></pre></td></tr></table></figure></li></ol></li></ol><ol start="3"><li>之后运行yum makecache生成缓存<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rpmyum </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>打包压缩解压</title>
      <link href="/2018/08/09/linuxtar/"/>
      <url>/2018/08/09/linuxtar/</url>
      
        <content type="html"><![CDATA[<blockquote><p> tar命令可以为linux的文件和目录创建档案。利用tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。<br>首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。<br>为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。</p></blockquote><a id="more"></a><h1 id="compress"><a href="#compress" class="headerlink" title="compress"></a>compress</h1><p>压缩<br>compress file<br>-c 选项不删除原文件<br>compress -c file<br>解压<br>compress -d file 或者  uncompress  file<br>这样也可以保留原文件  compress -dc m&gt;m.z</p><h1 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h1><p>压缩<br>gzip file<br>压缩比  1-9 数字越高 压缩比越高<br>cat /etc/fstab |gzip &gt;fstab.gz<br>解压<br>gizip -d 或者 gunzip file </p><h1 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h1><p>压缩<br>bzip2 -k file<br>解压<br>bzip2 -d file</p><h1 id="xz"><a href="#xz" class="headerlink" title="xz"></a>xz</h1><p>压缩<br>xz -k file 保留原文件<br>解压<br>xz -d file 解压<br>xzcat: 不显式解压缩的前提下查看文本文件内容</p><h1 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h1><p>打包压缩<br>zip -r /testdir/sysconfig(目的) /etc/sysconfig/ 原<br>解包解压缩<br>unzip sysconfig.zip </p><h1 id="tar-打包"><a href="#tar-打包" class="headerlink" title="tar  打包"></a>tar  打包</h1><p>语法： tar(选项)(参数)<br>选项<br>-A或–catenate：新增文件到以存在的备份文件；<br>-B：设置区块大小；<br>-c或–create：建立新的备份文件；<br>-C &lt;目录&gt;：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。<br>-d：记录文件的差别；<br>-x或–extract或–get：从备份文件中还原文件；<br>-t或–list：列出备份文件的内容；<br>-z或–gzip或–ungzip：通过gzip指令处理备份文件；<br>-Z或–compress或–uncompress：通过compress指令处理备份文件；<br>-f&lt;备份文件&gt;或–file=&lt;备份文件&gt;：指定备份文件；<br>-v或–verbose：显示指令执行过程；<br>-r：添加文件到已经压缩的文件；<br>-u：添加改变了和现有的文件到已经存在的压缩文件；<br>-j：支持bzip2解压文件；<br>-v：显示操作过程；<br>-l：文件系统边界设置；<br>-k：保留原有文件不覆盖；<br>-m：保留文件不被覆盖；<br>-w：确认压缩文件的正确性；<br>-p或–same-permissions：用原来的文件权限还原文件；<br>-P或–absolute-names：文件名使用绝对名称，不移除文件名称前的“/”号；<br>-N &lt;日期格式&gt; 或 –newer=&lt;日期时间&gt;：只将较指定日期更新的文件保存到备份文件里；<br>–exclude=&lt;范本样式&gt;：排除符合范本样式的文件。<br>参数<br>文件或目录：指定要打包的文件或目录列表。</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="将文件全部打包成tar包："><a href="#将文件全部打包成tar包：" class="headerlink" title="将文件全部打包成tar包："></a>将文件全部打包成tar包：</h2><p>tar -cvf log.tar log2012.log    仅打包，不压缩！<br>tar -zcvf log.tar.gz log2012.log   打包后，以 gzip 压缩<br>tar -jcvf log.tar.bz2 log2012.log  打包后，以 bzip2 压缩 </p><h2 id="在选项f之后的文件档名是自己取的，我们习惯上都用-tar-来作为辨识。-如果加z选项，则以-tar-gz或-tgz来代表gzip压缩过的tar包；如果加j选项，则以-tar-bz2来作为tar包名。"><a href="#在选项f之后的文件档名是自己取的，我们习惯上都用-tar-来作为辨识。-如果加z选项，则以-tar-gz或-tgz来代表gzip压缩过的tar包；如果加j选项，则以-tar-bz2来作为tar包名。" class="headerlink" title="在选项f之后的文件档名是自己取的，我们习惯上都用 .tar 来作为辨识。 如果加z选项，则以.tar.gz或.tgz来代表gzip压缩过的tar包；如果加j选项，则以.tar.bz2来作为tar包名。"></a>在选项f之后的文件档名是自己取的，我们习惯上都用 .tar 来作为辨识。 如果加z选项，则以.tar.gz或.tgz来代表gzip压缩过的tar包；如果加j选项，则以.tar.bz2来作为tar包名。</h2><h2 id="查阅上述tar包内有哪些文件："><a href="#查阅上述tar包内有哪些文件：" class="headerlink" title="查阅上述tar包内有哪些文件："></a>查阅上述tar包内有哪些文件：</h2><p>tar -ztvf log.tar.gz</p><h2 id="由于我们使用-gzip-压缩的log-tar-gz，所以要查阅log-tar-gz包内的文件时，就得要加上z这个选项了。"><a href="#由于我们使用-gzip-压缩的log-tar-gz，所以要查阅log-tar-gz包内的文件时，就得要加上z这个选项了。" class="headerlink" title="由于我们使用 gzip 压缩的log.tar.gz，所以要查阅log.tar.gz包内的文件时，就得要加上z这个选项了。"></a>由于我们使用 gzip 压缩的log.tar.gz，所以要查阅log.tar.gz包内的文件时，就得要加上z这个选项了。</h2><h2 id="将tar包解压缩："><a href="#将tar包解压缩：" class="headerlink" title="将tar包解压缩："></a>将tar包解压缩：</h2><p>tar -zxvf /opt/soft/test/log.tar.gz</p><h2 id="只将tar内的部分文件解压出来："><a href="#只将tar内的部分文件解压出来：" class="headerlink" title="只将tar内的部分文件解压出来："></a>只将tar内的部分文件解压出来：</h2><p>tar -zxvf /opt/soft/test/log30.tar.gz log2013.log</p><h2 id="我可以透过tar-ztvf来查阅-tar-包内的文件名称，如果单只要一个文件，就可以透过这个方式来解压部分文件！"><a href="#我可以透过tar-ztvf来查阅-tar-包内的文件名称，如果单只要一个文件，就可以透过这个方式来解压部分文件！" class="headerlink" title="我可以透过tar -ztvf来查阅 tar 包内的文件名称，如果单只要一个文件，就可以透过这个方式来解压部分文件！"></a>我可以透过tar -ztvf来查阅 tar 包内的文件名称，如果单只要一个文件，就可以透过这个方式来解压部分文件！</h2><h2 id="文件备份下来，并且保存其权限："><a href="#文件备份下来，并且保存其权限：" class="headerlink" title="文件备份下来，并且保存其权限："></a>文件备份下来，并且保存其权限：</h2><p>tar -zcvpf log31.tar.gz log2014.log log2015.log log2016.log</p><h2 id="这个-p的属性是很重要的，尤其是当您要保留原本文件的属性时。"><a href="#这个-p的属性是很重要的，尤其是当您要保留原本文件的属性时。" class="headerlink" title="这个-p的属性是很重要的，尤其是当您要保留原本文件的属性时。"></a>这个-p的属性是很重要的，尤其是当您要保留原本文件的属性时。</h2><h2 id="在文件夹当中，比某个日期新的文件才备份："><a href="#在文件夹当中，比某个日期新的文件才备份：" class="headerlink" title="在文件夹当中，比某个日期新的文件才备份："></a>在文件夹当中，比某个日期新的文件才备份：</h2><p>tar -N “2012/11/13” -zcvf log17.tar.gz test</p><h2 id="备份文件夹内容是排除部分文件："><a href="#备份文件夹内容是排除部分文件：" class="headerlink" title="备份文件夹内容是排除部分文件："></a>备份文件夹内容是排除部分文件：</h2><p>tar –exclude scf/service -zcvf scf.tar.gz scf/*</p><h2 id="C-解压到指定的目录"><a href="#C-解压到指定的目录" class="headerlink" title="-C 解压到指定的目录"></a>-C 解压到指定的目录</h2><p>其实最简单的使用 tar 就只要记忆底下的方式即可：<br>压　缩：tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称<br>查　询：tar -jtv -f filename.tar.bz2<br>解压缩：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 打包压缩 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>find查找工具</title>
      <link href="/2018/08/09/linuxfind/"/>
      <url>/2018/08/09/linuxfind/</url>
      
        <content type="html"><![CDATA[<blockquote><p>find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p></blockquote><a id="more"></a><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>find(选项)(参数)<br>选项<br>-amin&lt;分钟&gt;：查找在指定时间内被存取过的文件或目录，单位以分钟计算；<br>-anewer&lt;参考文件或目录&gt;：查找其存取时间较指定文件或目录的存取时间更接近现在的文件或目录；<br>-atime&lt;24小时数&gt;：查找在指定时间内被存取过的文件或目录，单位以24小时计算；<br>-cmin&lt;分钟&gt;：查找在指定时间之时被更改过的文件或目录；<br>-cnewer&lt;参考文件或目录&gt;查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；<br>-ctime&lt;24小时数&gt;：查找在指定时间之时被更改的文件或目录，单位以24小时计算；<br>-daystart：从本日开始计算时间；<br>-depth：从指定目录下最深层的子目录开始查找；<br>-expty：寻找文件大小为0 Byte的文件，或目录下没有任何子目录或文件的空目录；<br>-exec&lt;执行指令&gt;：假设find指令的回传值为True，就执行该指令；<br>-false：将find指令的回传值皆设为False；<br>-fls&lt;列表文件&gt;：此参数的效果和指定“-ls”参数类似，但会把结果保存为指定的列表文件；<br>-follow：排除符号连接；<br>-fprint&lt;列表文件&gt;：此参数的效果和指定“-print”参数类似，但会把结果保存成指定的列表文件；<br>-fprint0&lt;列表文件&gt;：此参数的效果和指定“-print0”参数类似，但会把结果保存成指定的列表文件；<br>-fprintf&lt;列表文件&gt;&lt;输出格式&gt;：此参数的效果和指定“-printf”参数类似，但会把结果保存成指定的列表文件；<br>-fstype&lt;文件系统类型&gt;：只寻找该文件系统类型下的文件或目录；<br>-gid&lt;群组识别码&gt;：查找符合指定之群组识别码的文件或目录；<br>-group&lt;群组名称&gt;：查找符合指定之群组名称的文件或目录；<br>-help或——help：在线帮助；<br>-ilname&lt;范本样式&gt;：此参数的效果和指定“-lname”参数类似，但忽略字符大小写的差别；<br>-iname&lt;范本样式&gt;：此参数的效果和指定“-name”参数类似，但忽略字符大小写的差别；<br>-inum&lt;inode编号&gt;：查找符合指定的inode编号的文件或目录；<br>-ipath&lt;范本样式&gt;：此参数的效果和指定“-path”参数类似，但忽略字符大小写的差别；<br>-iregex&lt;范本样式&gt;：此参数的效果和指定“-regexe”参数类似，但忽略字符大小写的差别；<br>-links&lt;连接数目&gt;：查找符合指定的硬连接数目的文件或目录；<br>-iname&lt;范本样式&gt;：指定字符串作为寻找符号连接的范本样式；<br>-ls：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出；<br>-maxdepth&lt;目录层级&gt;：设置最大目录层级；<br>-mindepth&lt;目录层级&gt;：设置最小目录层级；<br>-mmin&lt;分钟&gt;：查找在指定时间曾被更改过的文件或目录，单位以分钟计算；<br>-mount：此参数的效果和指定“-xdev”相同；<br>-mtime&lt;24小时数&gt;：查找在指定时间曾被更改过的文件或目录，单位以24小时计算；<br>-name&lt;范本样式&gt;：指定字符串作为寻找文件或目录的范本样式；<br>-newer&lt;参考文件或目录&gt;：查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；<br>-nogroup：找出不属于本地主机群组识别码的文件或目录；<br>-noleaf：不去考虑目录至少需拥有两个硬连接存在；<br>-nouser：找出不属于本地主机用户识别码的文件或目录；<br>-ok&lt;执行指令&gt;：此参数的效果和指定“-exec”类似，但在执行指令之前会先询问用户，若回答“y”或“Y”，则放弃执行命令；<br>-path&lt;范本样式&gt;：指定字符串作为寻找目录的范本样式；<br>-perm&lt;权限数值&gt;：查找符合指定的权限数值的文件或目录；<br>-print：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为每列一个名称，每个名称前皆有“./”字符串；<br>-print0：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为全部的名称皆在同一行；<br>-printf&lt;输出格式&gt;：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式可以自行指定；<br>-prune：不寻找字符串作为寻找文件或目录的范本样式;<br>-regex&lt;范本样式&gt;：指定字符串作为寻找文件或目录的范本样式；<br>-size&lt;文件大小&gt;：查找符合指定的文件大小的文件；<br>-true：将find指令的回传值皆设为True；<br>-typ&lt;文件类型&gt;：只寻找符合指定的文件类型的文件；<br>-uid&lt;用户识别码&gt;：查找符合指定的用户识别码的文件或目录；<br>-used&lt;日数&gt;：查找文件或目录被更改之后在指定时间内被存取过的文件或目录，单位以日计算；<br>-user&lt;拥有者名称&gt;：查找符和指定的拥有者名称的文件或目录；<br>-version或——version：显示版本信息；<br>-xdev：将范围局限在先行的文件系统中；<br>-xtype&lt;文件类型&gt;：此参数的效果和指定“-type”参数类似，差别在于它针对符号连接检查。<br>-i 忽略大小写</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="列出当前目录及子目录下所有文件和文件夹"><a href="#列出当前目录及子目录下所有文件和文件夹" class="headerlink" title="列出当前目录及子目录下所有文件和文件夹"></a>列出当前目录及子目录下所有文件和文件夹</h2><p>find .</p><h2 id="在-home目录下查找以-txt结尾的文件名"><a href="#在-home目录下查找以-txt结尾的文件名" class="headerlink" title="在/home目录下查找以.txt结尾的文件名"></a>在/home目录下查找以.txt结尾的文件名</h2><p>find /home -name “*.txt”</p><h2 id="同上，但忽略大小写"><a href="#同上，但忽略大小写" class="headerlink" title="同上，但忽略大小写"></a>同上，但忽略大小写</h2><p>find /home -iname “*.txt”</p><h2 id="当前目录及子目录下查找所有以-txt和-pdf结尾的文件"><a href="#当前目录及子目录下查找所有以-txt和-pdf结尾的文件" class="headerlink" title="当前目录及子目录下查找所有以.txt和.pdf结尾的文件"></a>当前目录及子目录下查找所有以.txt和.pdf结尾的文件</h2><p>find . ( -name “<em>.txt” -o -name “</em>.pdf” )<br>或<br>find . -name “<em>.txt” -o -name “</em>.pdf” </p><h2 id="匹配文件路径或者文件"><a href="#匹配文件路径或者文件" class="headerlink" title="匹配文件路径或者文件"></a>匹配文件路径或者文件</h2><p>find /usr/ -path “<em>local</em>“</p><h2 id="基于正则表达式匹配文件路径"><a href="#基于正则表达式匹配文件路径" class="headerlink" title="基于正则表达式匹配文件路径"></a>基于正则表达式匹配文件路径</h2><p>find . -regex “.*(.txt|.pdf)$”</p><h2 id="同上，但忽略大小写-1"><a href="#同上，但忽略大小写-1" class="headerlink" title="同上，但忽略大小写"></a>同上，但忽略大小写</h2><p>find . -iregex “.*(.txt|.pdf)$”</p><h2 id="否定参数"><a href="#否定参数" class="headerlink" title="否定参数"></a>否定参数</h2><p>找出/home下不是以.txt结尾的文件<br>find /home ! -name “*.txt”</p><h2 id="根据文件类型进行搜索"><a href="#根据文件类型进行搜索" class="headerlink" title="根据文件类型进行搜索"></a>根据文件类型进行搜索</h2><p>find . -type 类型参数<br>类型参数列表：<br>f 普通文件<br>l 符号连接<br>d 目录<br>c 字符设备<br>b 块设备<br>s 套接字<br>p 管道文件</p><h2 id="基于目录深度搜索"><a href="#基于目录深度搜索" class="headerlink" title="基于目录深度搜索"></a>基于目录深度搜索</h2><p>向下最大深度限制为3<br>find . -maxdepth 3 -type f<br>搜索出深度距离当前目录至少2个子目录的所有文件</p><p>find . -mindepth 2 -type f</p><h2 id="根据文件时间戳进行搜索"><a href="#根据文件时间戳进行搜索" class="headerlink" title="根据文件时间戳进行搜索"></a>根据文件时间戳进行搜索</h2><h2 id="find-type-f-时间戳"><a href="#find-type-f-时间戳" class="headerlink" title="find . -type f 时间戳"></a>find . -type f 时间戳</h2><p>UNIX/Linux文件系统每个文件都有三种时间戳：<br>访问时间（-atime/天，-amin/分钟）：用户最近一次访问时间。<br>修改时间（-mtime/天，-mmin/分钟）：文件最后一次修改时间。<br>变化时间（-ctime/天，-cmin/分钟）：文件数据元（例如权限等）最后一次修改时间。</p><h2 id="搜索最近七天内被访问过的所有文件"><a href="#搜索最近七天内被访问过的所有文件" class="headerlink" title="搜索最近七天内被访问过的所有文件"></a>搜索最近七天内被访问过的所有文件</h2><p>find . -type f -atime -7</p><h2 id="搜索恰好在七天前被访问过的所有文件"><a href="#搜索恰好在七天前被访问过的所有文件" class="headerlink" title="搜索恰好在七天前被访问过的所有文件"></a>搜索恰好在七天前被访问过的所有文件</h2><p>find . -type f -atime 7</p><h2 id="搜索超过七天内被访问过的所有文件"><a href="#搜索超过七天内被访问过的所有文件" class="headerlink" title="搜索超过七天内被访问过的所有文件"></a>搜索超过七天内被访问过的所有文件</h2><p>find . -type f -atime +7</p><h2 id="搜索访问时间超过10分钟的所有文件"><a href="#搜索访问时间超过10分钟的所有文件" class="headerlink" title="搜索访问时间超过10分钟的所有文件"></a>搜索访问时间超过10分钟的所有文件</h2><p>find . -type f -amin +10</p><h2 id="找出比file-log修改时间更长的所有文件"><a href="#找出比file-log修改时间更长的所有文件" class="headerlink" title="找出比file.log修改时间更长的所有文件"></a>找出比file.log修改时间更长的所有文件</h2><p>find . -type f -newer file.log</p><h3 id="根据文件大小进行匹配"><a href="#根据文件大小进行匹配" class="headerlink" title="根据文件大小进行匹配"></a>根据文件大小进行匹配</h3><p>find . -type f -size 文件大小单元</p><p>文件大小单元：<br>b —— 块（512字节）<br>c —— 字节<br>w —— 字（2字节）<br>k —— 千字节<br>M —— 兆字节<br>G —— 吉字节<br>搜索大于10KB的文件<br>find . -type f -size +10k<br>搜索小于10KB的文件<br>find . -type f -size -10k<br>搜索等于10KB的文件<br>find . -type f -size 10k</p><h2 id="删除匹配文件"><a href="#删除匹配文件" class="headerlink" title="删除匹配文件"></a>删除匹配文件</h2><h2 id="删除当前目录下所有-txt文件"><a href="#删除当前目录下所有-txt文件" class="headerlink" title="删除当前目录下所有.txt文件"></a>删除当前目录下所有.txt文件</h2><p>find . -type f -name “*.txt” -delete</p><h2 id="根据文件权限-所有权进行匹配"><a href="#根据文件权限-所有权进行匹配" class="headerlink" title="根据文件权限/所有权进行匹配"></a>根据文件权限/所有权进行匹配</h2><p>当前目录下搜索出权限为777的文件<br>find . -type f -perm 777</p><h2 id="找出当前目录下权限不是644的txt文件"><a href="#找出当前目录下权限不是644的txt文件" class="headerlink" title="找出当前目录下权限不是644的txt文件"></a>找出当前目录下权限不是644的txt文件</h2><p>find . -type f -name “*.txt” ! -perm 644</p><h2 id="找出当前目录用户root拥有的所有文件"><a href="#找出当前目录用户root拥有的所有文件" class="headerlink" title="找出当前目录用户root拥有的所有文件"></a>找出当前目录用户root拥有的所有文件</h2><p>find . -type f -user root</p><h2 id="找出当前目录用户组root拥有的所有文件"><a href="#找出当前目录用户组root拥有的所有文件" class="headerlink" title="找出当前目录用户组root拥有的所有文件"></a>找出当前目录用户组root拥有的所有文件</h2><p>find . -type f -group root</p><h2 id="借助-exec选项与其他命令结合使用"><a href="#借助-exec选项与其他命令结合使用" class="headerlink" title="借助-exec选项与其他命令结合使用"></a>借助-exec选项与其他命令结合使用</h2><h2 id="找出当前目录下所有root的文件，并把所有权更改为用户tom"><a href="#找出当前目录下所有root的文件，并把所有权更改为用户tom" class="headerlink" title="找出当前目录下所有root的文件，并把所有权更改为用户tom"></a>找出当前目录下所有root的文件，并把所有权更改为用户tom</h2><p>find . -type f -user root -exec chown test {} \;</p><h2 id="找出自己家目录下所有的-txt文件并删除"><a href="#找出自己家目录下所有的-txt文件并删除" class="headerlink" title="找出自己家目录下所有的.txt文件并删除"></a>找出自己家目录下所有的.txt文件并删除</h2><p>find $HOME/. -name “*.txt” -ok rm {} \;</p><h2 id="上例中，-ok和-exec行为一样，不过它会给出提示，是否执行相应的操作。"><a href="#上例中，-ok和-exec行为一样，不过它会给出提示，是否执行相应的操作。" class="headerlink" title="上例中，-ok和-exec行为一样，不过它会给出提示，是否执行相应的操作。"></a>上例中，-ok和-exec行为一样，不过它会给出提示，是否执行相应的操作。</h2><h2 id="查找当前目录下所有-txt文件并把他们拼接起来写入到all-txt文件中"><a href="#查找当前目录下所有-txt文件并把他们拼接起来写入到all-txt文件中" class="headerlink" title="查找当前目录下所有.txt文件并把他们拼接起来写入到all.txt文件中"></a>查找当前目录下所有.txt文件并把他们拼接起来写入到all.txt文件中</h2><p>find . -type f -name “*.txt” -exec cat {} \;&gt; all.txt</p><h2 id="将30天前的-log文件移动到old目录中-注意前提old-文件夹要存在"><a href="#将30天前的-log文件移动到old目录中-注意前提old-文件夹要存在" class="headerlink" title="将30天前的.log文件移动到old目录中  注意前提old 文件夹要存在"></a>将30天前的.log文件移动到old目录中  注意前提old 文件夹要存在</h2><p>find . -type f -mtime +30 -name “*.log” -exec cp {} old \;</p><h2 id="找出当前目录下所有-txt文件并以“File-文件名”的形式打印出来"><a href="#找出当前目录下所有-txt文件并以“File-文件名”的形式打印出来" class="headerlink" title="找出当前目录下所有.txt文件并以“File:文件名”的形式打印出来"></a>找出当前目录下所有.txt文件并以“File:文件名”的形式打印出来</h2><p>find . -type f -name “*.txt” -exec printf “File: %s\n” {} \;</p><h2 id="搜索但跳出指定的目录"><a href="#搜索但跳出指定的目录" class="headerlink" title="搜索但跳出指定的目录"></a>搜索但跳出指定的目录</h2><h2 id="查找当前目录或者子目录下所有-txt文件，但是跳过子目录sk"><a href="#查找当前目录或者子目录下所有-txt文件，但是跳过子目录sk" class="headerlink" title="查找当前目录或者子目录下所有.txt文件，但是跳过子目录sk"></a>查找当前目录或者子目录下所有.txt文件，但是跳过子目录sk</h2><p>find . -path “./sk” -prune -o -name “*.txt” -print</p><h2 id="find其他技巧收集"><a href="#find其他技巧收集" class="headerlink" title="find其他技巧收集"></a>find其他技巧收集</h2><h2 id="要列出所有长度为零的文件"><a href="#要列出所有长度为零的文件" class="headerlink" title="要列出所有长度为零的文件"></a>要列出所有长度为零的文件</h2><p>find . -empty</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> find </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>sed 文本处理工具</title>
      <link href="/2018/08/07/linuxSed/"/>
      <url>/2018/08/07/linuxSed/</url>
      
        <content type="html"><![CDATA[<blockquote><p>sed 是一种流编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓存区中，称为”模式空间”（pattern space），接着用sed命令处理缓存区中的内容，处理完成后，把缓存区的内容输出到屏幕，然后继续读入下一行，如果没有碰到入’D’的特殊命令，那会在两个循环之间清空模式空间，但不会清空保留空间。这样不断重复，直到文件末尾。保留空间的初始为空，我们可以认为是一个空行。<br>主要用来编辑一个或者多个文件。</p></blockquote><a id="more"></a><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>用法：sed [option]… ‘script’ inputfile  其中‘script’ 是地址命令</p><h2 id="常用选项："><a href="#常用选项：" class="headerlink" title="常用选项："></a>常用选项：</h2><p> -n :不输出模式空间内容到屏幕，即不自动打印。<br> -e: 多点编辑<br> -f: 从指定文件读取编辑脚本<br> -i: .bak 备份文件并原处编辑<br> -r:支持扩展的正则表达式</p><p> 下面说一下地址命令的概念<br> 地址是匹配出来的文本或者字符串，命令就是对文本或者字符串怎么处理<br> 地址：<br> 同时正则表达式还支持地址范围查找：<br> （1）不给地址对全文进行处理<br> （2）单地址：</p><pre><code>#指定的行，$最后一行/pattern/:被模式匹配到的每一行</code></pre><p> （3）地址范围：</p><pre><code>#,#  表示第几行到第几行/part1/,/part2/ 表示2个模式之间的行#,/part1/   表示第几行到匹配模式的行</code></pre><p> （4）~ 波浪符表示步进<br>      1~2 奇数行<br>      2~2 偶数行</p><h2 id="命令：命令跟选项是不一样的"><a href="#命令：命令跟选项是不一样的" class="headerlink" title="命令：命令跟选项是不一样的"></a>命令：命令跟选项是不一样的</h2><p> d 删除模式空间匹配的行，并立即启用下一轮循环。<br> p 打印当前模式空间的内容，追加到模式输出后边并且只显示影响的行<br> a []text 在指定行后面追加文本，支持使用\n 实现多行追加<br> i []text 在指定行前面追加文本<br> c []text 替换指定文本<br> W /path/file 保存匹配到的内容到文件<br> r /path/file 读取指定文件的文本到模式空间中匹配到的行后边<br> = 为模式空间中的行打印行号<br> ! 模式空间中匹配行取反处理<br> g 行内全局搜索<br> s/// 查找替换，支持使用其他分隔符，s@@@,s###,|||</p><h2 id="sed-替换标记"><a href="#sed-替换标记" class="headerlink" title="sed 替换标记"></a>sed 替换标记</h2><p>g 表示行内全局替换<br>p 表示打印行<br>w 把匹配行写入一个文件<br>x 表示互换模式空间跟保留空间中的文本<br>\1 子串匹配标记<br>&amp; 已匹配字符串标记</p><h2 id="sed-元字符集："><a href="#sed-元字符集：" class="headerlink" title="sed 元字符集："></a>sed 元字符集：</h2><p>^ 匹配行开始，如：/^sed/匹配所有以sed开头的行。<br>$ 匹配行结束，如：/sed$/匹配所有以sed结尾的行。<br>. 匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。</p><ul><li>匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。<br>[] 匹配一个指定范围内的字符，如/[ss]ed/匹配sed和Sed。<br>[^] 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。<br>(..匹配子串，保存匹配的字符，如s/(love)able/\1rs，loveable被替换成lovers。<br>&amp; 保存搜索字符用来替换其他字符，如s/love/<strong>&amp;</strong>/，love这成<strong>love</strong>。<br>\&lt; 匹配单词的开始，如:/\&lt;love/匹配包含以love开头的单词的行。<br>> 匹配单词的结束，如/love>/匹配包含以love结尾的单词的行。<br>x{m} 重复字符x，m次，如：/0{5}/匹配包含5个0的行。<br>x{m,} 重复字符x，至少m次，如：/0{5,}/匹配至少有5个0的行。<br>x{m,n} 重复字符x，至少m次，不多于n次，如：/0{5,10}/匹配5~10个0的行。</li></ul><h2 id="sed-用法实例："><a href="#sed-用法实例：" class="headerlink" title="sed 用法实例："></a>sed 用法实例：</h2><h3 id="替换操作："><a href="#替换操作：" class="headerlink" title="替换操作："></a>替换操作：</h3><p>echo “book”|sed -r ‘s/book/books/‘<br>sed -r ‘s/book/books/‘ file<br>加g 全面替换<br>echo “book”|sed -r ‘s/book/books/g’<br>sed -r ‘s/book/books/g’ file<br>当需要从第N处匹配开始替换时，可以使用/Ng<br> echo ababAbAbAb|sed ‘s/ab/AB/2g’  </p><h3 id="定界符："><a href="#定界符：" class="headerlink" title="定界符："></a>定界符：</h3><p>一般使用/ 作为定界符，当然可以可以使用其他字符| @ #<br>echo “/bin/sed”|sed -r ‘s|sed|cat|g’</p><h3 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h3><p>cat &gt; file &lt;&lt; EOF</p><blockquote><p>aaaaaaaaa<br>bbbbbbbbb</p><p>ccccccccc<br>ddddddddd<br>EOF<br>比如删除文件中的空行<br>sed ‘/^$/d’ file<br>删除第一行<br>sed ‘1d’ file<br>删除最后一行<br> sed ‘$d’ file<br>删除第2行到最后一行<br>sed ‘2,$d’ file<br>删除以a开始的行<br>sed ‘/^a/d’ file<br>已匹配字符串&amp;<br>在第一行后边增加111<br>sed -r ‘s/a*a/&amp;111/g’ file<br>把file文件空行前面加#<br>cat file|sed -r ‘s/^$/#&amp;/‘<br>把file文件带空格前面加#<br>sed -r ‘s/^[[:space:]]/#&amp;/g’  file </p></blockquote><h3 id="子串匹配标记-1"><a href="#子串匹配标记-1" class="headerlink" title="子串匹配标记\1"></a>子串匹配标记\1</h3><p>把主版本号获取出来 CentOS release 6.10 (Final)<br>cat /etc/centos-release |sed -r ‘s/[^0-9]+([0-9]).<em>/\1/‘<br>把字符串this is digit 7 in a number 把digit 去掉<br>echo this is digit 7 in a number|sed -r ‘s/digit ([0-9])/\1/g’<br>echo aaa BBB  输出 BBB aaa<br>echo aaa BBB|sed -r ‘s/([a-z]+) ([A-Z]+)/\2 \1/‘<br>loveable会被替换成lovers，并打印出来：<br>echo loveable|sed -r ‘s/(love)</em>/\1s/‘</p><h3 id="组合多个表达式："><a href="#组合多个表达式：" class="headerlink" title="组合多个表达式："></a>组合多个表达式：</h3><p>sed ‘表达式’ | ‘表达式’ 等价于 sed ‘表达式;表达式’ 等价于 sed -e ‘表达式’ -e ‘表达式’</p><h3 id="多点标记e："><a href="#多点标记e：" class="headerlink" title="多点标记e："></a>多点标记e：</h3><p>删除1到2行，然后把字符c替换成e<br> -e 等价的命令是 –expression：<br> sed -r -e ‘1,2d’ -e ‘s/c/e/g’ file<br> sed -r  ‘1,2d;s/c/e/g’ file<br> sed -r –expression=’1,2d’ –expression=’s/c/e/g’ file<br> 删除字符串开始的空格跟空行<br> sed ‘/^$/d;s/^[[:space:]]*//‘  file </p><h3 id="引用变量："><a href="#引用变量：" class="headerlink" title="引用变量："></a>引用变量：</h3><p>sed表达式可以使用单引号来引用，但是如果表达式内部包含变量字符串，就需要使用双引号。<br>test=HELLO<br>echo hello WORLD|sed “s/hello/$test/“</p><h3 id="选定行的范围，："><a href="#选定行的范围，：" class="headerlink" title="选定行的范围，："></a>选定行的范围，：</h3><p>打印以空格开头空行结尾的行<br>sed -n ‘/^[ ]/,/^$/p’ file</p><h3 id="从文件读入：r"><a href="#从文件读入：r" class="headerlink" title="从文件读入：r"></a>从文件读入：r</h3><p>file里的内容被读进来，显示在与test匹配的行后面，如果匹配多行，则file的内容将显示在所有匹配行的下面：<br>sed ‘/test/r file’ filename</p><h3 id="写入文件-w"><a href="#写入文件-w" class="headerlink" title="写入文件:w"></a>写入文件:w</h3><p>在example中所有包含test的行都被写入file里：<br>sed -n ‘/test/w file’ example</p><h3 id="追加下行a"><a href="#追加下行a" class="headerlink" title="追加下行a\:"></a>追加下行a\:</h3><p> 在包含a 的下一行追加this is  a line<br> sed ‘/.<em>a.</em>/a\this is a line’ file<br> 在bbb行后边追加123<br> cat file|sed -r ‘s/^bbb*/&amp;123/‘</p><h3 id="插入上行i-："><a href="#插入上行i-：" class="headerlink" title="插入上行i\："></a>插入上行i\：</h3><p> 在包含a 的上一行追加this is a line<br> sed ‘/.<em>a.</em>/i\this is a  line’ file </p><h3 id="下一个：n命令"><a href="#下一个：n命令" class="headerlink" title="下一个：n命令"></a>下一个：n命令</h3><p>如果test被匹配，则移动到匹配行的下一行，替换这一行的aa，变为bb，并打印该行，然后继续：<br>sed ‘/test/{ n; s/aa/bb/; }’ file</p><h3 id="保持和获取：h命令和G命令"><a href="#保持和获取：h命令和G命令" class="headerlink" title="保持和获取：h命令和G命令"></a>保持和获取：h命令和G命令</h3><p>在sed处理文件的时候，每一行都被保存在一个叫模式空间的临时缓冲区中，除非行被删除或者输出被取消，否则所有被处理的行都将 打印在屏幕上。接着模式空间被清空，并存入新的一行等待处理。<br>sed -e ‘/test/h’ -e ‘$G’ file<br>在这个例子里，匹配test的行被找到后，将存入模式空间，h命令将其复制并存入一个称为保持缓存区的特殊缓冲区内。第二条语句的意思是，当到达最后一行后，G命令取出保持缓冲区的行，然后把它放回模式空间中，且追加到现在已经存在于模式空间中的行的末尾。在这个例子中就是追加到最后一行。简单来说，任何包含test的行都被复制并追加到该文件的末尾。</p><h3 id="保持和互换：h命令和x命令"><a href="#保持和互换：h命令和x命令" class="headerlink" title="保持和互换：h命令和x命令"></a>保持和互换：h命令和x命令</h3><p>互换模式空间和保持缓冲区的内容。也就是把包含test与check的行互换：<br>sed -e ‘/test/h’ -e ‘/check/x’ file</p><h3 id="打印奇数行货偶数行："><a href="#打印奇数行货偶数行：" class="headerlink" title="打印奇数行货偶数行："></a>打印奇数行货偶数行：</h3><p>sed -n ‘1~2p’ test.txt  #奇数行<br>sed -n ‘2~2p’ test.txt  #偶数行<br>打印匹配字符串的下一行：<br>sed -n ‘/cccc/{n;p}’ file</p><h3 id="删除备份文件"><a href="#删除备份文件" class="headerlink" title="删除备份文件"></a>删除备份文件</h3><p>删除文件的第2行然后备份文件<br>sed -i.bak ‘2d’ file</p><h3 id="附加实例："><a href="#附加实例：" class="headerlink" title="附加实例："></a>附加实例：</h3><p>1、在/etc/default/grub文件中包含LINUX的行后边追加123<br>cat /etc/default/grub|sed -r ‘s/(LINUX.<em>)”/\1 123”/‘<br>cat /etc/default/grub|sed ‘/LINUX/s/“$/ 123”/‘ 写法先找出包含LINUX的行，然后再进行替换<br>2、取出centos 的版本号<br>CentOS Linux release 7.5.1804 (Core)<br> cat /etc/centos-release |sed -r ‘s/[^0-9]</em>([0-9]).<em>/\1/‘<br> 如果 要取 7.5.1804<br> cat /etc/centos-release|sed -r ‘s/[^0-9]</em>([0-9.]+).<em>/\1/‘<br>3、取出支持的cpu类型（/zsh-4.3.11-8.el6.centos.x86_64.rpm 要取x86_64），并且统计总数 /misc/cd/Packages<br>ls /misc/cd/Packages/</em> |sed -r ‘s/.<em>.([^./]+).rpm/\1/‘|sort|uniq -c<br>有点问题需要去掉    1 /misc/cd/Packages/TRANS.TBL<br>4、/etc/fstab 不是#开头的行加上#<br> cat /etc/fstab|sed -r ‘s/[^#](.</em>)/#\1/‘<br> 问题 cat /etc/fstab|sed -r ‘s/[^#].<em>/&amp;/‘ 为什么这样会把所有行都输出呢 ？<br>5、/etc/fstab 以#开头的行去掉#<br> cat /etc/fstab|sed -r ‘s/^#(.</em>)/\1/‘<br>6、获取ip地址<br>ifconfig eth0|sed -n ‘2p’|sed -r ‘s/inet addr:([0-9.]+).<em>/\1/‘<br>7、取出目录名跟基名<br>基名：echo “/etc/sysconfig/network-scripts/“|sed -r ‘s#^.</em>/([^/]+/)#\1#’<br>目录名：echo “/etc/sysconfig/network-scripts/“|sed -r ‘s#(^.<em>/)([^/]+/)#\1#’<br>或者<br>使用grep<br>echo /etc/rc.d/init.d/functions|egrep -o ‘[^/]+/?$’<br>echo /etc/rc.d/init.d/functions|egrep -o  “^.</em>/“<br>8、在所有的文件后边追加随机数<br>ls /data/ |sed -r “s/.*/&amp;_$RANDOM/“<br>9、取出磁盘利用率<br>df |sed -n ‘/sd/p’|grep -Eo ‘[0-9]{1,3}%’<br>10、请把每个单词的首字母改成大写<br>echo “this is a dog” |sed ‘s/\b[a-z]/\u&amp;/g’<br>11、请把每个单词的大写字母转成小写<br>echo “THIS IS A DOG”|sed ‘s/[A-Z]/\l&amp;/g’<br>12、把a.txt b.txt c.txt 改成A.txt B.txt C.txt<br>ls|sed -r ‘s/[[:alpha:]].txt/\u&amp;/‘<br>13、把文件/etc/fstab 中字母都变成大写<br>cat /etc/fstab  |sed -r ‘s/[[:alpha:]]/\u&amp;/g’<br>14、把文件/etc/fstab 中单词首字母变成大写<br>cat /etc/fstab  |sed -r ‘s/\b[[:alpha:]]/\u&amp;/g’<br>15、把文件/etc/httpd/conf/httpd.conf &lt;VirtualHost 跟 &lt;\/VirtualHost 之间的#去掉<br>cat  /etc/httpd/conf/httpd.conf|sed -r ‘/^#&lt;VirtualHost/,/^#&lt;\/VirtualHost&gt;/s/#//‘</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sed </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux sort,uniq,cut,wc</title>
      <link href="/2018/08/07/linuxTrCutOrder%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/"/>
      <url>/2018/08/07/linuxTrCutOrder%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>linux sort,uniq,cut,wc 对标准输入或者文件的替换 删除 排序 统计等等。</p></blockquote><a id="more"></a><h1 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h1><blockquote><p>sort命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出。sort命令既可以从特定的文件，也可以从stdin中获取输入。</p></blockquote><h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2><p>   sort(选项)(参数)</p><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p>-b：忽略每行前面开始出的空格字符；<br>-c：检查文件是否已经按照顺序排序；<br>-d：排序时，处理英文字母、数字及空格字符外，忽略其他的字符；<br>-f：排序时，将小写字母视为大写字母；<br>-i：排序时，除了040至176之间的ASCII字符外，忽略其他的字符；<br>-m：将几个排序号的文件进行合并；<br>-M：将前面3个字母依照月份的缩写进行排序；<br>-n：依照数值的大小排序；<br>-o&lt;输出文件&gt;：将排序后的结果存入制定的文件；<br>-r：以相反的顺序来排序；<br>-t&lt;分隔字符&gt;：指定排序时所用的栏位分隔字符；<br>+&lt;起始栏位&gt;-&lt;结束栏位&gt;：以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>文件：指定待排序的文件列表。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 data]<span class="comment"># cat sort.txt</span></span><br><span class="line">aaaa 1</span><br><span class="line">bbbb 2</span><br><span class="line">cccc 3</span><br><span class="line">cccc 4</span><br><span class="line">eeee 5</span><br><span class="line">aaaa 6</span><br></pre></td></tr></table></figure><p>1）忽略相同行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 data]<span class="comment"># sort -u sort.txt</span></span><br><span class="line">aaaa 1</span><br><span class="line">bbbb 2</span><br><span class="line">cccc 3</span><br><span class="line">eeee 4</span><br></pre></td></tr></table></figure></p><p>或者unqi 也可以<br>2）将第二列数字从小到大排序<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort -nk 2 -t: sort.txt</span><br></pre></td></tr></table></figure></p><p>3）将第二列数字从大到小排序<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort -nrk 2 -t: sort.txt</span><br></pre></td></tr></table></figure></p><h1 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h1><blockquote><p>uniq命令用于报告或忽略文件中的重复行，一般与sort命令结合使用。</p></blockquote><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>uniq(选项)(参数)</p><h2 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h2><p>-c或——count：在每列旁边显示该行重复出现的次数；<br>-d或–repeated：仅显示重复出现的行列；<br>-f&lt;栏位&gt;或–skip-fields=&lt;栏位&gt;：忽略比较指定的栏位；<br>-s&lt;字符位置&gt;或–skip-chars=&lt;字符位置&gt;：忽略比较指定的字符；<br>-u或——unique：仅显示出一次的行列；<br>-w&lt;字符位置&gt;或–check-chars=&lt;字符位置&gt;：指定要比较的字符。</p><h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><p>输入文件：指定要去除的重复行文件。如果不指定此项，则从标准读取数据；<br>输出文件：指定要去除重复行后的内容要写入的输出文件。如果不指定此选项，则将内容显示到标准输出设备（显示终端）。</p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 data]<span class="comment"># cat uniq.txt</span></span><br><span class="line">aaaa 1</span><br><span class="line">bbbb 2</span><br><span class="line">cccc 3</span><br><span class="line">cccc 4</span><br><span class="line">eeee 5</span><br><span class="line">aaaa 6</span><br></pre></td></tr></table></figure><p>1）删除重复行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uniq uniq.txt</span><br><span class="line">sort uniq.txt | uniq</span><br><span class="line">sort -u uniq.txt</span><br></pre></td></tr></table></figure></p><p>2）只显示单行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniq -u uniq.txt</span><br></pre></td></tr></table></figure></p><p>3）统计各行在文件中出现的次数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort uniq.txt |uniq -c</span><br></pre></td></tr></table></figure></p><p>4）在文件中找出重复行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort file.txt | uniq -d</span><br></pre></td></tr></table></figure></p><h1 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h1><blockquote><p>cut命令用来显示行中的指定部分，删除文件中指定字段。cut经常用来显示文件的内容</p></blockquote><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><p>cut(选项)(参数)</p><h2 id="选项-2"><a href="#选项-2" class="headerlink" title="选项"></a>选项</h2><p>-b：仅显示行中指定直接范围的内容；<br>-c：仅显示行中指定范围的字符；<br>-d：指定字段的分隔符，默认的字段分隔符为“TAB”；<br>-f：显示指定字段的内容；<br>-n：与“-b”选项连用，不分割多字节字符；<br>–complement：补足被选择的字节、字符或字段；<br>–out-delimiter=&lt;字段分隔符&gt;：指定输出内容是的字段分割符；<br>–help：显示指令的帮助信息；<br>–version：显示指令的版本信息。</p><h2 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h2><p>文件：指定要进行内容过滤的文件。</p><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><p>例如有一个学生报表信息，包含No、Name、Mark、Percent：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; test.txt &lt;&lt; EOF</span><br><span class="line">No Name Mark Percent</span><br><span class="line">01 tom 69 91</span><br><span class="line">02 jack 71 87</span><br><span class="line">03 alex 68 98</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p><p>1)使用 -f 选项提取指定字段：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut -d <span class="string">" "</span> -f 1 test.txt</span><br></pre></td></tr></table></figure></p><p>2)–complement 选项提取指定字段之外的列（打印除了第二列之外的列）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut -d<span class="string">" "</span> -f2 --complement test.txt</span><br></pre></td></tr></table></figure></p><p>3)使用 -d 选项指定字段分隔符：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut -d <span class="string">" "</span> -f 1 test.txt</span><br></pre></td></tr></table></figure></p><p>4)打印第1个到第3个字符：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut -c1-3 test.txt</span><br></pre></td></tr></table></figure></p><p>5)打印从第5个字符开始到结尾<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut -c5- test.txt</span><br></pre></td></tr></table></figure></p><h1 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h1><blockquote><p>wc命令用来计算数字。利用wc指令我们可以计算文件的Byte数、字数或是列数，若不指定文件名称，或是所给予的文件名为“-”，则wc指令会从标准输入设备读取数据。</p></blockquote><h2 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut -c5- test.txt</span><br></pre></td></tr></table></figure><h2 id="选项-3"><a href="#选项-3" class="headerlink" title="选项"></a>选项</h2><p>-c或–bytes或——chars：只显示Bytes数；<br>-l或——lines：只显示列数；<br>-w或——words：只显示字数。</p><h2 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h2><p>需要统计的文件列表</p><h2 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 data]<span class="comment"># wc test.txt</span></span><br><span class="line"> 4 16 69 test.txt</span><br></pre></td></tr></table></figure><p>代表4行， 16 个单词  69个字数</p><h1 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h1><blockquote><p>tr命令可以对来自标准输入的字符进行替换、压缩和删除。它可以将一组字符变成另一组字符，经常用来编写优美的单行命令，作用很强大</p></blockquote><p>#</p><h2 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h2><p>tr 选项 参数</p><h2 id="选项-4"><a href="#选项-4" class="headerlink" title="选项"></a>选项</h2><p>-c或——complerment：取代所有不属于第一字符集的字符；<br>-d或——delete：删除所有属于第一字符集的字符；<br>-s或–squeeze-repeats：把连续重复的字符以单独一个字符表示；<br>-t或–truncate-set1：先删除第一字符集较第二字符集多出的字符。</p><h2 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h2><p>字符集1：指定要转换或删除的原字符集。当执行转换操作时，必须使用参数“字符集2”指定转换的目标字符集。但执行删除操作时，不需要参数“字符集2”；<br>字符集2：指定要转换成的目标字符集。</p><h2 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h2><p>1）大小写转换<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"HELLO WORLD"</span> | tr <span class="string">'A-Z'</span> <span class="string">'a-z'</span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p><p>2）使用tr 删除字符<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"hello 123 world 456"</span> | tr -d <span class="string">'0-9'</span></span><br><span class="line">hello  world</span><br></pre></td></tr></table></figure></p><p>3）将制表符转换为空格<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat text | tr <span class="string">'\t'</span> <span class="string">' '</span></span><br></pre></td></tr></table></figure></p><p>4）用tr压缩字符，可以压缩输入中重复的字符：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"thissss is      a text linnnnnnne."</span> | tr -s <span class="string">' sn'</span></span><br><span class="line">this is a text line.</span><br></pre></td></tr></table></figure></p><p><strong>tr做数字相加</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 2 3 4 5 6 7 8 9 | xargs -n1 | <span class="built_in">echo</span> $[ $(tr <span class="string">'\n'</span> <span class="string">'+'</span>) 0 ]</span><br></pre></td></tr></table></figure></p><p>5）删除Windows文件“造成”的’^M’字符：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file | tr -s <span class="string">"\r"</span> <span class="string">"\n"</span> &gt; new_file</span><br></pre></td></tr></table></figure></p><p>6) tr 可以用通配符把小写转为大写<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tr <span class="string">'[:lower:]'</span> <span class="string">'[:upper:]'</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort,uniq,cut,wc,tr </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ACL访问控制列表</title>
      <link href="/2018/08/06/linuxAcl/"/>
      <url>/2018/08/06/linuxAcl/</url>
      
        <content type="html"><![CDATA[<blockquote><p>ACL(Access Control List)，访问控制列表。实现灵活的权限管理</p></blockquote><p>用户管理：<a href="https://michaelfxh.github.io/2018/08/02/linuxUser/">用户管理</a><br>一般权限:<a href="https://michaelfxh.github.io/2018/08/03/linux一般权限/">一般权限</a><br>ACL访问控制列表:<a href="https://michaelfxh.github.io/2018/08/06/linuxAcl/">ACL访问控制列表</a><br>suid,sgid:<a href="https://michaelfxh.github.io/2018/08/10/linuxSuidSgidSbit/">suid,sgid</a><br><a id="more"></a></p><h1 id="什么是ACL"><a href="#什么是ACL" class="headerlink" title="什么是ACL"></a>什么是ACL</h1><p>假如有个项目文件目录，对我们部门的人所属人，所属组都有权限，对于其他人来说不给权限的，突然有一天呢，从别的部门来了个同时想要临时性的加入我们的项目，那么一般权限就无法满足我们的需求了，也有办法，但是不太靠谱。比如：<br>1）可以建一个用户，然后加入到组里<br>2）给其他人赋予读写执行权限 这样显然不合理<br>ACL可以灵活的针对某一个用户设置权限，而不影响其他的用户。所以ACL就登场了。</p><h1 id="查看系统是否支持-ACL"><a href="#查看系统是否支持-ACL" class="headerlink" title="查看系统是否支持 ACL"></a>查看系统是否支持 ACL</h1><p>由于ACL是必须依托文件系统的，因此并不是每个文件系统都支持ACL。<br>执行命令<br>tune2fs -l /dev/sda2 | grep options<br>显示 user_xattr acl 表示我们的系统支持acl</p><p>如果不支持可以使用下边命令添加<br>tune2fs -o acl /dev/sda1<br>或者<br>mount -o remount,acl /dev/sda1(挂载点)</p><h1 id="通过ACL设置权限"><a href="#通过ACL设置权限" class="headerlink" title="通过ACL设置权限"></a>通过ACL设置权限</h1><p>ACL的相关的操作主要有 3 个命令，分别是 getface、setfacl和chacl，常用的主要是getfacl 和 setfacl。<br>getfacl    查看文件/目录的ACL设定内容<br>setfacl    设置文件/目录的ACL内容</p><p>setfacl 是使用最多的，基本 ACL 方面的操作都是它,常用的选项<br>-b ：删除所有的 acl 参数<br>-k ：删除预设的 acl 参数<br>-R ：递归设置后面的 acl 参数<br>-d ：设置预设的 acl 参数（只对目录有效，在该目录新建的文件也会使用此ACL默认值）<br>-m ：设置（修改）后面 acl 参数<br>-x ：删除后面指定的 acl 参数</p><p>实例：<br>给用户michael对data目录 增加读执行权限<br>setfacl -m u:michael:rx /data<br>如果是给组赋权限<br>setfacl -m g:组名:rx /data  </p><p>如果希望所有在此目录下建立的文件都可以被michael用户所访问，<br>setfacl -d -m user:michael:rw /data</p><p>查看/data 的权限<br>getfacl data</p><p>删除acl 权限<br>setfacl -b data </p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一般权限</title>
      <link href="/2018/08/03/linux%E4%B8%80%E8%88%AC%E6%9D%83%E9%99%90/"/>
      <url>/2018/08/03/linux%E4%B8%80%E8%88%AC%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p></blockquote><p>用户管理：<a href="https://fengxinhua.cn/2018/08/02/linuxUser/" target="_blank" rel="noopener">用户管理</a><br>一般权限:<a href="https://fengxinhua.cn/2018/08/03/linux一般权限/" target="_blank" rel="noopener">一般权限</a><br>ACL访问控制列表:<a href="https://fengxinhua.cn/2018/08/06/linuxAcl/" target="_blank" rel="noopener">ACL访问控制列表</a><br>suid,sgid:<a href="https://fengxinhua.cn/2018/08/10/linuxSuidSgidSbit/" target="_blank" rel="noopener">suid,sgid</a><br><a id="more"></a></p><h1 id="一般属性"><a href="#一般属性" class="headerlink" title="一般属性"></a>一般属性</h1><blockquote><p>[root@centos6 data]# ls -lih<br>total 40K<br>    11 drwx——. 2 root root  16K Jul 18 16:30 lost+found<br>    18 lrwxrwxrwx. 1 root root   11 Aug 14 09:19 pa2 -&gt; /etc/passwd<br>    12 -rw-r–r–. 1 root root 1.7K Aug 14 08:19 passwd<br>    14 -rw-r–r–. 1 root root 1.7K Aug 14 08:29 passwd1<br>    15 -rw-r–r–. 1 root root 1.8K Aug 14 08:31 profile<br>    13 -rw-r–r–. 1 root root 1.7K Aug 14 10:56 pwd<br>523265 drwx——. 2 root root 4.0K Aug 14 11:28 test<br>130817 drwxr-xr-x. 3 root root 4.0K Aug 14 11:23 testdir</p></blockquote><p>以上总共对应了8段字符，每段字符的解释如下：<br>iNode：节点，文件/目录在文件系统中对应的唯一值<br>文件类型：目录、文件还是其它<br>文件权限：不同用户对该文件所具备的权限<br>链接数目：硬链接数目<br>文件所有者：文件的主人<br>文件所属组：文件所属的组<br>文件大小：<br>文件修改时间：文件最后的访问/修改时间<br>文件名：</p><h2 id="iNode"><a href="#iNode" class="headerlink" title="iNode"></a>iNode</h2><h3 id="1）什么是inode"><a href="#1）什么是inode" class="headerlink" title="1）什么是inode"></a>1）什么是inode</h3><p>每个存储设备被格式为文件系统以后，应该分为2部分，一部分是inode,另外一部分是block。<br>Block是用来存储数据用的。而inode呢，就是用来存储这些数据的信息，这些信息包括文件大小、属主、归属的用户组、读写权限等。</p><h3 id="2）inode-内容"><a href="#2）inode-内容" class="headerlink" title="2）inode 内容"></a>2）inode 内容</h3><blockquote><p>[root@centos6 data]# stat passwd<br>  File: `passwd’<br>  Size: 1671            Blocks: 8          IO Block: 4096   regular file<br>Device: 803h/2051d      Inode: 12          Links: 1<br>Access: (0644/-rw-r–r–)  Uid: (    0/    root)   Gid: (    0/    root)<br>Access: 2018-08-14 08:19:39.006188715 +0800<br>Modify: 2018-08-14 08:19:25.839188877 +0800<br>Change: 2018-08-14 08:19:25.839188877 +0800</p></blockquote><p>由以上信息可以看出，iNode包含如下信息：<br>文件名<br>文件大小（以字节为单位）<br>文件数据的Block位置<br>链接数<br>UID<br>GID<br>文件的执行权限<br>时间戳：atime(最近访问时间)，ctime(状态改变时间)，mtime(最近修改时间)</p><h3 id="3）inode-大小"><a href="#3）inode-大小" class="headerlink" title="3）inode 大小"></a>3）inode 大小</h3><p>我们可以使用 df -i查看系统的iNode总量和使用情况</p><h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><p>Linux文件类型常见的有：普通文件、目录、字符设备文件、块设备文件、符号链接文件等<br>通过file命令可以查看文件类型</p><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><p>Linux的访问权限分为 读、写、执行三种，可以使用 ls -l进行查看：<br>r：可读(4)<br>w：可写(2)，对于目录来说表示可在目录中新建文件<br>x：可执行(1)，对于目录来说为可进入到该目录中<br>-：表示无对应位上的权限</p><h3 id="更改文件权限"><a href="#更改文件权限" class="headerlink" title="更改文件权限"></a>更改文件权限</h3><p>chmod xxx &lt; file-name &gt;<br>chmod u+x,g+w fff　　//为文件fff设置自己可以执行，组员可以写入的权限<br>chmod u=rwx,g=rw,o=r fff<br>chmod 764 fff<br>chmod a+x fff//对文件fff的u,g,o都设置可执行属性<br>chown user:root fff //把文件fff给uesr，添加到root组</p><h2 id="链接数目"><a href="#链接数目" class="headerlink" title="链接数目"></a>链接数目</h2><p>我们知道文件都有文件名与数据，这在 Linux 上被分成两个部分：用户数据 (user data) 与元数据 (metadata)。用户数据，即文件数据块 (data block)，数据块是记录文件真实内容的地方；而元数据则是文件的附加属性，如文件大小、创建时间、所有者等信息。在 Linux 中，元数据中的 inode 号（inode 是文件元数据的一部分但其并不包含文件名，inode 号即索引节点号）才是文件的唯一标识而非文件名。文件名仅是为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块。</p><p>在 Linux 系统中查看 inode 号可使用命令 stat 或 ls -i，文件移动不影响其indoe编号，<br>为了解决文件的共享使用，linux文件系统引入两种链接，硬链接跟软链接（符号链接 即 soft link 或 symbolic link）<br>软链接：<br>又称为符号链接，类似于Windows下的快捷方式，方便文件的查询等,只是一段文字，里面包含着它所指向的文件的名字，系统看到软链接后自动跳到对应的文件位置处进行处理<br>创建方式：ln -s source target<br>硬链接：<br>硬链接相当于为本文件开设了一个新的文件，但两个文件执行同一个iNode,改变一个文件的内容另一个随之改变，相当于“连体婴”；两个文件时平权的，一个删除另一个照样可用<br>创建方式：ln source target</p><p>链接文件带来的好处<br>链接为 Linux 系统解决了文件的共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。</p><p>若一个 inode 号对应多个文件名，则称这些文件为硬链接。换言之，硬链接就是同一个文件使用了多个别名，硬链接可由命令ln oldfile newfile 创建。</p><p>硬链接的特点：<br>1) 文件有相同的 inode 及 data block；<br>2) 只能对已存在的文件进行创建；<br>3) 不能交叉文件系统进行硬链接的创建；<br>4) 不能对目录进行创建，只可对文件创建；<br>5) 删除一个硬链接文件并不影响其他有相同 inode 号的文件。<br>6) 创建硬链接后原文件的链接数不会增加</p><p>软链接与硬链接不同，若文件用户数据块中存放的内容是另一文件的路径名的指向，则该文件就是软连接。软链接就是一个普通文件，只是数据块内容有点特殊。软链接有着自己的 inode 号以及用户数据块<br>1) 软链接有自己的文件属性及权限等；<br>2) 可对不存在的文件或目录创建软链接；<br>3) 软链接可交叉文件系统；<br>4) 软链接可对文件或目录创建；<br>5) 创建软链接时，链接计数 i_nlink 不会增加；<br>6) 删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。<br>ln -s old.file soft.link </p><p>链接相关的命令<br>在 Linux 中查看当前系统已挂着的文件系统类型，除上述使用的命令 df，还可使用命令 mount 或查看文件 /proc/mounts。<br>1）查找在路径 /data 下的文件 data.txt 的软链接<br>find /data -lname data.txt<br>2）查看路径 /home 有相同 inode 的所有硬链接<br>  find /data -samefile /data/old.file<br>3）列出路径 /data/ 下的所有软链接文件<br>find /data/ -type l -ls</p><h2 id="文件的所有者"><a href="#文件的所有者" class="headerlink" title="文件的所有者"></a>文件的所有者</h2><p>chown username file|directory</p><h2 id="文件所属组"><a href="#文件所属组" class="headerlink" title="文件所属组"></a>文件所属组</h2><p>chgrp groupname file|directory</p><h2 id="文件大小"><a href="#文件大小" class="headerlink" title="文件大小"></a>文件大小</h2><p>文件大小即文件锁占用的字节数，这对于文件来说很容易理解，但对于目录，需要清晰的知道目录是什么，占用空间的目的等。<br>1）何为目录<br>目录其实就是文件夹，是一组信息的集合，用于连接和包含各个文件名<br>2）目录内容<br>你可以用 vim 来查看目录锁包含的内容</p><h2 id="修改时间"><a href="#修改时间" class="headerlink" title="修改时间"></a>修改时间</h2><p>1）atime (access time)：<br>最近访问时间，即最近在社么时间访问了该文件<br>2）ctime (changed time)：<br>状态该表时间，即对文件的执行权限进行了修改的时间<br>3）mtime (modify time)：<br>修改时间，即最近什么时候对文件进行了修改</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一般权限 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用户管理</title>
      <link href="/2018/08/02/linuxUser/"/>
      <url>/2018/08/02/linuxUser/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p><p>每个用户账号都拥有一个惟一的用户名和各自的口令。</p><p>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。</p><p>实现用户账号的管理，要完成的工作主要有如下几个方面：</p><p>用户账号的添加、删除与修改。<br>用户口令的管理。<br>用户组的管理。</p></blockquote><p>用户管理：<a href="https://fengxinhua.cn/2018/08/02/linuxUser/" target="_blank" rel="noopener">用户管理</a><br>一般权限:<a href="https://fengxinhua.cn/2018/08/03/linux一般权限/" target="_blank" rel="noopener">一般权限</a><br>ACL访问控制列表:<a href="https://fengxinhua.cn/2018/08/06/linuxAcl/" target="_blank" rel="noopener">ACL访问控制列表</a><br>suid,sgid:<a href="https://fengxinhua.cn/2018/08/10/linuxSuidSgidSbit/" target="_blank" rel="noopener">suid,sgid</a><br><a id="more"></a></p><h1 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h1><p>useradd命令用于Linux中创建的新的系统用户。useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。</p><h2 id="实例创建账号useradd"><a href="#实例创建账号useradd" class="headerlink" title="实例创建账号useradd"></a>实例创建账号useradd</h2><p>选项：<br>-c&lt;备注&gt;：加上备注文字。备注文字会保存在passwd的备注栏位中；<br>-d&lt;登入目录&gt;：指定用户的家目录；<br>-D：变更预设值；<br>-e&lt;有效期限&gt;：指定帐号的有效期限；<br>-f&lt;缓冲天数&gt;：指定在密码过期后多少天即关闭该帐号；<br>-g&lt;群组&gt;：指定用户所属的群组；<br>-G&lt;群组&gt;：指定用户所属的附加群组；<br>-m：自动建立用户的登入目录；<br>-M：不要自动建立用户的登入目录；<br>-n：取消建立以用户名称为名的群组；<br>-r：建立系统帐号；<br>-s<shell>：指定用户登入后所使用的shell；<br>-u<uid>：指定用户id。</uid></shell></p><p>新建用户user1 指定主组sales，附加组为company,employee<br>useradd -g sales -G company,employee user1<br>建立一个新用户，并设置uid<br>useradd  -u 544 user2<br>创建了一个用户sam，其中/user/sam 为sam 的家目录<br>useradd  -d /usr/sam  sam<br>新建了一个用户gem，该用户的登录Shell是 /bin/sh，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。<br>useradd -s /bin/sh -g group -G adm,root gem</p><p>增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。<br>Linux提供了集成的系统管理工具userconf，它可以用来对用户账号进行统一管理。</p><h2 id="实例修改账号usermod"><a href="#实例修改账号usermod" class="headerlink" title="实例修改账号usermod"></a>实例修改账号usermod</h2><p>-c&lt;备注&gt;：修改用户帐号的备注文字；<br>-d&lt;登入目录&gt;：修改用户登入时的目录；<br>-e&lt;有效期限&gt;：修改帐号的有效期限；<br>-f&lt;缓冲天数&gt;：修改在密码过期后多少天即关闭该帐号；<br>-g&lt;群组&gt;：修改用户所属的群组；<br>-G&lt;群组&gt;；修改用户所属的附加群组；<br>-l&lt;帐号名称&gt;：修改用户帐号名称；<br>-L：锁定用户密码，使密码无效；<br>-s<shell>：修改用户登入后所使用的shell；<br>-u<uid>：修改用户ID；<br>-U:解除密码锁定。<br>将用户user1 添加到附加组中<br>usermod -G staff user1<br>修改用户user1 改为user2<br>usermod -G user1 user2 注意user2必须存在</uid></shell></p><h2 id="用户的口令管理passwd"><a href="#用户的口令管理passwd" class="headerlink" title="用户的口令管理passwd"></a>用户的口令管理passwd</h2><p>-d：删除指定用户密码<br>-l：锁定指定用户<br>-u：解锁指定用户<br>-e：强制用户下次登录修改密码<br>-f：强制操作<br>-n mindays：指定最短使用期限<br>-x maxdays：最大使用期限<br>-w warndays：提前多少天开始警告<br>-i inactivedays：非活动期限<br>–stdin：从标准输入接收用户密码<br>echo “PASSWORD” | passwd —stdin USERNAME</p><p>把用户michael的密码删除<br>passwd -d michael </p><p>把用户michael 锁定,使其不能登陆<br>passwd -l michael </p><h2 id="删除账号"><a href="#删除账号" class="headerlink" title="删除账号"></a>删除账号</h2><p>userdel -r 包括家目录一起删除</p><h1 id="用户组的管理"><a href="#用户组的管理" class="headerlink" title="用户组的管理"></a>用户组的管理</h1><h2 id="增加组"><a href="#增加组" class="headerlink" title="增加组"></a>增加组</h2><p>groupadd 选项 用户组<br>-g GID 指定新用户组的组标识号（GID）<br>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同<br>增加了一个新组group1<br>groupadd group1<br>增加了一个新组group2，同时指定新组的组标识号是101<br>groupadd -g 101 group2</p><p>查看用户有哪些组<br>查看某个组里包含哪些用户</p><h2 id="修改组"><a href="#修改组" class="headerlink" title="修改组"></a>修改组</h2><p>groupmod 选项 用户组<br>-g GID 为用户组指定新的组标识号。<br>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。<br>-n新用户组 将用户组的名字改为新名字</p><p>此命令将组group2的组标识号修改为102<br>groupmod -g 102 group2<br>将组group2的标识号改为10000，组名修改为group3<br>groupmod –g 10000 -n group3 group2</p><h2 id="删除组"><a href="#删除组" class="headerlink" title="删除组"></a>删除组</h2><p>groupdel group1</p><p>如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限<br>当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成<br>newgroup root </p><h1 id="与用户账号有关的系统文件"><a href="#与用户账号有关的系统文件" class="headerlink" title="与用户账号有关的系统文件"></a>与用户账号有关的系统文件</h1><p>用户有关的信息shadow<br>例如：jack:X:503:504:::/home/jack/:/bin/bash<br>jack　　//用户名<br>X　　//口令、密码<br>503　　//用户id（0代表root、普通新建用户从500开始）<br>504　　//所在组<br>:　　//描述<br>/home/jack/　　//用户主目录<br>/bin/bash　　//用户缺省Shell<br>用户组相关的信息gshadow<br>例如：jack:$!$:???:13801:0:99999:7:<em>:</em>:<br>jack　　//组名<br>$!$　　//被加密的口令<br>13801　　//创建日期与今天相隔的天数<br>0　　//口令最短位数<br>99999　　//用户口令<br>7　　//到7天时提醒<br><em>　　//禁用天数</em>　　//过期天数</p><h1 id="批量添加用户"><a href="#批量添加用户" class="headerlink" title="批量添加用户"></a>批量添加用户</h1><p>添加和删除用户对每位Linux系统管理员都是轻而易举的事，比较棘手的是如果要添加几十个、上百个甚至上千个用户时，我们不太可能还使用useradd一个一个地添加，必然要找一种简便的创建大量用户的方法。Linux系统提供了创建大量用户的工具，可以让您立即创建大量用户，方法如下：<br>（1）先编辑一个文本用户文件。<br>每一列按照/etc/passwd密码文件的格式书写，要注意每个用户的用户名、UID、宿主目录都不可以相同，其中密码栏可以留做空白或输入x号。一个范例文件user.txt内容如下：<br>user001::600:100:user:/home/user001:/bin/bash<br>user002::601:100:user:/home/user002:/bin/bash<br>user003::602:100:user:/home/user003:/bin/bash<br>user004::603:100:user:/home/user004:/bin/bash<br>user005::604:100:user:/home/user005:/bin/bash<br>user006::605:100:user:/home/user006:/bin/bash<br>（2）以root身份执行命令 /usr/sbin/newusers，从刚创建的用户文件user.txt中导入数据，创建用户：<br> newusers &lt; user.txt<br>然后可以执行命令 vipw 或 vi /etc/passwd 检查 /etc/passwd 文件是否已经出现这些用户的数据，并且用户的宿主目录是否已经创建。<br>（3）执行命令/usr/sbin/pwunconv。<br>将 /etc/shadow 产生的 shadow 密码解码，然后回写到 /etc/passwd 中，并将/etc/shadow的shadow密码栏删掉。这是为了方便下一步的密码转换工作，即先取消 shadow password 功能。<br> pwunconv<br>（4）编辑每个用户的密码对照文件。<br>范例文件 passwd.txt 内容如下：<br>user001:密码<br>user002:密码<br>user003:密码<br>user004:密码<br>user005:密码<br>user006:密码<br>（5）以root身份执行命令 /usr/sbin/chpasswd。<br>创建用户密码，chpasswd 会将经过 /usr/bin/passwd 命令编码过的密码写入 /etc/passwd 的密码栏。<br> chpasswd &lt; passwd.txt<br>（6）确定密码经编码写入/etc/passwd的密码栏后。<br>执行命令 /usr/sbin/pwconv 将密码编码为 shadow password，并将结果写入 /etc/shadow。<br> pwconv</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 用户管理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>正则表达式</title>
      <link href="/2018/08/02/gegexp/"/>
      <url>/2018/08/02/gegexp/</url>
      
        <content type="html"><![CDATA[<blockquote><p>正则表达式处理大量文本字符串定义的一套算法规则，通过一些特殊符号可以快速的查找出要过滤的字符，以行为处理单位。</p></blockquote><a id="more"></a><h1 id="一、为什么学正则表达式"><a href="#一、为什么学正则表达式" class="headerlink" title="一、为什么学正则表达式"></a>一、为什么学正则表达式</h1><p>  简单，高效，极大的提高了我们的工作效率，运维过程中会有很多对字符串或者文本的查找工作。linux 三剑客（grep,sed,awk）都支持正则表达式。</p><h1 id="二、使用注意事项"><a href="#二、使用注意事项" class="headerlink" title="二、使用注意事项"></a>二、使用注意事项</h1><p>  正则表达式跟通配符容易搞混，通配符是对文件名或者目录的查找，二正则表达式是对文本或者字符串的查找。</p><h1 id="三、正则表达式介绍"><a href="#三、正则表达式介绍" class="headerlink" title="三、正则表达式介绍"></a>三、正则表达式介绍</h1><h2 id="基本正则表达式元字符"><a href="#基本正则表达式元字符" class="headerlink" title="基本正则表达式元字符"></a>基本正则表达式元字符</h2><pre><code>. 匹配任意单个字符[] 匹配指定范围内的任意单个字符[^] 匹配指定范围外的任意单个字符[:alnum:] 字母和数字[:alpha:] 代表任何英文大小写字符，亦即 A-Z, a-z[:lower:] 小写字母 [:upper:] 大写字母[:blank:] 空白字符（空格和制表符）[:space:] 水平和垂直的空白字符（比[:blank:]包含的范围广）[:cntrl:] 不可打印的控制字符（退格、删除、警铃...）[:digit:] 十进制数字 [:xdigit:]十六进制数字[:graph:] 可打印的非空白字符[:print:] 可打印字符[:punct:] 标点符号</code></pre><h2 id="正则表达式介绍"><a href="#正则表达式介绍" class="headerlink" title="正则表达式介绍"></a>正则表达式介绍</h2><pre><code>* 匹配前面的字符任意次，包括0次贪婪模式：尽可能长的匹配.* 任意长度的任意字符\? 匹配其前面的字符0或1次\+ 匹配其前面的字符至少1次\{n\} 匹配前面的字符n次\{m,n\} 匹配前面的字符至少m次，至多n次\{,n\} 匹配前面的字符至多n次\{n,\} 匹配前面的字符至少n次^ 行首锚定，用于模式的最左侧$ 行尾锚定，用于模式的最右侧^PATTERN$ 用于模式匹配整行^$ 空行^[[:space:]]*$ 空白行\&lt; 或 \b 词首锚定，用于单词模式的左侧\&gt; 或 \b 词尾锚定；用于单词模式的右侧\&lt;PATTERN\&gt; 匹配整个单词</code></pre><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p> 如果重复单个字符可以在后边加上限定符，如果重复多个字符或者单词呢，可以用小括号括起来()来指定子表达式，然后你可以指定表达式重复的次数，这就是分组。比如匹配ip地址192.168.110.132<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig|grep -w inet|head -n1|egrep -o <span class="string">"([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;"</span></span><br></pre></td></tr></table></figure></p><p> 首先[0-9]匹配1到3位的数字，([0-9]{1,3}.){3}匹配1到3位的数字加上一个英文句号.重复3次，最后加上一个1到3位的数字。<br> 但是ip 地址的范围是0-255，上边的将会匹配256 这是不合法的。我们只能限定他的范围如下：<br> (2[0-5][0-5]|[01]?[0-9][0-9].){3}2[0-5][0-5]|[01]?[0-9][0-9]</p><h2 id="向后引用"><a href="#向后引用" class="headerlink" title="向后引用"></a>向后引用</h2><p> 使用小括号指定一个子表达式后，每个分组有一个组号，从左到右，第一个为1，第二个为2以此类推。<br> 比如我们创建文件test.txt<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; test.txt &lt;&lt; EOF</span><br><span class="line">&gt; go go1 </span><br><span class="line">&gt; EOF</span><br></pre></td></tr></table></figure></p><p> 执行grep -wo go test.txt 结果如下<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go</span><br></pre></td></tr></table></figure></p><p> 但是如果还想匹配go1 中的go呢<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egrep  <span class="string">"(\bgo\b).*\1"</span> test.txt</span><br></pre></td></tr></table></figure></p><h1 id="四、实例介绍"><a href="#四、实例介绍" class="headerlink" title="四、实例介绍"></a>四、实例介绍</h1><p>如下通过常用实例来学习BRE和ERE匹配，源文件url.txt内容如下：<br><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a><br><a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a><br><a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a><br><a href="http://wwwbaiducom" target="_blank" rel="noopener">http://wwwbaiducom</a><br>baidu.com<br>baidu<br>1.url匹配<br>匹配以http或者https开头，并且其后为：并且含有.的串<br>BRE匹配：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">'^https\&#123;0,1\&#125;.*\..*'</span> url.txt</span><br></pre></td></tr></table></figure></p><p>ERE匹配：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">'^https?.*\..*'</span> url.txt</span><br><span class="line">``` </span><br><span class="line">匹配结果如下：</span><br><span class="line">http://www.baidu.com</span><br><span class="line">https://www.baidu.com</span><br><span class="line"></span><br><span class="line">2.Email匹配</span><br><span class="line">示例文件内容为：</span><br><span class="line">hfutwyy@qq.com</span><br><span class="line">aaaa@</span><br><span class="line">aaa@.com</span><br><span class="line">aaa@gmail.com</span><br><span class="line">@@baidu.com</span><br><span class="line"></span><br><span class="line">匹配以字母数字或者下划线开头的多个字符，其后有一个@之后有多个字母数字或者下划线，其中有一个.号</span><br><span class="line">``` bash</span><br><span class="line">grep <span class="string">'^[[:alpha:][:digit:]_]*@[[:alpha:][:digit:]]*\..*'</span> email.txt</span><br><span class="line"> 匹配结果：</span><br><span class="line">hfutwyy@qq.com</span><br><span class="line">aaa@.com</span><br><span class="line">aaa@gmail.com</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>shell脚本</title>
      <link href="/2018/08/02/shell/"/>
      <url>/2018/08/02/shell/</url>
      
        <content type="html"><![CDATA[<blockquote><p>shell是操作系统提供给我们的一种语言，用来将用户的命令输送到内核中执行</p></blockquote><a id="more"></a><h1 id="脚本的规范跟用途"><a href="#脚本的规范跟用途" class="headerlink" title="脚本的规范跟用途"></a>脚本的规范跟用途</h1><h2 id="shell脚本规范"><a href="#shell脚本规范" class="headerlink" title="shell脚本规范:"></a>shell脚本规范:</h2><p>包含一些命令或声明，并符合一定格式的文本文件<br>1、第一行一般为调用使用的语言<br>2、程序名，避免更改文件名为无法找到正确的文件<br>3、版本号<br>4、更改后的时间<br>5、作者相关信息<br>6、该程序的作用，及注意事项<br>7、最后是各版本的更新简要说明</p><h2 id="脚本的用途："><a href="#脚本的用途：" class="headerlink" title="脚本的用途："></a>脚本的用途：</h2><p> 自动化常用命令<br> 执行系统管理和故障排除<br> 创建简单的应用程序<br> 处理文本或文件</p><h1 id="创建第一个脚本"><a href="#创建第一个脚本" class="headerlink" title="创建第一个脚本"></a>创建第一个脚本</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># ------------------------------------------</span></span><br><span class="line"><span class="comment"># Filename: hello.sh</span></span><br><span class="line"><span class="comment"># Revision: 1.1</span></span><br><span class="line"><span class="comment"># Date: 2018/08/01</span></span><br><span class="line"><span class="comment"># Author: michael</span></span><br><span class="line"><span class="comment"># Email: michael@126.com</span></span><br><span class="line"><span class="comment"># Website: www.fengxinhua.cn</span></span><br><span class="line"><span class="comment"># Description: This is the first script</span></span><br><span class="line"><span class="comment"># ------------------------------------------</span></span><br><span class="line"><span class="comment"># Copyright: 2018</span></span><br><span class="line"><span class="comment"># License: GPL</span></span><br><span class="line"><span class="built_in">echo</span> “hello world”</span><br></pre></td></tr></table></figure><h1 id="脚本基本知识"><a href="#脚本基本知识" class="headerlink" title="脚本基本知识"></a>脚本基本知识</h1><h2 id="脚本调试"><a href="#脚本调试" class="headerlink" title="脚本调试"></a>脚本调试</h2><p>检测脚本中的语法错误<br>bash -n /path/to/some_script<br>调试执行<br>bash -x /path/to/some_script</p><h2 id="bash执行顺序"><a href="#bash执行顺序" class="headerlink" title="bash执行顺序"></a>bash执行顺序</h2><p>~/.bashrc –&gt; /etc/bashrc –&gt; /etc/profile.d/*.sh</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量分为强类型，弱类型。强类型不经过强制转换，他永远是这个数据类型。弱类型语言的运行时会隐式做数据类型转换。<br>变量的命名规则：<br>1、不能使程序中的保留字：例如if, for<br>2、只能使用数字、字母及下划线，且不能以数字开头<br>3、见名知义<br>4、统一命名规则：驼峰命名法<br>作用：<br>1、数据存储格式<br>2、参与的运算<br>3、表示的数据范围<br>类型：<br>1、字符<br>2、整型、<br>3、浮点型</p><h3 id="局部变量：生效范围为当前shell进程"><a href="#局部变量：生效范围为当前shell进程" class="headerlink" title="局部变量：生效范围为当前shell进程"></a>局部变量：生效范围为当前shell进程</h3><p>变量赋值：name=‘value’<br>可以使用引用value:<br>(1) 可以是直接字串; name=“root”<br>(2) 变量引用：name=”$USER”<br>(3) 命令引用：name=<code>COMMAND</code> name=$(COMMAND)<br>变量引用：${name} $name<br>“”：弱引用，其中的变量引用会被替换为变量值<br>‘’：强引用，其中的变量引用不会被替换为变量值，而保持原字符串<br>显示已定义的所有变量：set<br>删除变量：unset name</p><h3 id="环境变量：生效范围为当前shell进程及其子进程"><a href="#环境变量：生效范围为当前shell进程及其子进程" class="headerlink" title="环境变量：生效范围为当前shell进程及其子进程"></a>环境变量：生效范围为当前shell进程及其子进程</h3><p>变量声明、赋值：<br>export name=VALUE<br>declare -x name=VALUE<br>变量引用：$name, ${name}<br>显示所有环境变量：<br>env<br>printenv<br>export<br>declare -x<br>删除变量：<br>unset name</p><h3 id="本地变量：生效范围为当前shell进程中某代码片断，通常指函数"><a href="#本地变量：生效范围为当前shell进程中某代码片断，通常指函数" class="headerlink" title="本地变量：生效范围为当前shell进程中某代码片断，通常指函数"></a>本地变量：生效范围为当前shell进程中某代码片断，通常指函数</h3><h3 id="位置变量：-1-2-…来表示，用于让脚本在脚本代码中调用通过命令行传递给它的参数"><a href="#位置变量：-1-2-…来表示，用于让脚本在脚本代码中调用通过命令行传递给它的参数" class="headerlink" title="位置变量：$1, $2, …来表示，用于让脚本在脚本代码中调用通过命令行传递给它的参数"></a>位置变量：$1, $2, …来表示，用于让脚本在脚本代码中调用通过命令行传递给它的参数</h3><p>$1, $2, …：对应第1、第2等参数，shift [n]换位置<br>$0: 命令本身<br>$<em>: 传递给脚本的所有参数，全部参数合为一个字符串<br>$@: 传递给脚本的所有参数，每个参数为独立字符串<br>$#: 传递给脚本的参数的个数<br>$@ $</em> 只在被双引号包起来的时候才会有差异<br>set – 清空所有位置变量</p><h3 id="特殊变量：-0"><a href="#特殊变量：-0" class="headerlink" title="特殊变量：$?, $0, $*, $@, $#,$$"></a>特殊变量：$?, $0, $*, $@, $#,$$</h3><p>$? 上一条命令执行返回的结果正确返回0，错误返回非0<br>$0 脚本的第一个参数，一般指的是脚本名<br>$* 脚本所有的参数<br>$@ 脚本所有的参数<br>$# 脚本中的参数个数<br>$$ </p><h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><p>bash中的算术运算:help let<br>+, -, <em>, /, %取模（取余）, **（乘方）<br>实现算术运算：<br>(1) let var=算术表达式<br>(2) var=$[算术表达式]<br>(3) var=$((算术表达式))<br>(4) var=$(expr arg1 arg2 arg3 …)<br>(5) declare –i var = 数值<br>(6) echo ‘算术表达式’ | bc<br>乘法符号有些场景中需要转义，如</em><br>bash有内建的随机数生成器：$RANDOM（0-32767）<br>echo $[$RANDOM%50] ：0-49之间随机数</p><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><p>非：！<br>! 1 = 0<br>! 0 = 1<br>短路运算<br>短路与<br>第一个为0，结果必定为0<br>第一个为1，第二个必须要参与运算<br> 短路或<br>第一个为1，结果必定为1<br>第一个为0，第二个必须要参与运算<br>异或：^<br> 异或的两个值,相同为假，不同为真</p><h2 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h2><p>判断某需求是否满足，需要由测试机制来实现<br> 专用的测试表达式需要由测试命令辅助完成测试过程<br>评估布尔声明，以便用在条件性执行中<br>• 若真，则返回0<br>• 若假，则返回1<br>测试命令：<br>• test EXPRESSION<br>• [ EXPRESSION ]<br>• [[ EXPRESSION ]]<br> 注意：EXPRESSION前后必须有空白字符<br> 根据退出状态而定，命令可以有条件地运行<br>• &amp;&amp; 代表条件性的AND THEN<br>• || 代表条件性的OR ELSE<br>例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">grep -q no_such_user /etc/passwd \</span><br><span class="line">|| <span class="built_in">echo</span> <span class="string">'No such user'</span></span><br><span class="line">No such user</span><br><span class="line"></span><br><span class="line">ping -c1 -W2 station1 &amp;&gt; /dev/null \</span><br><span class="line">&gt; &amp;&amp; <span class="built_in">echo</span> <span class="string">"station1 is up"</span> \</span><br><span class="line">&gt; || (<span class="built_in">echo</span> <span class="string">'station1 is unreachable'</span>; <span class="built_in">exit</span> 1)</span><br><span class="line">station1 is up</span><br></pre></td></tr></table></figure></p><h2 id="Test命令"><a href="#Test命令" class="headerlink" title="Test命令"></a>Test命令</h2><p>长格式的例子：<br>test “$A” = “$B” &amp;&amp; echo “Strings are equal”<br>test “$A”-eq “$B” &amp;&amp; echo “Integers are equal”<br>简写格式的例子：<br>[ “$A” = “$B” ] &amp;&amp; echo “Strings are equal”<br>[ “$A” -eq “$B” ] &amp;&amp; echo “Integers are equal</p><h2 id="数字测试"><a href="#数字测试" class="headerlink" title="数字测试"></a>数字测试</h2><p>-gt 是否大于<br>-ge 是否大于等于<br>-eq 是否等于<br>-ne 是否不等于<br>-lt 是否小于<br>-le 是否小于等于</p><h2 id="字符串测试"><a href="#字符串测试" class="headerlink" title="字符串测试"></a>字符串测试</h2><p>= 是否等于</p><blockquote><p>ascii码是否大于ascii码<br>&lt; 是否小于<br>!= 是否不等于<br>=~ 左侧字符串是否能够被右侧的PATTERN所匹配<br> 注意: 此表达式一般用于[[ ]]中；扩展的正则表达式<br> -z “STRING“ 字符串是否为空，空为真，不空为假<br> -n “STRING“ 字符串是否不空，不空为真，空为假</p></blockquote><h2 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h2><h3 id="存在性测试"><a href="#存在性测试" class="headerlink" title="存在性测试"></a>存在性测试</h3><p>-a FILE：同-e<br>-e FILE: 文件存在性测试，存在为真，否则为假<br>存在性及类别测试<br>-b FILE：是否存在且为块设备文件<br>-c FILE：是否存在且为字符设备文件<br>-d FILE：是否存在且为目录文件<br>-f FILE：是否存在且为普通文件<br>-h FILE 或 -L FILE：存在且为符号链接文件<br>-p FILE：是否存在且为命名管道文件<br>-S FILE：是否存在且为套接字文件</p><h3 id="权限测试"><a href="#权限测试" class="headerlink" title="权限测试"></a>权限测试</h3><p>-r FILE：是否存在且可读<br>-w FILE: 是否存在且可写<br>-x FILE: 是否存在且可执行<br>文件特殊权限测试：<br>-u FILE：是否存在且拥有suid权限<br>-g FILE：是否存在且拥有sgid权限<br>-k FILE：是否存在且拥有sticky权限</p><h3 id="文件属性测试"><a href="#文件属性测试" class="headerlink" title="文件属性测试"></a>文件属性测试</h3><p>-s FILE: 是否存在且非空<br>-t fd: fd 文件描述符是否在某终端已经打开<br>-N FILE：文件自从上一次被读取之后是否被修改过<br>-O FILE：当前有效用户是否为文件属主<br>-G FILE：当前有效用户是否为文件属组</p><h3 id="文件双目测试"><a href="#文件双目测试" class="headerlink" title="文件双目测试"></a>文件双目测试</h3><p>FILE1 -ef FILE2: FILE1是否是FILE2的硬链接<br>FILE1 -nt FILE2: FILE1是否新于FILE2（mtime）<br>FILE1 -ot FILE2: FILE1是否旧于FILE2</p><h3 id="组合测试条件"><a href="#组合测试条件" class="headerlink" title="组合测试条件"></a>组合测试条件</h3><p>COMMAND1 &amp;&amp; COMMAND2 并且<br>COMMAND1 || COMMAND2 或者<br>第一种<br>[[ -r sort.txt ]] &amp;&amp; [[ -w sort.txt ]] &amp;&amp; echo true<br>第二种<br>EXPRESSION1 -a EXPRESSION2 并且<br>EXPRESSION1 -o EXPRESSION2 或者<br>[ -f /bin/cat -a -x /bin/cat ]<br>[ -z “$HOSTNAME” -o $HOSTNAME “==”localhost.localdomain” ]</p><p>多条件判断<br>第一种<br>[ -r /app/passwd ] || [ -w /app/passwd ] &amp;&amp; echo true<br>[ -r /app/passwd ] &amp;&amp; [ -w /app/passwd ] &amp;&amp; echo true<br>第二种<br>[ -r /app/passwd  -a -w /app/passwd  ] &amp;&amp; echo true<br>[ -r /app/passwd  -o -w /app/passwd  ] &amp;&amp; echo true</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>1、编写脚本/root/bin/systeminfo.sh,显示当前主机系统信息，包括主机名，<br>IPv4地址，操作系统版本，内核版本，CPU型号，内存大小，硬盘大小<br>获取ip地址：<br>ifconfig | grep -Eo “(([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]).){3}([1-9]?[0-9]|[1-9]?[0-9]|2[0-4][0-9]|25[0-5])”</p><p>[[  “$ip” =~ ^(([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]).){3}([1-9]?[0-9]|[1-9]?[0-9]|2[0-4][0-9]|25[0-5])$ ]] &amp;&amp; echo true || echo false</p><p>主机名：hostname<br>ipv4地址：ifconfig | grep -Eo “(([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]).){3}([1-9]?[0-9]|[1-9]?[0-9]|2[0-4][0-9]|25[0-5])” |head -n1<br>操作系统版本：cat /etc/centos-release |sed -r ‘s/[^0-9]<em>([0-9]).</em>/\1/‘<br>内核版本： uname -r<br>cpu型号:lscpu |grep “Model name”|tr -s “ “|cut -d: -f2<br>内存大小： free -mh|head -n 2|tail -n 1|tr -s “ “|cut -d” “ -f2<br>硬盘大小： fdisk -l|head -n 2|tr -s “ “|cut -d” “ -f3,4<br>vim /root/bin/systeminfo.sh</p><p>#! /bin/bash<br>echo ‘主机名：’<code>hostname</code><br>echo ipv4地址：<code>ifconfig | grep -Eo &quot;(([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}([1-9]?[0-9]|[1-9]?[0-9]|2[0-4][0-9]|25[0-5])&quot; |head -n1</code><br>echo 操作系统版本：<code>cat /etc/centos-release |sed -r &#39;s/[^0-9]*([0-9]).*/\1/&#39;</code><br>echo 内核版本： <code>uname -r</code><br>echo cpu型号:<code>lscpu |grep &quot;Model name&quot;|tr -s &quot; &quot;|cut -d: -f2</code><br>echo 内存大小： <code>free -mh|head -n 2|tail -n 1|tr -s &quot; &quot;|cut -d&quot; &quot; -f2</code><br>echo 硬盘大小： <code>fdisk -l|head -n 2|tr -s &quot; &quot;|cut -d&quot; &quot; -f3,4</code><br>2、编写脚本/root/bin/backup.sh，可实现每日将/etc/目录备份到/root/etcYYYY-mm-dd中<br>cp -a /etc/ /root/etc<code>date +%Y-%m-%d</code><br>3、编写脚本/root/bin/disk.sh,显示当前硬盘分区中空间利用率最大的值<br> echo “当前硬盘分区中空间利用率最大的值:$( df |grep -o “[0-9]{1,3}%” |sort -rn |head -1)”<br>4、编写脚本/root/bin/links.sh,显示正连接本主机的每个远程主机的IPv4地址<br>和连接数，并按连接数从大到小排序<br>5、让所有用户的PATH环境变量的值多出一个路径，例如：<br>/usr/local/apache/bin<br>6、用户root登录时，将命令指示符变成红色，并自动启用如下别名：<br>rm=‘rm –i’<br>cdnet=‘cd /etc/sysconfig/network-scripts/’<br>editnet=‘vim /etc/sysconfig/network-scripts/ifcfg-eth0’<br>editnet=‘vim /etc/sysconfig/network-scripts/ifcfg-eno16777736 或 ifcfg-ens33 ’ (如果系<br>统是CentOS7)<br>7、任意用户登录系统时，显示红色字体的警示提醒信息“Hi,dangerous！”<br>9、编写用户的环境初始化脚本reset.sh，包括别名，登录提示符，vim的设置，<br>环境变量等</p><p>cat &lt;&lt; EOF &gt;&gt; ~/.bashrc<br>alias ipconfig=’ifconfig etho’<br>PS1=’[\e[32;40m][\u@\h \W]\$ ‘<br>EOF<br>cat &lt;&lt; EOF &gt;&gt; ~/.vimrc<br>set nu<br>EOF<br>echo ‘echo welcome’ &gt;&gt; /etc/bashrc</p><p>10、编写脚本/bin/per.sh,判断当前用户对指定参数文件，是否不可读并且不可写<br>[ ! -r $1 -a ! -w $1 ] &amp;&amp; echo “$1 file not read and not write”<br>11、编写脚本/root/bin/excute.sh ，判断参数文件是否为sh后缀的普通文件，如<br>果是，添加所有人可执行权限，否则提示用户非脚本文件<br>[ $# == 0 ] &amp;&amp; read -p “please input fimename” name || name=$1<br>[ -f $name ] &amp;&amp; [[ “$name” =~ .sh$ ]] &amp;&amp; chmod a+x $name || echo “$name not scripts file”<br>12、编写脚本/root/bin/nologin.sh和login.sh,实现禁止和充许普通用户登录系统<br>nologin:usermod $1 -s /bin/bash/nolgin<br>login:usermod $1 -s /bin/bash<br>13、编写脚本/root/bin/argsnum.sh，接受一个文件路径作为参数；如果参数<br>个数小于1，则提示用户“至少应该给一个参数”，并立即退出；如果参数个数<br>不小于1，则显示第一个参数所指向的文件中的空白行数<br>[ $# -lt 1 ] &amp;&amp; (echo “please input a arge” &amp;&amp; exit ) || echo “<code>grep &quot;^$&quot; $1 | wc -l</code>“<br>14、编写脚本/root/bin/hostping.sh，接受一个主机的IPv4地址做为参数，测<br>试是否可连通。如果能ping通，则提示用户“该IP地址可访问”；如果不可<br>ping通，则提示用户“该IP地址不可访问”<br>a1=<code>echo $1|cut -d. -f1</code><br>a2=<code>echo $1|cut -d. -f2</code><br>a3=<code>echo $1|cut -d. -f3</code><br>a4=<code>echo $1|cut -d. -f4</code><br>[ $a1 -le 255 ] &amp;&amp; [ $a2 -le 255 ] &amp;&amp; [ $a3 -le 255 ] &amp;&amp; [ $a4 -le 255 ] || echo “IP地址不合法” &amp;&amp; exi<br>t 1<br>ping -c1 -W1 $1 &amp;&gt; /dev/null &amp;&amp; echo “该IP可访问” || echo “该IP不可访问”</p><p>15、编写脚本/root/bin/checkdisk.sh，检查磁盘分区空间和inode使用率，如<br>果超过80%，就发广播警告空间将满<br>usagea=$(df |grep “^/.<em>sd” |egrep -o “[0-9]{1,3}%” |tr -d % |sort -n |tail -1)<br>usageb=$(df -i |grep “^/.</em>sd” |egrep -o “[0-9]{1,3}%” |tr -d % |sort -n |tail -1)<br>[ $usagea -ge 80 -o $usageb -ge 80 ] &amp;&amp; wall warning || echo health<br>16、写一个创建用户的脚本，会询问用户用户名及密码，要求密码输入过程不可见<br>read -p “Please Enter your username: “ name<br>echo -n “Please Enter the password for $name: “<br>stty -echo<br>read password<br>stty echo<br>echo<br>useradd $name<br>echo $password |passwd –stdin $name &amp;&gt; /dev/null<br>echo “$name created”<br>或者<br>read -p “Please Enter your username: “ name<br>read -sp “Please Enter the password for $name: “ password<br>echo<br>useradd $name<br>echo $password |passwd –stdin $name &amp;&gt; /dev/null<br>echo “$name created”<br>17、编写一个脚本，名为/root/bin/createscripts.sh ，当执行该脚本时，输入 createscripts.sh /path/newsh.sh 则会在指定路径生成脚本文件，并涵盖注释信息如下：<br>并自动打开该 文件，开始编辑，在编辑结束后，自动给该脚本加上执行权限。<br>#<br>A=<code>basename $1 |grep -o &quot;\.sh$&quot;</code> </p><p>#echo $A<br>if [ -n “$A” ];then<br>        echo -e “#!/bin/bash \n#” &gt;&gt; $1<br>        echo  “#—————————————“ &gt;&gt; $1<br>        echo  “# Filename:    <code>basename $1</code>“ &gt;&gt; $1<br>        echo  “# Revision:    1.0” &gt;&gt; $1<br>        echo  “# Date:        <code>date +&quot;%F %T&quot;</code>“&gt;&gt; $1<br>        echo  “# Author:      <code>id -nu</code>“ &gt;&gt; $1<br>        echo  “# Email:       <a href="mailto:sezina_f@163.com" target="_blank" rel="noopener">sezina_f@163.com</a>“ &gt;&gt; $1<br>        echo  “# Description:” &gt;&gt; $1<br>        echo  “#—————————————“ &gt;&gt; $1<br>        echo  “# Copyright:   2018 tzx” &gt;&gt; $1<br>        echo  “# License:     GPL” &gt;&gt; $1<br>        echo  &gt;&gt; $1<br>        vim +13 $1<br>        chmod +x $1<br>    else<br>        echo “Usage: Please end file with .sh.”</p><p>fi<br>18、创建用户并修改密码，首次登陆强制修改密码<br>useradd $1<br>echo $1 is created<br>echo magedu | passwd –stdin $1  &amp;&gt;/dev/null<br>passwd -e  $1 &amp;&gt; /dev/null<br>echo $1 password is reset</p><p>19、提示用户输入yes or no<br>read -p “Please input yes or no: “ answer<br>[[ “$answer” =~   ^<a href="[Ee][Ss]">Yy</a>?$ ]] &amp;&amp;  echo Your answer is YES &amp;&amp; exit<br>[[ “$answer” =~   ^[Nn][Oo]?$ ]] &amp;&amp;  echo Your answer is NO  &amp;&amp; exit<br>echo “Your answer is false,please input yes or no</p><p>20、 判断字符串是否为空<br>-z 当串的长度为0时为真<br>-n 当串的长度大于0时为真<br>STRING=$1<br>if [ -z “$STRING” ]; then<br>    echo “STRING is empty”<br>fi<br>if [ -n “$STRING” ]; then<br>    echo “STRING is not empty”<br>fi</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell script </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>grep使用</title>
      <link href="/2018/08/02/grep/"/>
      <url>/2018/08/02/grep/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;Linux  文本处理三剑客之一，<br>Grep 是文本过滤工具,根据用户指定的模式对目标文本逐行进行匹配检查；最后打印匹配到的行。<br>REGEXP是由一类特殊字符及文本字符所编写的模式，其中有些字符（元字符）不表示字符字面意义，而表示控制或通配的功能，分为BRE基本正则 跟 ERE扩展正则<br>模式：由正则表达式字符及文本字符所编写的过滤条件.</p></blockquote><a id="more"></a><h1 id="一、grep-基本用法"><a href="#一、grep-基本用法" class="headerlink" title="一、grep 基本用法"></a>一、grep 基本用法</h1> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   grep [options]  pattern  [file...]</span><br><span class="line">例子：grep root /etc/passwd </span><br><span class="line">在passwd文件中搜索当前用户也可以写成下面格式</span><br><span class="line">grep <span class="string">"<span class="variable">$USER</span>"</span> /etc/passwd 搜索结果 root:x:0:0:root:/root:/bin/bash</span><br><span class="line">grep ‘<span class="variable">$USER</span>’ /etc/passwd 如果写成单引号模式他将把<span class="variable">$USER</span>当做字符串而不是变量来搜索，所以结果为空</span><br><span class="line">pattern 除了可以用变量也可以用命令比如：</span><br><span class="line">grep `whoami` /etc/passwd</span><br></pre></td></tr></table></figure><h1 id="二、grep-命令选项介绍"><a href="#二、grep-命令选项介绍" class="headerlink" title="二、grep 命令选项介绍"></a>二、grep 命令选项介绍</h1><p>–color=auto 对匹配到的文本着色显示<br>用法：\grep root /etc/passwd –color=auto<br>-v 显示不被匹配到的行<br>用法：grep -v root /etc/passwd 将显示除了root 之外的行<br>-i 忽略大小写<br>用法:grep -i ROOT /etc/passwd<br>-n 显示匹配的行号<br>-c 统计匹配的行数<br>-o 仅显示匹配到的字符串<br>-q 静默模式，不输出任何信息<br>-A # 后#行 #代表数字<br>用法：grep -A2 root /etc/passwd 将显示出包括root匹配行跟后边的2行<br>-B # 前#行<br>-C# 前后个#行<br>-e 实现多个选项间的逻辑or关系<br>用法：grep -e ‘cat’ -e ‘dog’  file<br>-w 匹配整个单词<br>-E 使用扩展正则表达式ERE<br>-F相当于fgrep ,按字符串搜索，不支持正则表达式<br>用法：fgrep “root” /etc/passwd</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> grep </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>文件管理</title>
      <link href="/2018/08/01/linuxfile/"/>
      <url>/2018/08/01/linuxfile/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文将介绍最常见的顶级目录，并且可能作为Linux系统的用户进行交互。</p></blockquote><a id="more"></a><h1 id="一-Linux目录结构和文件系统层次结构"><a href="#一-Linux目录结构和文件系统层次结构" class="headerlink" title="一 Linux目录结构和文件系统层次结构"></a>一 Linux目录结构和文件系统层次结构</h1><p>描述<br>/        名为“root”的目录。它是文件系统层次结构的起点。 请注意，这与root用户或超级用户帐户无关。<br>/bin    二进制文件和其他可执行程序。<br>/etc    系统配置文件。<br>/home    主页目录。<br>/opt    可选或第三方软件。<br>/tmp    临时空间，通常在重新启动时清除。<br>/usr    用户相关程序。<br>/var    可变数据，尤其是日志文件。</p><p>Linux目录结构就像一棵树。 Linux文件系统层次结构的基础从根开始。 目录分支根目录，但一切都从root开始。<br>Linux中的目录分隔符是正斜杠（/）。 在谈论目录和说话目录路径时，“正斜杠”缩写为“斜杠”。文件系统的根通常被称为“斜杠”，因为它的完整路径是/ 。 如果你听到有人说“斜线”或“该文件是斜线”，则它们指的是根目录。<br><img src="/Linux/linux-folders.jpg" alt="logo"></p><p>/bin目录是您可以找到二进制或可执行文件的位置。 程序用源代码编写，源代码是人类可读的文本。 然后将源代码编译成机器可读的二进制文件。 它们被称为二进制文件，因为机器代码是一系列零和一。 要知道的导入事项是，您可以使用的命令，程序和应用程序有时位于/bin 。</p><p>配置文件位于/etc目录中。 配置文件控制操作系统或应用程序的行为方式。 例如， /etc中有一个文件告诉操作系统是启动文本模式还是图形模式。</p><p>用户主目录位于/home 。 如果您的帐户名称为“pat”，则您的主目录将为/home/pat 。 Linux系统可以并且通常具有多个用户帐户。 主目录允许每个用户将他们的数据与系统上的其他用户分开。 pat目录被称为子目录。 子目录只是一个驻留在另一个目录中的目录。</p><p>/opt目录包含可选或第三方软件。 未与操作系统捆绑在一起的软件通常安装在/opt 。 例如， Google地球应用程序不是标准Linux操作系统的一部分，而是安装在/opt/google/earth目录中。</p><p>临时空间在/tmp分配。 大多数Linux发行版在启动时清除/tmp的内容。 请注意，如果您将文件放在/tmp并且Linux系统重新启动，那么您的文件很可能会消失。 /tmp目录是存储临时文件的好地方，但是不要在/tmp中放置任何想要长期保存的内容。</p><p>/usr目录称为“user”。您将在/usr/bin目录中找到与用户相关的二进制程序和可执行文件。</p><p>日志文件等可变数据驻留在/var 。 具体来说， /var/log目录包含操作系统和其他应用程序生成的日志。</p><p>其中<br>-：普通文件<br>d: 目录文件<br>b: 块设备<br>c: 字符设备<br>l: 符号链接文件<br>p: 管道文件pipe<br>s: 套接字文件socket</p><h1 id="二-对文件的查看，复制，删除，移动"><a href="#二-对文件的查看，复制，删除，移动" class="headerlink" title="二 对文件的查看，复制，删除，移动"></a>二 对文件的查看，复制，删除，移动</h1><h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><blockquote><p>cp命令用来将一个或多个源文件或者目录复制到指定的目的文件或目录。它可以将单个源文件复制成一个指定文件名的具体的文件或一个已经存在的目录下。cp命令还支持同时复制多个文件，当一次复制多个文件时，目标文件参数必须是一个已经存在的目录，否则将出现错误。</p></blockquote><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>cp(选项)(参数)</p><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>-a：此参数的效果和同时指定”-dpR”参数相同；<br>-d：当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录；<br>-f：强行复制文件或目录，不论目标文件或目录是否已存在；<br>-i：覆盖既有文件之前先询问用户；<br>-l：对源文件建立硬连接，而非复制文件；<br>-p：保留源文件或目录的属性；<br>-R/r：递归处理，将指定目录下的所有文件与子目录一并处理；<br>-s：对源文件建立符号连接，而非复制文件；<br>-u：使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件；<br>-S：在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀；<br>-b：覆盖已存在的文件目标前将目标文件备份；<br>-v：详细显示命令执行的操作。</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>源文件：指定源文件列表。默认情况下，cp命令不能复制目录，如果要复制目录，则必须使用-R选项；<br>目标文件：指定目标文件。当“源文件”为多个文件时，要求“目标文件”为指定的目录。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><strong>如果把一个文件复制到一个目标文件中，而目标文件已经存在，那么，该目标文件的内容将被破坏。此命令中所有参数既可以是绝对路径名，也可以是相对路径名。通常会用到点.或点点..的形式。例如，下面的命令将指定文件复制到当前目录下：</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ../data1/ff .</span><br></pre></td></tr></table></figure></p><p><strong>将文件passwd复制到目录/data/下，并改名为pwd</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/passwd /data/<span class="built_in">pwd</span></span><br></pre></td></tr></table></figure></p><p><strong>将目录/data/下的所有文件及其子目录复制到目录/data1/中</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r /data/ /data1/</span><br></pre></td></tr></table></figure></p><p><strong>交互式地将目录/data/中的以m打头的所有.c文件复制到目录/data1/中</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -i /data/m*.c /data1/</span><br></pre></td></tr></table></figure></p><h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><blockquote><p>mv命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。source表示源文件或目录，target表示目标文件或目录。如果将一个文件移到一个已经存在的目标文件中，则目标文件的内容将被覆盖。</p><p>mv命令可以用来将源文件移至一个目标文件中，或将一组文件移至一个目标目录中。源文件被移至目标文件有两种不同的结果：</p><p>如果目标文件是到某一目录文件的路径，源文件会被移到此目录下，且文件名不变。<br>如果目标文件不是目录文件，则源文件名（只能有一个）会变为此目标文件名，并覆盖己存在的同名文件。如果源文件和目标文件在同一个目录下，mv的作用就是改文件名。当目标文件是目录文件时，源文件或目录参数可以有多个，则所有的源文件都会被移至目标文件中。所有移到该目录下的文件都将保留以前的文件名。<br>注意事项：mv与cp的结果不同，mv好像文件“搬家”，文件个数并未增加。而cp对文件进行复制，文件个数增加了。</p></blockquote><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>mv(选项)(参数)</p><h3 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h3><p>–backup=&lt;备份模式&gt;：若需覆盖文件，则覆盖前先行备份；<br>-b：当文件存在时，覆盖前，为其创建一个备份；<br>-f：若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文件或目录；<br>-i：交互式操作，覆盖前先行询问用户，如果源文件与目标文件或目标目录中的文件同名，则询问用户是否覆盖目标文件。用户输入”y”，表示将覆盖目标文件；输入”n”，表示取消对源文件的移动。这样可以避免误将文件覆盖。<br>–strip-trailing-slashes：删除源文件中的斜杠“/”；<br>-S&lt;后缀&gt;：为备份文件指定后缀，而不使用默认的后缀；<br>–target-directory=&lt;目录&gt;：指定源文件要移动到目标目录；<br>-u：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。</p><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p>源文件：源文件列表。<br>目标文件：如果“目标文件”是文件名则在移动文件的同时，将其改名为“目标文件”；如果“目标文件”是目录名则将源文件移动到“目标文件”下。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p><strong>将pa1重命名为pa2</strong><br>mv pa1 pa2</p><p><strong>将/data 下的所有文件移动到/data1 下</strong><br>mv /data/* /data1/</p><h2 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h2><blockquote><p> mkdir命令用来创建目录。该命令创建由dirname命名的目录。如果在目录名的前面没有加任何路径名，则在当前目录下创建由dirname指定的目录；如果给出了一个已经存在的路径，将会在该目录下创建一个指定的目录。在创建目录时，应保证新建的目录与它所在目录下的文件没有重名。 </p><p>注意：在创建文件时，不要把所有的文件都存放在主目录中，可以创建子目录，通过它们来更有效地组织文件。最好采用前后一致的命名方式来区分文件和目录。例如，目录名可以以大写字母开头，这样，在目录列表中目录名就出现在前面。</p><p>在一个子目录中应包含类型相似或用途相近的文件。例如，应建立一个子目录，它包含所有的数据库文件，另有一个子目录应包含电子表格文件，还有一个子目录应包含文字处理文档，等等。目录也是文件，它们和普通文件一样遵循相同的命名规则，并且利用全路径可以唯一地指定一个目录。</p></blockquote><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p>mkdir (选项)(参数)</p><h3 id="选项-2"><a href="#选项-2" class="headerlink" title="选项"></a>选项</h3><p>-Z：设置安全上下文，当使用SELinux时有效；<br>-m&lt;目标属性&gt;或–mode&lt;目标属性&gt;建立目录的同时设置目录的权限；<br>-p或–parents 若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录；<br>–version 显示版本信息。</p><h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><p>目录：指定要创建的目录列表，多个目录之间用空格隔开。</p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p><strong>在目录/data/下建立子目录test，并且只有文件主有读、写和执行权限，其他人无权访问</strong><br>mkdir -m 700 /data/test</p><h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><blockquote><p>ls命令用来显示目标列表，在Linux中是使用率较高的命令。ls命令的输出信息可以进行彩色加亮显示，以分区不同类型的文件。</p></blockquote><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><p>ls（选项）（参数）</p><h3 id="选项-3"><a href="#选项-3" class="headerlink" title="选项"></a>选项</h3><p>-a：显示所有档案及目录（ls内定将档案名或目录名称为“.”的视为影藏，不会列出）；<br>-A：显示除影藏文件“.”和“..”以外的所有文件列表；<br>-C：多列显示输出结果。这是默认选项；<br>-l：与“-C”选项功能相反，所有输出信息用单列格式输出，不输出为多列；<br>-F：在每个输出项后追加文件的类型标识符，具体含义：“<em>”表示具有可执行权限的普通文件，“/”表示目录，“@”表示符号链接，“|”表示命令管道FIFO，“=”表示sockets套接字。当文件为普通文件时，不输出任何标识符；<br>-b：将文件中的不可输出的字符以反斜线“”加字符编码的方式输出；<br>-c：与“-lt”选项连用时，按照文件状态时间排序输出目录内容，排序的依据是文件的索引节点中的ctime字段。与“-l”选项连用时，则排序的一句是文件的状态改变时间；<br>-d：仅显示目录名，而不显示目录下的内容列表。显示符号链接文件本身，而不显示其所指向的目录列表；<br>-f：此参数的效果和同时指定“aU”参数相同，并关闭“lst”参数的效果；<br>-i：显示文件索引节点号（inode）。一个索引节点代表一个文件；<br>–file-type：与“-F”选项的功能相同，但是不显示“</em>”；<br>-k：以KB（千字节）为单位显示文件大小；<br>-l：以长格式显示目录下的内容列表。输出的信息从左到右依次包括文件名，文件类型、权限模式、硬连接数、所有者、组、文件大小和文件的最后修改时间等；<br>-m：用“,”号区隔每个文件和目录的名称；<br>-n：以用户识别码和群组识别码替代其名称；<br>-r：以文件名反序排列并输出目录内容列表；<br>-s：显示文件和目录的大小，以区块为单位；<br>-t：用文件和目录的更改时间排序；<br>-L：如果遇到性质为符号链接的文件或目录，直接列出该链接所指向的原始文件或目录；<br>-R：递归处理，将指定目录下的所有文件及子目录一并处理；<br>–full-time：列出完整的日期与时间；<br>–color[=WHEN]：使用不同的颜色高亮显示不同类型的。</p><h3 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h3><p>目录：指定要显示列表的目录，也可以是具体的文件。</p><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p><strong>显示当前目录非隐藏的文件与目录</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure></p><p><strong>显示当前目录下包括影藏文件在内的所有文件列表</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -a</span><br></pre></td></tr></table></figure></p><p><strong>输出长格式列表</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l</span><br></pre></td></tr></table></figure></p><p><strong>显示inode 编号</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -i</span><br></pre></td></tr></table></figure></p><p><strong>最近修改的文件显示在前面</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -t</span><br></pre></td></tr></table></figure></p><p><strong>列出可读文件和文件夹详细信息</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -lh</span><br></pre></td></tr></table></figure></p><p><strong>列出文件并标记颜色分类</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls --color=auto</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件管理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux 入门安装</title>
      <link href="/2018/07/19/linuxInstall/"/>
      <url>/2018/07/19/linuxInstall/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Linux是一个开源的操作系统，它最初是芬兰的Helsinki大学的一位年轻的学生Linux Torvalds作为爱好开发的。Linus对Minix(一个小型的UNIX系统)很感兴趣，并且决定开发一个比Minix更好的系统。他在1991年开始开发并且当年发布0.02版本，他坚持继续开发直到1994年Linux内核1.0版本的发布。它的内核，就是所有Linux系统的核心，是在GNU通用公共许可证开发和发布的,它的源码是对每个人都是免费的。这个内核建立了Linux操作系统的开发最基本部分。现在有很多公司、组织和团队发布他们自己基于Linux内核开发的操作系统版本。</p></blockquote><a id="more"></a><h1 id="一，为啥要学习linux"><a href="#一，为啥要学习linux" class="headerlink" title="一，为啥要学习linux"></a>一，为啥要学习linux</h1><p>  首先技术的价值不在于这个技术有多牛逼，而是这个技术本身给我们带来的价值，所以学习一个技术的时候一定要知道它的使用场景，给我们带来的便利性。Linux 免费，稳定，性能好。<br>  注意点<br>  1.在Linux系统所有的内容都是文件的形式存储<br>  2.我们在学习字符版的Linux系统中，我们所输入的命令是严格区分大小写的<br>  3.Linux中的文件不是通过后缀名来区分文件类型，而是通过权限，具体的后面的教程会讲到<br>  4.windows系统中的程序不能直接拿到Linux系统安装和使用<br>  5.当我们插入U盘或者其他存储设备，Linux不能直接读取使用，我们需要一个挂载的过程，才可以使用。</p><h1 id="二，安装linux"><a href="#二，安装linux" class="headerlink" title="二，安装linux"></a>二，安装linux</h1><p> 首先介绍一下linux 分区的概念，主要分为2种格式：MBR,GPT.其中MBR 又分为主分区，扩展分区，逻辑分区。<br> 主分区：一个硬盘最多4个，主分区是最小单位，只有一个活动的主分区（用于启动计算机）<br> 扩展分区：一个硬盘最多只有一个扩展分区，内部可以再划分小分区即逻辑分区，不能直接使用，必须划分为逻辑分区。<br> 逻辑分区：从5-？开始编号  sda5……<br> 接下来介绍下我们练习时候的一个分区规划：<br> Sda1  boot   1G<br> Sda2  /      50G<br> Sda3  /data  30G<br> Sda4<br> Sda5  swap   2G    物理内存的2倍  可以通过free -h 查看</p><p> #（1）安装Vmware虚拟机<br>   <img src="/Linux/20180303150433729.jpg" alt="logo"><br>   <img src="/Linux/2.jpg" alt="logo"><br>   <img src="/Linux/3.jpg" alt="logo"><br>   <img src="/Linux/4.jpg" alt="logo"></p><p>  #（1）给虚拟机安装Linux系统<br>   <img src="/Linux/5.png" alt="logo"><br>   <img src="/Linux/6.png" alt="logo"><br>   <img src="/Linux/7.png" alt="logo"></p><p>   系统的安装还是比较简单的，不一个一个列出了，有点困了，以后有时间补充。下面重点说下挂载点概念</p><p>   给我们的Linux系统区分并且格式化，我们在安装windows系统的时候也需要对硬盘进行分区并且进行格式化操作。没有格式化的硬盘是不能保存文件的。请勿弄错，弄错可能会导致无法启动Linux。我们看到的sda是我们的第一块硬盘，我们选择标准分区，然后点击创建。<br> 什么是挂载点？<br>   挂载就是相当于我们windows给硬盘分区格式化的一个过程，挂载点就相当于我们windows系统中的C盘、D盘、E盘。<br> 1 选择系统挂载点，第一步先选择Boot，Boot是我们系统启动时所需要的，大小200兆就足够了。（下图2）<br> 2 swap分区，swap在分区的时候是没有挂载点的，因为swap不是给我们用户使用的，而是提供给linux内核进行使用。大小1G就够了，  我们在给swap分区，在挂载点是找不到swap的，在挂载点下有个系统类型选择swap即可。（下图3）<br> 3 然后再分data分区，用于我们学习测试使用。<br> 4 最后在给 “根目录”分区，根目录就是在选择挂载点的第一个 “/”,然后下面有个选择框“选择最大的值”，分区4个就够了。</p><p> 上面的步骤有的跳过了，后期有时间再补充。<br> 最后说一句学习一门课程最重要是坚持，大家一起学习加油。祝大家学业有成！</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux 安装 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>linux 入门安装</title>
      <link href="/Linux/index.html"/>
      <url>/Linux/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="一，什么是linux"><a href="#一，什么是linux" class="headerlink" title="一，什么是linux"></a>一，什么是linux</h1><p> Linux是一个开源的操作系统，它最初是芬兰的Helsinki大学的一位年轻的学生Linux Torvalds作为爱好开发的。Linus对Minix(一个小型的UNIX系统)很感兴趣，并且决定开发一个比Minix更好的系统。他在1991年开始开发并且当年发布0.02版本，他坚持继续开发直到1994年Linux内核1.0版本的发布。它的内核，就是所有Linux系统的核心，是在GNU通用公共许可证开发和发布的,它的源码是对每个人都是免费的。这个内核建立了Linux操作系统的开发最基本部分。现在有很多公司、组织和团队发布他们自己基于Linux内核开发的操作系统版本。</p><h1 id="二，为啥要学习linux"><a href="#二，为啥要学习linux" class="headerlink" title="二，为啥要学习linux"></a>二，为啥要学习linux</h1><p>  首先技术的价值不在于这个技术有多牛逼，而是这个技术本身给我们带来的价值，所以学习一个技术的时候一定要知道它的使用场景，给我们带来的便利性。Linux 免费，稳定，性能好。<br>  注意点<br>  1.在Linux系统所有的内容都是文件的形式存储<br>  2.我们在学习字符版的Linux系统中，我们所输入的命令是严格区分大小写的<br>  3.Linux中的文件不是通过后缀名来区分文件类型，而是通过权限，具体的后面的教程会讲到<br>  4.windows系统中的程序不能直接拿到Linux系统安装和使用<br>  5.当我们插入U盘或者其他存储设备，Linux不能直接读取使用，我们需要一个挂载的过程，才可以使用。<br><a id="more"></a></p><h1 id="三，安装linux"><a href="#三，安装linux" class="headerlink" title="三，安装linux"></a>三，安装linux</h1><p> 首先介绍一下linux 分区的概念，主要分为2种格式：MBR,GPT.其中MBR 又分为主分区，扩展分区，逻辑分区。<br> 主分区：一个硬盘最多4个，主分区是最小单位，只有一个活动的主分区（用于启动计算机）<br> 扩展分区：一个硬盘最多只有一个扩展分区，内部可以再划分小分区即逻辑分区，不能直接使用，必须划分为逻辑分区。<br> 逻辑分区：从5-？开始编号  sda5……<br> 接下来介绍下我们练习时候的一个分区规划：<br> Sda1  boot   1G<br> Sda2  /      50G<br> Sda3  /data  30G<br> Sda4<br> Sda5  swap   2G    物理内存的2倍  可以通过free -h 查看</p><p> #（1）安装Vmware虚拟机<br>   <img src="Linux/20180303150433729.jpg" alt="logo"><br>   <img src="Linux/2.jpg" alt="logo"><br>   <img src="Linux/3.jpg" alt="logo"><br>   <img src="Linux/4.jpg" alt="logo"></p><p>  #（1）给虚拟机安装Linux系统<br>   <img src="Linux/5.png" alt="logo"><br>   <img src="Linux/6.png" alt="logo"><br>   <img src="Linux/7.png" alt="logo"></p><p>   系统的安装还是比较简单的，不一个一个列出了，有点困了，以后有时间补充。下面重点说下挂载点概念</p><p>   给我们的Linux系统区分并且格式化，我们在安装windows系统的时候也需要对硬盘进行分区并且进行格式化操作。没有格式化的硬盘是不能保存文件的。请勿弄错，弄错可能会导致无法启动Linux。我们看到的sda是我们的第一块硬盘，我们选择标准分区，然后点击创建。<br> 什么是挂载点？<br>   挂载就是相当于我们windows给硬盘分区格式化的一个过程，挂载点就相当于我们windows系统中的C盘、D盘、E盘。<br> 1 选择系统挂载点，第一步先选择Boot，Boot是我们系统启动时所需要的，大小200兆就足够了。（下图2）<br> 2 swap分区，swap在分区的时候是没有挂载点的，因为swap不是给我们用户使用的，而是提供给linux内核进行使用。大小1G就够了，  我们在给swap分区，在挂载点是找不到swap的，在挂载点下有个系统类型选择swap即可。（下图3）<br> 3 然后再分data分区，用于我们学习测试使用。<br> 4 最后在给 “根目录”分区，根目录就是在选择挂载点的第一个 “/”,然后下面有个选择框“选择最大的值”，分区4个就够了。</p><p> 上面的步骤有的跳过了，后期有时间再补充。<br> 最后说一句学习一门课程最重要是坚持，大家一起学习加油。祝大家学业有成！</p>]]></content>
      
    </entry>
    
    <entry>
      <title>文章分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>mytest</title>
      <link href="/mytest/index.html"/>
      <url>/mytest/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>net</title>
      <link href="/net/index.html"/>
      <url>/net/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>python</title>
      <link href="/python/index.html"/>
      <url>/python/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>sql</title>
      <link href="/sql/index.html"/>
      <url>/sql/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/Linux/vsmarkdown.css"/>
      <url>/Linux/vsmarkdown.css</url>
      
        <content type="html"><![CDATA[@charset "utf-8";/** * vscode-markdown.css */h1, h2, h3, h4, h5, h6, p, blockquote { margin: 0; padding: 0;}body { font-family: "PingFang SC", "Hiragino Sans GB", Helvetica, Arial, sans-serif; padding: 1em; margin: auto; max-width: 42em; color: #737373; background-color: white; margin: 10px 13px 10px 13px;}table { margin: 10px 0 15px 0; border-collapse: collapse;}td, th { border: 1px solid #ddd; padding: 3px 10px;}th { padding: 5px 10px; }a { color: #0069d6; }a:hover { color: #0050a3; text-decoration: none;}a img { border: none; }p { margin-bottom: 9px; }h1, h2, h3, h4, h5, h6 { color: #404040; line-height: 36px;}h1 { margin-bottom: 18px; font-size: 30px; }h2 { font-size: 24px; }h3 { font-size: 18px; }h4 { font-size: 16px; }h5 { font-size: 14px; }h6 { font-size: 13px; }hr { margin: 0 0 19px; border: 0; border-bottom: 1px solid #ccc;}blockquote{ color:#666666; margin:0; padding-left: 3em; border-left: 0.5em #EEE solid; font-family: "STKaiti", georgia, serif;}code, pre { font-family: Monaco, Andale Mono, Courier New, monospace; font-size: 12px;}code { background-color: #ffffe0; border: 1px solid orange; color: rgba(0, 0, 0, 0.75); padding: 1px 3px; -webkit-border-radius: 3px; -moz-border-radius: 3px; border-radius: 3px;}pre { display: block; background-color: #f8f8f8;  border: 1px solid #2f6fab; border-radius: 3px; overflow: auto; padding: 14px; white-space: pre-wrap; word-wrap: break-word;}pre code { background-color: inherit; border: none;  padding: 0;}sup { font-size: 0.83em; vertical-align: super; line-height: 0;}* { -webkit-print-color-adjust: exact;}@media screen and (min-width: 914px) {   body { width: 854px; margin: 10px auto; }}@media print {   body, code, pre code, h1, h2, h3, h4, h5, h6 { color: black; }   table, pre { page-break-inside: avoid; }}]]></content>
      
    </entry>
    
  
</search>
